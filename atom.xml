<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2018-03-31T00:08:24.093Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Go Channel 应用模式]]></title>
    <link href="http://colobu.com/2018/03/26/channel-patterns/"/>
    <id>http://colobu.com/2018/03/26/channel-patterns/</id>
    <published>2018-03-26T14:00:35.000Z</published>
    <updated>2018-03-31T00:05:26.691Z</updated>
    <content type="html"><![CDATA[<p>Channel是Go中的一种类型，和goroutine一起为Go提供了并发技术， 它在开发中得到了广泛的应用。Go鼓励人们通过Channel在goroutine之间传递数据的引用(就像把数据的owner从一个goroutine传递给另外一个goroutine), <a href="http://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>总结了这么一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>在 <a href="https://golang.org/ref/mem" target="_blank" rel="external">Go内存模型</a>指出了channel作为并发控制的一个特性：</p>
<blockquote>
<p>A send on a channel happens before the corresponding receive from that channel completes. (Golang Spec)</p>
</blockquote>
<p>除了正常的在goroutine之间安全地传递共享数据， Channel还可以玩出很多的花样(模式)， 本文列举了一些channel的应用模式。</p>
<p>促成本文诞生的因素主要包括：</p>
<ol>
<li>eapache的channels库</li>
<li>concurrency in go 这本书</li>
<li>Francesc Campoy的 justforfun系列中关于merge channel的实现</li>
<li>我在出版Scala集合手册这本书中对Scala集合的启发</li>
</ol>
<p>下面就让我们以实例的方式看看这么模式吧。</p>
<a id="more"></a>
<h2 id="Lock/TryLock_模式">Lock/TryLock 模式</h2>
<p>我们知道， Go的标准库<code>sync</code>有<code>Mutex</code>,可以用来作为锁，但是<code>Mutex</code>却没有实现<code>TryLock</code>方法。</p>
<p>我们对于<code>TryLock</code>的定义是当前goroutine尝试获得锁， 如果成功，则获得了锁，返回true, 否则返回false。我们可以使用这个方法避免在获取锁的时候当前goroutine被阻塞住。</p>
<p>本来，这是一个常用的功能，在一些其它编程语言中都有实现，为什么Go中没有实现的？<a href="https://github.com/golang/go/issues/6123" target="_blank" rel="external">issue#6123</a>有详细的讨论，在我看来，Go核心组成员本身对这个特性没有积极性，并且认为通过channel可以实现相同的方式。</p>
<h3 id="Hacked_Lock/TryLock_模式">Hacked Lock/TryLock 模式</h3>
<p>其实，对于标准库的<code>sync.Mutex</code>要增加这个功能很简单，下面的方式就是通过<code>hack</code>的方式为<code>Mutex</code>实现了<code>TryLock</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mutexLocked =<span class="number"> 1</span> &lt;&lt; <span class="constant">iota</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	mu sync.Mutex</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	m.mu.Lock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	m.mu.Unlock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.CompareAndSwapInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.mu)),<span class="number"> 0</span>, mutexLocked)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> atomic.LoadInt32((*<span class="typename">int32</span>)(unsafe.Pointer(&m.mu))) == mutexLocked</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果你看一下<code>Mutex</code>实现的源代码，就很容易理解上面的这段代码了，因为<code>mutex</code>实现锁主要利用<code>CAS</code>对它的一个int32字段做操作。</p>
<p>上面的代码还额外增加了一个<code>IsLocked</code>方法，不过这个方法一般不常用，因为查询和加锁这两个方法执行的时候不是一个原子的操作，素以这个方法一般在调试和打日志的时候可能有用。</p>
<h3 id="TryLock_By_Channel">TryLock By Channel</h3>
<p>既然标准库中不准备在<code>Mutex</code>上增加这个方法，而是推荐使用channel来实现，那么就让我们看看如何使用 channel来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	ch <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewMutex() *Mutex {</div><div class="line">	mu := &Mutex{<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)}</div><div class="line">	mu.ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">	<span class="keyword">return</span> mu</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	&lt;-m.ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-m.ch:</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.ch) ==<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>主要是利用channel边界情况下的阻塞特性实现的。</p>
<p>你还可以将缓存的大小从1改为n,用来处理n个锁(资源)。</p>
<h3 id="TryLock_with_Timeout">TryLock with Timeout</h3>
<p>有时候，我们在获取一把锁的时候，由于有竞争的关系，在锁被别的goroutine拥有的时候，当前goroutine没有办法立即获得锁，只能阻塞等待。标准库并没有提供等待超时的功能，我们尝试实现它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> {</div><div class="line">	ch <span class="keyword">chan</span> <span class="keyword">struct</span>{}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewMutex() *Mutex {</div><div class="line">	mu := &Mutex{<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{},<span class="number"> 1</span>)}</div><div class="line">	mu.ch &lt;- <span class="keyword">struct</span>{}{}</div><div class="line">	<span class="keyword">return</span> mu</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Lock() {</div><div class="line">	&lt;-m.ch</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) Unlock() {</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> m.ch &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"unlock of unlocked mutex"</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) TryLock(timeout time.Duration) <span class="typename">bool</span> {</div><div class="line">	timer := time.NewTimer(timeout)</div><div class="line">	<span class="keyword">select</span> {</div><div class="line">	<span class="keyword">case</span> &lt;-m.ch:</div><div class="line">		timer.Stop()</div><div class="line">		<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">	<span class="keyword">case</span> &lt;-time.After(timeout):</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Mutex) IsLocked() <span class="typename">bool</span> {</div><div class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.ch) ==<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你也可以把它用<code>Context</code>来改造，不是利用超时，而是利用<code>Context</code>来取消/超时获得锁的操作，这个作业留给读者来实现。</p>
<h2 id="Or_Channel_模式">Or Channel 模式</h2>
<p>当你等待多个信号的时候，如果收到任意一个信号， 就执行业务逻辑，忽略其它的还未收到的信号。</p>
<p>举个例子， 我们往提供相同服务的n个节点发送请求，只要任意一个服务节点返回结果，我们就可以执行下面的业务逻辑，其它n-1的节点的请求可以被取消或者忽略。当n=2的时候，这就是<code>back request</code>模式。 这样可以用资源来换取latency的提升。</p>
<p>需要注意的是，当收到任意一个信号的时候，<strong>其它信号都被忽略</strong>。如果用channel来实现，只要从任意一个channel中接收到一个数据，那么所有的channel都可以被关闭了(依照你的实现，但是输出的channel肯定会被关闭)。</p>
<p>有三种实现的方式: goroutine、reflect和递归。</p>
<h3 id="Goroutine方式">Goroutine方式</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">var</span> once sync.Once</div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> chans {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> &lt;-c:</div><div class="line">					once.Do(<span class="keyword">func</span>() { <span class="built_in">close</span>(out) })</div><div class="line">				<span class="keyword">case</span> &lt;-out:</div><div class="line">				}</div><div class="line">			}(c)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>or</code>函数可以处理n个channel,它为每个channel启动一个goroutine，只要任意一个goroutine从channel读取到数据，输出的channel就被关闭掉了。</p>
<p>为了避免并发关闭输出channel的问题，关闭操作只执行一次。</p>
<h3 id="Reflect方式">Reflect方式</h3>
<p>Go的反射库针对select语句有专门的数据(<code>reflect.SelectCase</code>)和函数(<code>reflect.Select</code>)处理。<br>所以我们可以利用反射“随机”地从一组可选的channel中接收数据，并关闭输出channel。</p>
<p>这种方式看起来更简洁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> channels<span class="number">[0</span>]</div><div class="line">	}</div><div class="line"></div><div class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</div><div class="line">		<span class="keyword">var</span> cases []reflect.SelectCase</div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> channels {</div><div class="line">			cases = <span class="built_in">append</span>(cases, reflect.SelectCase{</div><div class="line">				Dir:  reflect.SelectRecv,</div><div class="line">				Chan: reflect.ValueOf(c),</div><div class="line">			})</div><div class="line">		}</div><div class="line"></div><div class="line">		reflect.Select(cases)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> orDone</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递归方式">递归方式</h3>
<p>递归方式一向是比较开脑洞的实现，下面的方式就是分而治之的方式，逐步合并channel，最终返回一个channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> or(channels ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> channels<span class="number">[0</span>]</div><div class="line">	}</div><div class="line"></div><div class="line">	orDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(orDone)</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> <span class="built_in">len</span>(channels) {</div><div class="line">		<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-channels<span class="number">[0</span>]:</div><div class="line">			<span class="keyword">case</span> &lt;-channels<span class="number">[1</span>]:</div><div class="line">			}</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			m := <span class="built_in">len</span>(channels) /<span class="number"> 2</span></div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-or(channels[:m]...):</div><div class="line">			<span class="keyword">case</span> &lt;-or(channels[m:]...):</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> orDone</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在后面的扇入(合并)模式中，我们还是会使用相同样的递归模式来合并多个输入channel，根据 justforfun 的测试结果，这种递归的方式要比goroutine、Reflect更有效。</p>
<h2 id="Or-Done-Channel模式">Or-Done-Channel模式</h2>
<p>这种模式是我们经常使用的一种模式，通过一个信号channel(done)来控制(取消)输入channel的处理。</p>
<p>一旦从done channel中读取到一个信号，或者done channel被关闭， 输入channel的处理则被取消。</p>
<p>这个模式提供一个简便的方法，把done channel 和 输入 channel 融合成一个输出channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> orDone(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-c:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- v:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="扇入模式">扇入模式</h2>
<p>扇入模式(FanIn)是将多个同样类型的输入channel合并成一个同样类型的输出channel，也就是channel的合并。</p>
<h3 id="Goroutine方式-1">Goroutine方式</h3>
<p>每个channel起一个goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanIn(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">		wg.Add(<span class="built_in">len</span>(chans))</div><div class="line"></div><div class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> chans {</div><div class="line">			<span class="keyword">go</span> <span class="keyword">func</span>(c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">				<span class="keyword">for</span> v := <span class="keyword">range</span> c {</div><div class="line">					out &lt;- v</div><div class="line">				}</div><div class="line">				wg.Done()</div><div class="line">			}(c)</div><div class="line">		}</div><div class="line"></div><div class="line">		wg.Wait()</div><div class="line">		<span class="built_in">close</span>(out)</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect">Reflect</h3>
<p>利用反射库针对select语句的处理合并输入channel。</p>
<p>下面这种实现方式其实还是有些问题的， 在输入channel读取比较均匀的时候比较有效，否则性能比较低下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">func fanInReflect(chans <span class="keyword">...</span>&lt;-chan interface{}) &lt;-chan interface{} {</div><div class="line">	out := make(chan interface{})</div><div class="line">	go func() {</div><div class="line">		defer close(out)</div><div class="line">		var cases []reflect.SelectCase</div><div class="line">		<span class="keyword">for</span> _, c := range chans {</div><div class="line">			cases = append(cases, reflect.SelectCase{</div><div class="line">				Dir:  reflect.SelectRecv,</div><div class="line">				Chan: reflect.ValueOf(c),</div><div class="line">			})</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> len(cases) &gt; <span class="number">0</span> {</div><div class="line">			i, v, ok := reflect.Select(cases)</div><div class="line">			<span class="keyword">if</span> !ok { //remove this case</div><div class="line">				cases = append(cases[:i], cases[i+<span class="number">1</span>:]<span class="keyword">...</span>)</div><div class="line">				continue</div><div class="line">			}</div><div class="line">			out &lt;- v.Interface()</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> out</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="递归方式-1">递归方式</h3>
<p>这种方式虽然理解起来不直观，但是性能还是不错的(输入channel不是很多的情况下递归层级不会很高，不会成为瓶颈)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanInRec(chans ...&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(chans) {</div><div class="line">	<span class="keyword">case</span><span class="number"> 0</span>:</div><div class="line">		c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">		<span class="built_in">close</span>(c)</div><div class="line">		<span class="keyword">return</span> c</div><div class="line">	<span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">		<span class="keyword">return</span> chans<span class="number">[0</span>]</div><div class="line">	<span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">		<span class="keyword">return</span> mergeTwo(chans<span class="number">[0</span>], chans<span class="number">[1</span>])</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		m := <span class="built_in">len</span>(chans) /<span class="number"> 2</span></div><div class="line">		<span class="keyword">return</span> mergeTwo(</div><div class="line">			fanInRec(chans[:m]...),</div><div class="line">			fanInRec(chans[m:]...))</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> mergeTwo(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(c)</div><div class="line">		<span class="keyword">for</span> a != <span class="constant">nil</span> || b != <span class="constant">nil</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-a:</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					a = <span class="constant">nil</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				}</div><div class="line">				c &lt;- v</div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-b:</div><div class="line">				<span class="keyword">if</span> !ok {</div><div class="line">					b = <span class="constant">nil</span></div><div class="line">					<span class="keyword">continue</span></div><div class="line">				}</div><div class="line">				c &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> c</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Tee模式">Tee模式</h2>
<p>扇出模式(FanOut)是将一个输入channel扇出为多个channel。</p>
<p>扇出行为至少可以分为两种：</p>
<ol>
<li>从输入channel中读取一个数据，发送给每个输入channel，这种模式称之为Tee模式</li>
<li>从输入channel中读取一个数据，在输出channel中选择一个channel发送</li>
</ol>
<p>本节只介绍第一种情况，下一节介绍第二种情况</p>
<h3 id="Goroutine方式-2">Goroutine方式</h3>
<p>将读取的值发送给每个输出channel， 异步模式可能会产生很多的goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOut(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}, async <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				i := i</div><div class="line">				<span class="keyword">if</span> async {</div><div class="line">					<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">						out[i] &lt;- v</div><div class="line">					}()</div><div class="line">				} <span class="keyword">else</span> {</div><div class="line">					out[i] &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect方式-1">Reflect方式</h3>
<p>这种模式一旦一个输出channel被阻塞，可能会导致后续的处理延迟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOutReflect(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(out))</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">			cases[i].Dir = reflect.SelectSend</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">				cases[i].Chan = reflect.ValueOf(out[i])</div><div class="line">				cases[i].Send = reflect.ValueOf(v)</div><div class="line">			}</div><div class="line"></div><div class="line">			<span class="keyword">for</span> _ = <span class="keyword">range</span> cases { <span class="comment">// for each channel</span></div><div class="line">				chosen, _, _ := reflect.Select(cases)</div><div class="line">				cases[chosen].Chan = reflect.ValueOf(<span class="constant">nil</span>)</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="分布模式">分布模式</h2>
<p>分布模式将从输入channel中读取的值往输出channel中的其中一个发送。</p>
<h3 id="Goroutine方式-3">Goroutine方式</h3>
<p>roundrobin的方式选择输出channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOut(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		<span class="comment">// roundrobin</span></div><div class="line">		<span class="keyword">var</span> i =<span class="number"> 0</span></div><div class="line">		<span class="keyword">var</span> n = <span class="built_in">len</span>(out)</div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			out[i] &lt;- v</div><div class="line">			i = (i +<span class="number"> 1</span>) % n</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Reflect方式-2">Reflect方式</h3>
<p>利用发射随机的选择。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> fanOutReflect(ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, out []<span class="keyword">chan</span> <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; <span class="built_in">len</span>(out); i++ {</div><div class="line">				<span class="built_in">close</span>(out[i])</div><div class="line">			}</div><div class="line">		}()</div><div class="line"></div><div class="line">		cases := <span class="built_in">make</span>([]reflect.SelectCase, <span class="built_in">len</span>(out))</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">			cases[i].Dir = reflect.SelectSend</div><div class="line">			cases[i].Chan = reflect.ValueOf(out[i])</div><div class="line"></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> ch {</div><div class="line">			v := v</div><div class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> cases {</div><div class="line">				cases[i].Send = reflect.ValueOf(v)</div><div class="line">			}</div><div class="line">			_, _, _ = reflect.Select(cases)</div><div class="line">		}</div><div class="line">	}()</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="eapache">eapache</h2>
<p><a href="https://github.com/eapache/channels" target="_blank" rel="external">eapache/channels</a>提供了一些channel应用模式的方法，比如上面的扇入扇出模式等。</p>
<p>因为go本身的channel无法再进行扩展， <code>eapache/channels</code>库定义了自己的channel接口，并提供了与channel方便的转换。</p>
<p><code>eapache/channels</code> 提供了四个方法:</p>
<ul>
<li>Distribute： 从输入channel读取值，发送到其中一个输出channel中。当输入channel关闭后，输出channel都被关闭</li>
<li>Tee: 从输入channel读取值，发送到所有的输出channel中。当输入channel关闭后，输出channel都被关闭</li>
<li>Multiplex: 合并输入channel为一个输出channel， 当所有的输入都关闭后，输出才关闭</li>
<li>Pipe: 将两个channel串起来</li>
</ul>
<p>同时对上面的四个函数还提供了<code>WeakXXX</code>的函数，输入关闭后不会关闭输出。</p>
<p>下面看看对应的函数的例子。</p>
<h3 id="Distribute">Distribute</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testDist() {</div><div class="line">	fmt.Println(<span class="string">"dist:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	outputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Distribute(a, outputs<span class="number">[0</span>], outputs<span class="number">[1</span>], outputs<span class="number">[2</span>], outputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakDistribute(a, outputs[0], outputs[1], outputs[2], outputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 6</span>; i++ {</div><div class="line">		<span class="keyword">var</span> v <span class="keyword">interface</span>{}</div><div class="line">		<span class="keyword">var</span> j <span class="typename">int</span></div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[0</span>].Out():</div><div class="line">			j =<span class="number"> 0</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[1</span>].Out():</div><div class="line">			j =<span class="number"> 1</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[2</span>].Out():</div><div class="line">			j =<span class="number"> 2</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[3</span>].Out():</div><div class="line">			j =<span class="number"> 3</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"channel#%d: %d\n"</span>, j, v)</div><div class="line">	}</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Tee">Tee</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testTee() {</div><div class="line">	fmt.Println(<span class="string">"tee:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	outputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Tee(a, outputs<span class="number">[0</span>], outputs<span class="number">[1</span>], outputs<span class="number">[2</span>], outputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakTee(a, outputs[0], outputs[1], outputs[2], outputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 20</span>; i++ {</div><div class="line">		<span class="keyword">var</span> v <span class="keyword">interface</span>{}</div><div class="line">		<span class="keyword">var</span> j <span class="typename">int</span></div><div class="line">		<span class="keyword">select</span> {</div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[0</span>].Out():</div><div class="line">			j =<span class="number"> 0</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[1</span>].Out():</div><div class="line">			j =<span class="number"> 1</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[2</span>].Out():</div><div class="line">			j =<span class="number"> 2</span></div><div class="line">		<span class="keyword">case</span> v = &lt;-outputs<span class="number">[3</span>].Out():</div><div class="line">			j =<span class="number"> 3</span></div><div class="line">		}</div><div class="line">		fmt.Printf(<span class="string">"channel#%d: %d\n"</span>, j, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Multiplex">Multiplex</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testMulti() {</div><div class="line">	fmt.Println(<span class="string">"multi:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	inputs := []channels.Channel{</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">		channels.NewNativeChannel(channels.None),</div><div class="line">	}</div><div class="line"></div><div class="line">	channels.Multiplex(a, inputs<span class="number">[0</span>], inputs<span class="number">[1</span>], inputs<span class="number">[2</span>], inputs<span class="number">[3</span>])</div><div class="line">	<span class="comment">//channels.WeakMultiplex(a, inputs[0], inputs[1], inputs[2], inputs[3])</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			<span class="keyword">for</span> j := <span class="keyword">range</span> inputs {</div><div class="line">				inputs[j].In() &lt;- i</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> inputs {</div><div class="line">			inputs[i].Close()</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> a.Out() {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Pipe">Pipe</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> testPipe() {</div><div class="line">	fmt.Println(<span class="string">"pipe:"</span>)</div><div class="line">	a := channels.NewNativeChannel(channels.None)</div><div class="line">	b := channels.NewNativeChannel(channels.None)</div><div class="line"></div><div class="line">	channels.Pipe(a, b)</div><div class="line">	<span class="comment">// channels.WeakPipe(a, b)</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 5</span>; i++ {</div><div class="line">			a.In() &lt;- i</div><div class="line">		}</div><div class="line">		a.Close()</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> b.Out() {</div><div class="line">		fmt.Printf(<span class="string">"%d "</span>, v)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="集合操作">集合操作</h2>
<p>从channel的行为来看，它看起来很像一个数据流，所以我们可以实现一些类似Scala 集合的操作。</p>
<p>Scala的集合类提供了丰富的操作(方法)， 当然其它的一些编程语言或者框架也提供了类似的方法， 比如Apache Spark、Java Stream、ReactiveX等。</p>
<p>下面列出了一些方法的实现，我相信经过一些人的挖掘，相关的方法可以变成一个很好的类库，但是目前我们先看一些例子。</p>
<h3 id="skip">skip</h3>
<p>skip函数是从一个channel中跳过开一些数据，然后才开始读取。</p>
<h4 id="skipN">skipN</h4>
<p>skipN跳过开始的N个数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipN(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, num <span class="typename">int</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; num; i++ {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="skipFn">skipFn</h4>
<p>skipFn 提供Fn函数为true的数据，比如跳过偶数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipFn(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !fn(v) {</div><div class="line">					takeStream &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="skipWhile">skipWhile</h4>
<p>跳过开头函数fn为true的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> skipWhile(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		take := <span class="constant">false</span></div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !take {</div><div class="line">					take = !fn(v)</div><div class="line">					<span class="keyword">if</span> !take {</div><div class="line">						<span class="keyword">continue</span></div><div class="line">					}</div><div class="line">				}</div><div class="line">				takeStream &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="take">take</h3>
<p>skip的反向操作，读取一部分数据。</p>
<h4 id="takeN">takeN</h4>
<p>takeN 读取开头N个数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeN(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, num <span class="typename">int</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; num; i++ {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> takeStream &lt;- &lt;-valueStream:</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="takeFn">takeFn</h4>
<p>takeFn 只筛选满足fn的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeFn(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> fn(v) {</div><div class="line">					takeStream &lt;- v</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="takeWhile">takeWhile</h4>
<p>takeWhile只挑选开头满足fn的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> takeWhile(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="typename">bool</span>) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	takeStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(takeStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v := &lt;-valueStream:</div><div class="line">				<span class="keyword">if</span> !fn(v) {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				takeStream &lt;- v</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> takeStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="flat">flat</h3>
<p>平展(flat)操作是一个有趣的操作。</p>
<p>如果输入是一个channel,channel中的数据还是相同类型的channel， 那么flat将返回一个输出channel,输出channel中的数据是输入的各个channel中的数据。</p>
<p>它与扇入不同，扇入的输入channel在调用的时候就是固定的，并且以数组的方式提供，而flat的输入是一个channel，可以运行时随时的加入channel。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> orDone(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			<span class="keyword">case</span> v, ok := &lt;-c:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- v:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div><div class="line"><span class="keyword">func</span> flat(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>{}, chanStream &lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	valStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			<span class="keyword">var</span> stream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}</div><div class="line">			<span class="keyword">select</span> {</div><div class="line">			<span class="keyword">case</span> maybeStream, ok := &lt;-chanStream:</div><div class="line">				<span class="keyword">if</span> ok == <span class="constant">false</span> {</div><div class="line">					<span class="keyword">return</span></div><div class="line">				}</div><div class="line">				stream = maybeStream</div><div class="line">			<span class="keyword">case</span> &lt;-done:</div><div class="line">				<span class="keyword">return</span></div><div class="line">			}</div><div class="line">			<span class="keyword">for</span> val := <span class="keyword">range</span> orDone(done, stream) {</div><div class="line">				<span class="keyword">select</span> {</div><div class="line">				<span class="keyword">case</span> valStream &lt;- val:</div><div class="line">				<span class="keyword">case</span> &lt;-done:</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}()</div><div class="line">	<span class="keyword">return</span> valStream</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="map">map</h3>
<p>map和reduce是一组常用的操作。</p>
<p>map将一个channel映射成另外一个channel， channel的类型可以不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> mapChan(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(<span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}) &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{} {</div><div class="line">	out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</div><div class="line">	<span class="keyword">if</span> in == <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">close</span>(out)</div><div class="line">		<span class="keyword">return</span> out</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(out)</div><div class="line"></div><div class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> in {</div><div class="line">			out &lt;- fn(v)</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为<code>map</code>是go的关键字，所以我们不能命名函数类型为<code>map</code>,这里用<code>mapChan</code>代替。</p>
<p>比如你可以处理一个公司员工工资的channel， 输出一个扣税之后的员工工资的channel。</p>
<h3 id="reduce">reduce</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> reduce(in &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>{}, fn <span class="keyword">func</span>(r, v <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{}) <span class="keyword">interface</span>{} {</div><div class="line">	<span class="keyword">if</span> in == <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">	}</div><div class="line"></div><div class="line">	out := &lt;-in</div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> in {</div><div class="line">		out = fn(out, v)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">return</span> out</div><div class="line">}</div><div class="line"></div><div class="line">你可以用<span class="string">`reduce`</span>实现<span class="string">`sum`</span>、<span class="string">`max`</span>、<span class="string">`min`</span>等聚合操作。</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>本文列出了channel的一些深入应用的模式，相信通过阅读本文，你可以更加深入的了解Go的channel类型，并在开发中灵活的应用channel。也欢迎你在评论中提出更多的 channel的应用模式。</p>
<p>所有的代码可以在github上找到: <a href="https://github.com/smallnest/channels" target="_blank" rel="external">smallnest/channels</a>。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://github.com/kat-co/concurrency-in-go-src" target="_blank" rel="external">https://github.com/kat-co/concurrency-in-go-src</a></li>
<li><a href="https://github.com/campoy/justforfunc/tree/master/27-merging-chans" target="_blank" rel="external">https://github.com/campoy/justforfunc/tree/master/27-merging-chans</a></li>
<li><a href="https://github.com/eapache/channels" target="_blank" rel="external">https://github.com/eapache/channels</a></li>
<li><a href="https://github.com/LK4D4/trylock" target="_blank" rel="external">https://github.com/LK4D4/trylock</a></li>
<li><a href="https://stackoverflow.com/questions/36391421/explain-dont-communicate-by-sharing-memory-share-memory-by-communicating" target="_blank" rel="external">https://stackoverflow.com/questions/36391421/explain-dont-communicate-by-sharing-memory-share-memory-by-communicating</a></li>
<li><a href="https://github.com/lrita/gosync" target="_blank" rel="external">https://github.com/lrita/gosync</a></li>
<li><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="external">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Channel是Go中的一种类型，和goroutine一起为Go提供了并发技术， 它在开发中得到了广泛的应用。Go鼓励人们通过Channel在goroutine之间传递数据的引用(就像把数据的owner从一个goroutine传递给另外一个goroutine), <a href="http://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a>总结了这么一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>在 <a href="https://golang.org/ref/mem" target="_blank" rel="external">Go内存模型</a>指出了channel作为并发控制的一个特性：</p>
<blockquote>
<p>A send on a channel happens before the corresponding receive from that channel completes. (Golang Spec)</p>
</blockquote>
<p>除了正常的在goroutine之间安全地传递共享数据， Channel还可以玩出很多的花样(模式)， 本文列举了一些channel的应用模式。</p>
<p>促成本文诞生的因素主要包括：</p>
<ol>
<li>eapache的channels库</li>
<li>concurrency in go 这本书</li>
<li>Francesc Campoy的 justforfun系列中关于merge channel的实现</li>
<li>我在出版Scala集合手册这本书中对Scala集合的启发</li>
</ol>
<p>下面就让我们以实例的方式看看这么模式吧。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DHT 分布式哈希表]]></title>
    <link href="http://colobu.com/2018/03/26/distributed-hash-table/"/>
    <id>http://colobu.com/2018/03/26/distributed-hash-table/</id>
    <published>2018-03-26T08:02:45.000Z</published>
    <updated>2018-03-26T13:58:03.867Z</updated>
    <content type="html"><![CDATA[<p>本文主要整理维基百科中英文和百度百科等资料，算是对 <code>DHT</code> 技术做一个综述，基本都是摘自参考资料中的文档。</p>
<a id="more"></a>
<h2 id="DHT">DHT</h2>
<p><img src="DHT.png" alt=""></p>
<p>分布式哈希表（distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个键（key）的集合分散到所有在分布式系统中的节点。这里的节点类似哈希表中的存储位置。分布式哈希表通常是为了拥有大量节点的系统，而且系统的节点常常会加入或离开。</p>
<p>研究分布式哈希表的主要动机是为了开发点对点系统，像是Napster、Gnutella、BitTorrent及Freenet。这些系统使用分散在互联网上的各项资源以提供文件分享服务，特别在带宽及硬盘存储空间上受益良多。</p>
<p>这些系统使用不同的方法来解决如何找到拥有某数据的节点的问题。Napster使用中央的索引服务器：每个节点加入网络的同时，会将他们所拥有的文件列表发送给服务器，这使得服务器可以进行搜索并将结果回传给进行查询的节点。但中央索引服务器让整个系统易受攻击，且可能造成法律问题。于是，Gnutella和相似的网络改用大量查询模式（flooding query model）：每次搜索都会把查询消息广播给网络上的所有节点。虽然这个方式能够防止单点故障（single point of failure），但比起Napster来说却极没效率。</p>
<p>最后，Freenet使用了完全分布式的系统，但它建置了一套使用经验法则的基于键的路由方法（key based routing）。在这个方法中，每个文件与一个键相结合，而拥有相似键的文件会倾向被相似的节点构成的集合所保管。于是查询消息就可以根据它所提供的键被路由到该集合，而不需要经过所有的节点。然而，Freenet并不保证存在网络上的数据在查询时一定会被找到。</p>
<p>分布式哈希表为了达到Gnutella与Freenet的分散性（decentralization）以及Napster的效率与正确结果，使用了较为结构化的基于键的路由方法。不过分布式哈希表也有个Freenet有的缺点，就是只能作精确搜索，而不能只提供部分的关键字；但这个功能可以在分布式哈希表的上层实现。</p>
<p>最初的四项分布式哈希表技术——内容可定址网络（Content addressable network，CAN）、Chord（Chord project）、Pastry（Pastry (DHT)），以及Tapestry (DHT)（Tapestry (DHT)）皆同时于2001年发表。从那时开始，相关的研究便一直十分活跃。在学术领域以外，分布式哈希表技术已经被应用在BitTorrent及CoralCDN（Coral Content Distribution Network）等。</p>
<p>分布式散列表本质上强调以下特性：</p>
<ul>
<li><strong>离散性</strong>：构成系统的节点并没有任何中央式的协调机制。</li>
<li><strong>伸缩性</strong>：即使有成千上万个节点，系统仍然应该十分有效率。</li>
<li><strong>容错性</strong>：即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度。</li>
</ul>
<p>要达到以上的目标，有一个关键的技术：任一个节点只需要与系统中的部分节点沟通，当成员改变的时候，只有一部分的工作（例如数据或键的发送，哈希表的改变等）必须要完成。</p>
<p>分布式散列表的结构可以分成几个主要的组件。其基础是一个抽象的<code>键空间</code>（keyspace），例如说所有<strong>160</strong>位长的字符串集合。<code>键空间分区</code>（keyspace partitioning）将<code>键空间</code>分区成数个，并指定到在此系统的节点中。而<code>延展网络</code>则连接这些节点，并让他们能够借由在<code>键空间</code>内的任一值找到拥有该值的节点。</p>
<p>假设<code>键空间</code>是一个160位长的字符串集合。为了在分布式散列表中存储一个文件，名称为<code>filename</code>且内容为<code>data</code>，我们计算出<code>filename</code>的SHA1散列值——一个160位的键<code>k</code>——并将消息<code>put(k,data)</code>送给分布式散列表中的任意参与节点。此消息在延展网络中被路由，直到抵达在键空间分区中被指定负责存储关键值<code>k</code>的节点。而<code>(k,data)</code>即存储在该节点。其他的节点只需要重新计算<code>filename</code>的散列值<code>k</code>，然后提交消息<code>get(k)</code>给分布式哈希表中的任意参与节点，以此来找与<code>k</code>相关的数据。此消息也会在延展网络中被路由到负责存储<code>k</code>的节点。而此节点则会负责传回存储的数据<code>data</code>。</p>
<p>基本上，就是一种映射key和节点的算法以及路由的算法。</p>
<p>其一为保证任何的路由路径长度必须尽量短，因而请求能快速地被完成；<br>其二为任一节点的邻近节点数目（又称最大节点度（Degree (graph theory)））必须尽量少，因此维护的花费不会过多。</p>
<h2 id="分布式哈希与一致性哈希">分布式哈希与一致性哈希</h2>
<p>分布式哈希和一致性哈希有什么区别呢？lintong 的<a href="https://www.jianshu.com/p/7beeb52376cc" target="_blank" rel="external">分布式哈希与一致性哈希</a> 一文对它做了清晰而简洁的解释。</p>
<ul>
<li><strong>分布式哈希</strong>: 将哈希表分散在不同的节点上，并且能提供相应的方法来查找， 比如DHT算法</li>
<li><strong>一致性哈希</strong>: 当节点宕机或者扩容的时候，需要重新哈希，一致性哈希实现的 DHT 避免对大量的数据重新哈希, 比如<a href="https://en.wikipedia.org/wiki/Chord_(peer-to-peer" target="_blank" rel="external">Chord DHT</a>). 所以一致性哈希是 DHT 的一种实现，避免在节点变化的时候出现的全部重新哈希的现象. 我不知道为什么wikipedia没有列出memcached client中常用的<a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients" target="_blank" rel="external">libketama</a>，在我看来它也是一个易于理解的一致性哈希的实现。</li>
</ul>
<p>其它的 DHT 的分区实现(Keyspace partitioning)还有:</p>
<ul>
<li><strong>Rendezvous hashing</strong>: 最高随机权重哈希。每个client都会获得服务节点相同的指示符<code>{S1, S2, ..., Sn }</code>， 对于键<code>k</code>, client使用相同的哈希函数计算服务节点的权重<code>w1 = h(S1, k), w2 = h(S2, k), ..., wn = h(Sn, k)</code>，然后总是选择最高权重的节点。</li>
<li><strong>Locality-preserving hashing</strong>: 相近的键总是指派给相近的对象。</li>
</ul>
<h2 id="Kademlia算法">Kademlia算法</h2>
<p><strong>Kademlia</strong>是一种通过 DHT 的协议算法，它是由Petar和David在2002年为P2P网络而设计的。Kademlia规定了网络的结构，也规定了通过节点查询进行信息交换的方式。<br>Kademlia网络节点之间使用<strong>UDP</strong>进行通讯。参与通讯的所有节点形成一张虚拟网（或者叫做覆盖网）。这些节点通过一组数字（或称为节点ID）来进行身份标识。节点ID不仅可以用来做身份标识，还可以用来进行值定位（值通常是文件的散列或者关键词）。</p>
<p>当我们在网络中搜索某些值（即通常搜索存储文件散列或关键词的节点）的时候，Kademlia算法需要知道与这些值相关的键，然后逐步在网络中开始搜索。每一步都会找到一些节点，这些节点的ID与键更为接近，如果有节点直接返回搜索的值或者再也无法找到与键更为接近的节点ID的时候搜索便会停止。</p>
<p>这种搜索值的方法是非常高效的：与其他的分布式哈希表的实现类似，在一个包含n个节点的系统的值的搜索中，Kademlia仅访问<code>O(log(n))</code>个节点。</p>
<p><code>Kademlia</code>简称为<code>Kad</code>,它使用了一个精妙的算法，来计算节点之间的&quot;距离&quot; (这里的距离不是地理空间的距离，而是路由的跳数)，这个算法就是<code>XOR</code>操作(异或)，因为这个操作和距离的计算类似：</p>
<ul>
<li><code>(A ⊕ B) == (B ⊕ A)</code>:     XOR 符合“交换律”，具备对称性。A和B的距离从哪一个节点计算都是相同的。</li>
<li><code>(A ⊕ A) == 0</code>:    反身性，自己和自己的距离为零。</li>
<li><code>(A ⊕ B) &gt; 0</code>:    两个不同的 key 之间的距离必大于零。</li>
<li><code>(A ⊕ B) + (B ⊕ C) &gt;= (A ⊕ C)</code>:    三角不等式,  A经过B到C的距离总是大于A直接到C的距离。</li>
</ul>
<p>(精妙啊!是如何想起和距离计算联系在一起的？)</p>
<p>Kad使用160位的哈希算法（比如 SHA1），完整的 key 用二进制表示有160位，这样可以容纳2<sup>160</sup>个节点，可以说是不计其数了。</p>
<p>Kad把 key 映射到一个二叉树，每一个 key 都是这个二叉树的<code>叶子</code>。</p>
<h3 id="映射规则"><strong>映射规则</strong></h3>
<ol>
<li>先把 key 以二进制形式表示，然后从高位到低位依次处理。</li>
<li>二进制的第 n 个位就对应了二叉树的第 n 层</li>
<li>如果该位是1，进入左子树，是0则进入右子树（这只是人为约定，反过来处理也可以）</li>
<li>全部位都处理完后，这个 key 就对应了二叉树上的某个叶子</li>
</ol>
<h3 id="二叉树的拆分规则"><strong>二叉树的拆分规则</strong></h3>
<p><img src="kad.png" alt=""></p>
<p>对每一个节点，都可以<strong>按照自己的视角</strong>对整个二叉树进行拆分成最多160个子树。</p>
<p>拆分的规则是：先从根节点开始，把<strong>不包含</strong>自己的那个子树拆分出来；然后在剩下的子树再拆分不包含自己的第二层子树；以此类推，直到最后只剩下自己。</p>
<p>Kad 默认的散列值空间是 <code>m=160</code>（散列值有 160 bit），因此拆分出来的子树<strong>最多</strong>有 160 个（考虑到实际的节点数<strong>远远小于</strong>2<sup>160</sup>，子树的个数会明显小于 160）。</p>
<p>对于每一个节点而言，当它以自己的视角完成子树拆分后，会得到 n 个子树；对于每个子树，如果它都能知道里面的一个节点，那么它就可以利用这 n 个节点进行递归路由，从而到达整个二叉树的<strong>任何一个</strong>节点。</p>
<h3 id="拆子树"><strong>拆子树</strong></h3>
<p>每个节点在完成子树拆分后，只需要知道每个子树里面的一个节点，就足以实现全遍历。但是考虑到健壮性（节点可能宕机或者退出），光知道<strong>一个</strong>显然是不够的，需要知道<strong>多个</strong>才比较保险。</p>
<p>所以 Kad 论文中给出了一个<code>K-桶（K-bucket）</code>的概念。也就是说：每个节点在完成子树拆分后，要记录每个子树里面的 <code>K</code> 个节点。这里所说的 <code>K</code> 值是一个<strong>系统级</strong>的常量。由使用 Kad 的软件系统自己设定（比如 BT 下载使用的 Kad 网络，K 设定为 8）。<br>　　<br><strong>K 桶</strong>其实就是<strong>路由表</strong>。对于某个节点而言，如果<strong>以它自己为视角</strong>拆分了 <strong>n</strong> 个子树，那么它就需要维护 <strong>n</strong> 个路由表，并且每个路由表的<strong>上限</strong>是 K。<br>　<br>说 K 只是一个<strong>上限</strong>，是因为有两种情况使得 K 桶的尺寸会小于 K:</p>
<ol>
<li>距离越近的子树就越小。如果整个子树<strong>可能存在的</strong>节点数小于 K，那么该子树的 K 桶尺寸永远也不可能达到 K。(这是由于K桶对应的距离越近，节点数越少)</li>
<li>有些子树虽然实际上线的节点数超过 K，但是因为种种原因，没有收集到该子树足够多的节点，这也会使得该子树的 K 桶尺寸小于 K。</li>
</ol>
<p>如果选择这 K 个节点呢？<br>Kademlia选择把那些长时间在线的节点存入K桶，这一方法增长了未来某一时刻有效节点的数量，同时也提供了更为稳定的网络。当某个K桶已满，而又发现了相应于该桶的新节点的时候，那么，就首先检查K桶中最早访问的节点，假如该节点仍然存活，那么新节点就被安排到一个附属列表中（作为一个替代缓存）.只有当K桶中的某个节点停止响应的时候，替代cache才被使用。换句话说，新发现的节点只有在老的节点消失后才被使用。</p>
<h3 id="Kademlia协议"><strong>Kademlia协议</strong></h3>
<p>Kademlia协议共有四种消息。</p>
<ul>
<li><strong>PING</strong>消息: 用来测试节点是否仍然在线。</li>
<li><strong>STORE</strong>消息: 在某个节点中存储一个键值对。</li>
<li><strong>FIND_NODE</strong>消息: 消息请求的接收者将返回自己桶中离请求键值最近的K个节点。</li>
<li><strong>FIND_VALUE</strong>消息: 与FIND_NODE一样，不过当请求的接收者存有请求者所请求的键的时候，它将返回相应键的值。</li>
</ul>
<p>每一个RPC消息中都包含一个发起者加入的随机值，这一点确保响应消息在收到的时候能够与前面发送的请求消息匹配。</p>
<h3 id="定位节点"><strong>定位节点</strong></h3>
<p>节点查询可以异步进行，也可以同时进行，同时查询的数量由α表示，一般是3。</p>
<ol>
<li>由查询发起者从自己的k-桶中筛选出若干距离目标ID最近的节点，并向这些节点同时发送异步查询请求；</li>
<li>被查询节点收到请求之后，将从自己的k-桶中找出自己所知道的距离查询目标ID最近的若干个节点，并返回给发起者；</li>
<li>发起者在收到这些返回信息之后，更新自己的结果列表，再次从自己所有已知的距离目标较近的节点中挑选出若干没有请求过的，并重复步骤1；</li>
<li>上述步骤不断重复，直至无法获得比查询者当前已知的k个节点更接近目标的活动节点为止。</li>
<li>在查询过程中，没有及时响应的节点将立即被排除；查询者必须保证最终获得的k个最节点都是活动的。</li>
</ol>
<h3 id="定位资源"><strong>定位资源</strong></h3>
<p>通过把资源信息与键进行映射，资源即可进行定位，杂凑表是典型的用来映射的手段。由于以前的STORE消息，存储节点将会有对应STORE所存储的相关资源的信息。定位资源时，如果一个节点存有相应的资源的值的时候，它就返回该资源，搜索便结束了，除了该点以外，定位资源与定位离键最近的节点的过程相似。</p>
<p>考虑到节点未必都在线的情况，资源的值被存在多个节点上（节点中的K个），并且，为了提供冗余，还有可能在更多的节点上储存值。储存值的节点将定期搜索网络中与储存值所对应的键接近的K个节点并且把值复制到这些节点上，这些节点可作为那些下线的节点的补充。另外还有缓存技术。</p>
<h3 id="加入网络"><strong>加入网络</strong></h3>
<ol>
<li>新节点A必须知道某个引导节点B，并把它加入到自己相应的K-桶中</li>
<li>生成一个随机的节点ID,直到离开网络，该节点会一直使用该ID号</li>
<li>向B（A目前知道的唯一节点）发起一个查询请求（FIND_NODE），请求的ID是自己（就是查询自己）</li>
<li>B收到该请求之后，会先把A的ID加入自己的相应的 K-桶中。并且根据 FIND_NODE 请求的约定，B会找到K个最接近 A 的节点，并返回给 A</li>
<li>A收到这K个节点的ID之后，把他们加入自己的 K-桶</li>
<li>然后A会继续向刚刚拿到的这批节点(还未发送过请求的节点)发送查询请求（协议类型 FIND_NODE），如此往复，直至A建立了足够详细的路由表。</li>
<li>这种“自我定位”将使得Kad的其他节点（收到请求的节点）能够使用A的ID填充他们的K-桶，同时也能够使用那些查询过程的中间节点来填充A的K-桶。这已过程既让A获得了详细的路由表，也让其它节点知道了A节点的加入</li>
</ol>
<h2 id="kad在p2p网络中的应用">kad在p2p网络中的应用</h2>
<p>Kademlia可在文件分享网络中使用，通过制作Kademlia关键字搜索，我们能够在文件分享网络中找到我们需要的文件以供我们下载。由于没有中央服务器存储文件的索引，这部分工作就被平均地分配到所有的客户端中去：</p>
<p>假如一个节点希望分享某个文件，它先根据文件的内容来处理该文件，通过运算，把文件的内容散列成一组数字，该数字在文件分享网络中可被用来标识文件。这组散列数字必须和节点ID有同样的长度，<br>然后，该节点便在网络中搜索ID值与文件的散列值相近的节点，并把它自己的IP地址存储在那些搜索到的节点上，也就是说，它把自己作为文件的源进行了发布。正在进行文件搜索的客户端将使用Kademlia协议来寻找网络上ID值与希望寻找的文件的散列值最近的那个节点，然后取得存储在那个节点上的文件源列表。<br>由于一个键可以对应很多值，即同一个文件可以有多个源，每一个存储源列表的节点可能有不同的文件的源的信息，这样的话，源列表可以从与键值相近的K个节点获得。</p>
<p>文件的散列值通常可以从其他的一些特别的Internet链接的地方获得，或者被包含在从其他某处获得的索引文件中。<br>文件名的搜索可以使用关键词来实现，文件名可以分割成连续的几个关键词，这些关键词都可以散列并且可以和相应的文件名和文件散列储存在网络中。搜索者可以使用其中的某个关键词，联系ID值与关键词散列最近的那个节点，取得包含该关键词的文件列表。由于在文件列表中的文件都有相关的散列值，通过该散列值就可利用上述通常取文件的方法获得要搜索的文件。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://zh.wikipedia.org/wiki/分散式雜湊表" target="_blank" rel="external">https://zh.wikipedia.org/wiki/分散式雜湊表</a></li>
<li><a href="https://en.wikipedia.org/wiki/Distributed_hash_table" target="_blank" rel="external">https://en.wikipedia.org/wiki/Distributed_hash_table</a></li>
<li><a href="https://baike.baidu.com/item/DHT/1007999" target="_blank" rel="external">https://baike.baidu.com/item/DHT/1007999</a></li>
<li><a href="https://www.jianshu.com/p/7beeb52376cc" target="_blank" rel="external">https://www.jianshu.com/p/7beeb52376cc</a></li>
<li><a href="https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html" target="_blank" rel="external">https://program-think.blogspot.com/2017/09/Introduction-DHT-Kademlia-Chord.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要整理维基百科中英文和百度百科等资料，算是对 <code>DHT</code> 技术做一个综述，基本都是摘自参考资料中的文档。</p>
]]>
    
    </summary>
    
      <category term="p2p" scheme="http://colobu.com/tags/p2p/"/>
    
      <category term="区块链" scheme="http://colobu.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8 和 Java 9中并发工具的改变]]></title>
    <link href="http://colobu.com/2018/03/12/Concurrency-Utilities-Enhancements-in-Java-8-Java-9/"/>
    <id>http://colobu.com/2018/03/12/Concurrency-Utilities-Enhancements-in-Java-8-Java-9/</id>
    <published>2018-03-12T09:14:11.000Z</published>
    <updated>2018-03-26T13:58:03.828Z</updated>
    <content type="html"><![CDATA[<p>Java 8 和 Java 9中 <code>concurrent</code>包有了一些改变， 本文对这些改变做了汇总。</p>
<a id="more"></a>
<h2 id="Java_8_中_Concurrent_package的改变">Java 8 中 Concurrent package的改变</h2>
<h3 id="java-util-concurrent中新的类和接口">java.util.concurrent中新的类和接口</h3>
<p>增加了两个新接口和4个新类:</p>
<ol>
<li>接口<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.AsynchronousCompletionTask.html" target="_blank" rel="external">CompletableFuture.AsynchronousCompletionTask</a></li>
<li><p>接口<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" target="_blank" rel="external">CompletionStage<t></t></a></p>
</li>
<li><p>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">CompletableFuture<t></t></a></p>
</li>
<li>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.KeySetView.html" target="_blank" rel="external">ConcurrentHashMap.KeySetView<k,v></k,v></a></li>
<li>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountedCompleter.html" target="_blank" rel="external">CountedCompleter<t></t></a></li>
<li>类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionException.html" target="_blank" rel="external">CompletionException</a></li>
</ol>
<h3 id="java-util-concurrent-ConcurrentHashMap的新方法">java.util.concurrent.ConcurrentHashMap的新方法</h3>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html" target="_blank" rel="external">集合框架</a>在Java 8中做了修订，基于<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/lambda_api_jdk8.html" target="_blank" rel="external">stream</a>和<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8" target="_blank" rel="external">lambda表达式</a>添加了很多聚合方法。因此<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="external"> ConcurrentHashMap </a>也引入了30几个新方法，包括各种<code>foreach</code>方法(<code>forEach</code>, <code>forEachKey</code>, <code>forEachValue</code>, 和 <code>forEachEntry</code>)、搜索方法(<code>search</code>, <code>searchKeys</code>, <code>searchValues</code>, 和 <code>searchEntries</code>)和reduction方法(<code>reduce</code>, <code>reduceToDouble</code>, <code>reduceToLong</code>等)。</p>
<p>也添加了一些其它方法，比如 <code>mappingCount</code>和<code>newKeySet</code>。并且当前版本的<code>ConcurrentHashMap</code>的更适合做cache，因为增加了当键值不存在的时候的检查方法。</p>
<h3 id="java-util-concurrent-atomic中的新类">java.util.concurrent.atomic中的新类</h3>
<p>为了并发计算count、sum， 新引入了<code>DoubleAccumulator</code>, <code>DoubleAdder</code>, <code>LongAccumulator</code>, <code>LongAdder</code>类，比Atomic提供更高的吞吐率。</p>
<h3 id="java-util-concurrent-ForkJoinPool的新方法">java.util.concurrent.ForkJoinPool的新方法</h3>
<p>静态的<code>commonPool()</code>新加入，可以为ForkJoinTask提供通用池。</p>
<p>两个方法 <code>getCommonPoolParallelism()</code> 和 <code>commonPool()</code>提供不同的配置。 </p>
<h3 id="新类_java-util-concurrent-locks-StampedLock">新类 java.util.concurrent.locks.StampedLock</h3>
<p>新类<a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/util/concurrent/package-summary.html" target="_blank" rel="external">StampedLock</a>提供三种模式(写，读，乐观读)，用来提高性能。</p>
<h2 id="Java_9_中_Concurrent_package的改变">Java 9 中 Concurrent package的改变</h2>
<p>主要是<a href="http://openjdk.java.net/jeps/266" target="_blank" rel="external"> JEP 266: More Concurrency Updates</a>, 包括publish-subscribe, <code>CompletableFuture</code>接口的加强等。</p>
<ul>
<li>支持Reactive Streams publish-subscribe框架，四个接口<code>Processor</code>、<code>Publisher</code>、<code>Subscriber</code>、<code>Subscription</code>，容器类<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html" target="_blank" rel="external">java.util.concurrent.Flow</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/SubmissionPublisher.html" target="_blank" rel="external">java.util.concurrent.SubmissionPublisher</a></li>
<li>CompletableFuture类加强，支持delays, timeout, subclassing 以及其它方法</li>
<li>调优以及修改javadoc</li>
</ul>
<h2 id="参考文档">参考文档</h2>
<ol>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/changes8.html" target="_blank" rel="external">Concurrency Utilities Enhancements in Java SE 8</a></li>
<li><a href="https://www.javaworld.com/article/3198904/learn-java/java-9s-other-new-enhancements-part-6-concurrency.html" target="_blank" rel="external">Java 9&#39;s other new enhancements, Part 6: Concurrency</a></li>
<li><a href="https://blog.takipi.com/the-essential-java-9-feature-you-probably-never-heard-of/" target="_blank" rel="external">The Essential Java 9 Feature You Probably Never Heard Of</a></li>
<li><a href="https://www.infoworld.com/article/3169289/java/java-9s-other-new-enhancements-part-2.html" target="_blank" rel="external">Java 9&#39;s other new enhancements</a></li>
<li><a href="http://openjdk.java.net/jeps/266" target="_blank" rel="external">JEP 266: More Concurrency Updates</a></li>
<li><a href="https://www.voxxed.com/2016/10/java-9-series-concurrency-updates/" target="_blank" rel="external">Java 9 series: Concurrency Updates</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java 8 和 Java 9中 <code>concurrent</code>包有了一些改变， 本文对这些改变做了汇总。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]20个使用 Java CompletableFuture的例子]]></title>
    <link href="http://colobu.com/2018/03/12/20-Examples-of-Using-Java%E2%80%99s-CompletableFuture/"/>
    <id>http://colobu.com/2018/03/12/20-Examples-of-Using-Java’s-CompletableFuture/</id>
    <published>2018-03-12T06:52:48.000Z</published>
    <updated>2018-03-26T13:58:03.824Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在Java中异步编程，不一定非要使用rxJava, Java本身的库中的CompletableFuture可以很好的应对大部分的场景。</p>
</blockquote>
<p>原文: <a href="https://mahmoudanouti.wordpress.com/2018/01/26/20-examples-of-using-javas-completablefuture/" target="_blank" rel="external">20 Examples of Using Java’s CompletableFuture</a>, 作者 Mahmoud Anouti。</p>
<p>这篇文章介绍 Java 8 的 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletionStage.html" target="_blank" rel="external">CompletionStage API</a>和它的标准库的实现 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">CompletableFuture</a>。API通过例子的方式演示了它的行为，每个例子演示一到两个行为。</p>
<p>既然<code>CompletableFuture</code>类实现了<code>CompletionStage</code>接口，首先我们需要理解这个接口的契约。它代表了一个特定的计算的阶段，可以同步或者异步的被完成。你可以把它看成一个计算流水线上的一个单元，最终会产生一个最终结果，这意味着几个<code>CompletionStage</code>可以串联起来，一个完成的阶段可以触发下一阶段的执行，接着触发下一次，接着……</p>
<p>除了实现<code>CompletionStage</code>接口， <code>CompletableFuture</code>也实现了<code>future</code>接口, 代表一个未完成的异步事件。<code>CompletableFuture</code>提供了方法，能够显式地完成这个future,所以它叫<code>CompletableFuture</code>。</p>
<a id="more"></a>
<p>1、 创建一个完成的CompletableFuture</p>
<p>最简单的例子就是使用一个预定义的结果创建一个完成的CompletableFuture,通常我们会在计算的开始阶段使用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> completedFutureExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>);</div><div class="line">    assertTrue(cf.isDone());</div><div class="line">    assertEquals(<span class="string">"message"</span>, cf.getNow(<span class="keyword">null</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>getNow(null)</code>方法在future完成的情况下会返回结果，就比如上面这个例子，否则返回null (传入的参数)。</p>
<p>2、运行一个简单的异步阶段</p>
<p>这个例子创建一个一个异步执行的阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> runAsyncExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.runAsync(() -&gt; {</div><div class="line">        assertTrue(Thread.currentThread().isDaemon());</div><div class="line">        randomSleep();</div><div class="line">    });</div><div class="line">    assertFalse(cf.isDone());</div><div class="line">    sleepEnough();</div><div class="line">    assertTrue(cf.isDone());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过这个例子可以学到两件事情：</p>
<p>CompletableFuture的方法如果以<code>Async</code>结尾，它会异步的执行(没有指定executor的情况下)， 异步执行通过<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html" target="_blank" rel="external">ForkJoinPool</a>实现， 它使用守护线程去执行任务。注意这是CompletableFuture的特性， 其它CompletionStage可以override这个默认的行为。</p>
<p>3、在前一个阶段上应用函数</p>
<p>下面这个例子使用前面 <strong>#1</strong> 的完成的CompletableFuture， #1返回结果为字符串<code>message</code>,然后应用一个函数把它变成大写字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenApplyExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApply(s -&gt; {</div><div class="line">        assertFalse(Thread.currentThread().isDaemon());</div><div class="line">        <span class="keyword">return</span> s.toUpperCase();</div><div class="line">    });</div><div class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.getNow(<span class="keyword">null</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意<code>thenApply</code>方法名称代表的行为。</p>
<p><code>then</code>意味着这个阶段的动作发生当前的阶段正常完成之后。本例中，当前节点完成，返回字符串<code>message</code>。</p>
<p><code>Apply</code>意味着返回的阶段将会对结果前一阶段的结果应用一个函数。</p>
<p>函数的执行会被<strong>阻塞</strong>，这意味着<code>getNow()</code>只有打斜操作被完成后才返回。</p>
<p>4、在前一个阶段上异步应用函数</p>
<p>通过调用异步方法(方法后边加Async后缀)，串联起来的CompletableFuture可以异步地执行（使用ForkJoinPool.commonPool()）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenApplyAsyncExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; {</div><div class="line">        assertTrue(Thread.currentThread().isDaemon());</div><div class="line">        randomSleep();</div><div class="line">        <span class="keyword">return</span> s.toUpperCase();</div><div class="line">    });</div><div class="line">    assertNull(cf.getNow(<span class="keyword">null</span>));</div><div class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>5、使用定制的Executor在前一个阶段上异步应用函数</p>
<p>异步方法一个非常有用的特性就是能够提供一个<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Executor.html" target="_blank" rel="external">Executor</a>来异步地执行CompletableFuture。这个例子演示了如何使用一个固定大小的线程池来应用大写函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>, <span class="keyword">new</span> ThreadFactory() {</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> Thread <span class="title">newThread</span>(Runnable runnable) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(runnable, <span class="string">"custom-executor-"</span> + count++);</div><div class="line">    }</div><div class="line">});</div><div class="line"> </div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenApplyAsyncWithExecutorExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; {</div><div class="line">        assertTrue(Thread.currentThread().getName().startsWith(<span class="string">"custom-executor-"</span>));</div><div class="line">        assertFalse(Thread.currentThread().isDaemon());</div><div class="line">        randomSleep();</div><div class="line">        <span class="keyword">return</span> s.toUpperCase();</div><div class="line">    }, executor);</div><div class="line"> </div><div class="line">    assertNull(cf.getNow(<span class="keyword">null</span>));</div><div class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>6、消费前一阶段的结果</p>
<p>如果下一阶段接收了当前阶段的结果，但是在计算的时候不需要返回值(它的返回类型是void)， 那么它可以不应用一个函数，而是一个消费者， 调用方法也变成了<code>thenAccept</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenAcceptExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture.completedFuture(<span class="string">"thenAccept message"</span>)</div><div class="line">            .thenAccept(s -&gt; result.append(s));</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>本例中消费者同步地执行，所以我们不需要在CompletableFuture调用<code>join</code>方法。</p>
<p>7、异步地消费迁移阶段的结果</p>
<p>同样，可以使用<code>thenAcceptAsync</code>方法， 串联的CompletableFuture可以异步地执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenAcceptAsyncExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"thenAcceptAsync message"</span>)</div><div class="line">            .thenAcceptAsync(s -&gt; result.append(s));</div><div class="line">    cf.join();</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>8、完成计算异常</p>
<p>现在我们来看一下异步操作如何显式地返回异常，用来指示计算失败。我们简化这个例子，操作处理一个字符串，把它转换成答谢，我们模拟延迟一秒。</p>
<p>我们使用<code>thenApplyAsync(Function, Executor)</code>方法，第一个参数传入大写函数， executor是一个delayed executor,在执行前会延迟一秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> completeExceptionallyExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(String::toUpperCase,</div><div class="line">            CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</div><div class="line">    CompletableFuture exceptionHandler = cf.handle((s, th) -&gt; { <span class="keyword">return</span> (th != <span class="keyword">null</span>) ? <span class="string">"message upon cancel"</span> : <span class="string">""</span>; });</div><div class="line">    cf.completeExceptionally(<span class="keyword">new</span> RuntimeException(<span class="string">"completed exceptionally"</span>));</div><div class="line">assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        cf.join();</div><div class="line">        fail(<span class="string">"Should have thrown an exception"</span>);</div><div class="line">    } <span class="keyword">catch</span>(CompletionException ex) { <span class="comment">// just for testing</span></div><div class="line">        assertEquals(<span class="string">"completed exceptionally"</span>, ex.getCause().getMessage());</div><div class="line">    }</div><div class="line"> </div><div class="line">    assertEquals(<span class="string">"message upon cancel"</span>, exceptionHandler.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>让我们看一下细节。</p>
<p>首先我们创建了一个CompletableFuture, 完成后返回一个字符串<code>message</code>,接着我们调用<code>thenApplyAsync</code>方法，它返回一个CompletableFuture。这个方法在第一个函数完成后，异步地应用转大写字母函数。</p>
<p>这个例子还演示了如何通过<code>delayedExecutor(timeout, timeUnit)</code>延迟执行一个异步任务。</p>
<p>我们创建了一个分离的<code>handler</code>阶段： exceptionHandler， 它处理异常异常，在异常情况下返回<code>message upon cancel</code>。</p>
<p>下一步我们显式地用异常完成第二个阶段。 在阶段上调用<code>join</code>方法，它会执行大写转换，然后抛出CompletionException（正常的join会等待1秒，然后得到大写的字符串。不过我们的例子还没等它执行就完成了异常）， 然后它触发了handler阶段。</p>
<p>9、取消计算</p>
<p>和完成异常类似，我们可以调用<code>cancel(boolean mayInterruptIfRunning)</code>取消计算。对于CompletableFuture类，布尔参数并没有被使用，这是因为它并没有使用中断去取消操作，相反，<code>cancel</code>等价于<code>completeExceptionally(new CancellationException())</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> cancelExample() {</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(String::toUpperCase,</div><div class="line">            CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</div><div class="line">    CompletableFuture cf2 = cf.exceptionally(throwable -&gt; <span class="string">"canceled message"</span>);</div><div class="line">    assertTrue(<span class="string">"Was not canceled"</span>, cf.cancel(<span class="keyword">true</span>));</div><div class="line">    assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</div><div class="line">    assertEquals(<span class="string">"canceled message"</span>, cf2.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>10、在两个完成的阶段其中之一上应用函数</p>
<p>下面的例子创建了<code>CompletableFuture</code>, <code>applyToEither</code>处理两个阶段， 在其中之一上应用函数(包保证哪一个被执行)。 本例中的两个阶段一个是应用大写转换在原始的字符串上， 另一个阶段是应用小些转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> applyToEitherExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf1 = CompletableFuture.completedFuture(original)</div><div class="line">            .thenApplyAsync(s -&gt; delayedUpperCase(s));</div><div class="line">    CompletableFuture cf2 = cf1.applyToEither(</div><div class="line">            CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</div><div class="line">            s -&gt; s + <span class="string">" from applyToEither"</span>);</div><div class="line">    assertTrue(cf2.join().endsWith(<span class="string">" from applyToEither"</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>11、在两个完成的阶段其中之一上调用消费函数</p>
<p>和前一个例子很类似了，只不过我们调用的是消费者函数 (Function变成Consumer):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> acceptEitherExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original)</div><div class="line">            .thenApplyAsync(s -&gt; delayedUpperCase(s))</div><div class="line">            .acceptEither(CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</div><div class="line">                    s -&gt; result.append(s).append(<span class="string">"acceptEither"</span>));</div><div class="line">    cf.join();</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.toString().endsWith(<span class="string">"acceptEither"</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>12、在两个阶段都执行完后运行一个 <code>Runnable</code></p>
<p>这个例子演示了依赖的CompletableFuture如果等待两个阶段完成后执行了一个Runnable。 注意下面所有的阶段都是同步执行的，第一个阶段执行大写转换，第二个阶段执行小写转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> runAfterBothExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture.completedFuture(original).thenApply(String::toUpperCase).runAfterBoth(</div><div class="line">            CompletableFuture.completedFuture(original).thenApply(String::toLowerCase),</div><div class="line">            () -&gt; result.append(<span class="string">"done"</span>));</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>13、 使用BiConsumer处理两个阶段的结果</p>
<p>上面的例子还可以通过BiConsumer来实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenAcceptBothExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    CompletableFuture.completedFuture(original).thenApply(String::toUpperCase).thenAcceptBoth(</div><div class="line">            CompletableFuture.completedFuture(original).thenApply(String::toLowerCase),</div><div class="line">            (s1, s2) -&gt; result.append(s1 + s2));</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, result.toString());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>14、使用BiFunction处理两个阶段的结果</p>
<p>如果CompletableFuture依赖两个前面阶段的结果， 它复合两个阶段的结果再返回一个结果，我们就可以使用<code>thenCombine()</code>函数。整个流水线是同步的，所以<code>getNow()</code>会得到最终的结果，它把大写和小写字符串连接起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenCombineExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedUpperCase(s))</div><div class="line">            .thenCombine(CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedLowerCase(s)),</div><div class="line">                    (s1, s2) -&gt; s1 + s2);</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.getNow(<span class="keyword">null</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p>15、异步使用BiFunction处理两个阶段的结果</p>
<p>类似上面的例子，但是有一点不同： 依赖的前两个阶段异步地执行，所以<code>thenCombine()</code>也异步地执行，即时它没有<code>Async</code>后缀。</p>
<p>Javadoc中有注释：</p>
<blockquote>
<p>Actions supplied for dependent completions of non-async methods may be performed by the thread that completes the current CompletableFuture, or by any other caller of a completion method</p>
</blockquote>
<p>所以我们需要<code>join</code>方法等待结果的完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenCombineAsyncExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original)</div><div class="line">            .thenApplyAsync(s -&gt; delayedUpperCase(s))</div><div class="line">            .thenCombine(CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</div><div class="line">                    (s1, s2) -&gt; s1 + s2);</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>16、组合 CompletableFuture</p>
<p>我们可以使用<code>thenCompose()</code>完成上面两个例子。这个方法等待第一个阶段的完成(大写转换)， 它的结果传给一个指定的返回CompletableFuture函数，它的结果就是返回的CompletableFuture的结果。</p>
<p>有点拗口，但是我们看例子来理解。函数需要一个大写字符串做参数，然后返回一个CompletableFuture, 这个CompletableFuture会转换字符串变成小写然后连接在大写字符串的后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenComposeExample() {</div><div class="line">    String original = <span class="string">"Message"</span>;</div><div class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedUpperCase(s))</div><div class="line">            .thenCompose(upper -&gt; CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedLowerCase(s))</div><div class="line">                    .thenApply(s -&gt; upper + s));</div><div class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.join());</div><div class="line">}</div></pre></td></tr></table></figure>

<p>17、当几个阶段中的一个完成，创建一个完成的阶段</p>
<p>下面的例子演示了当任意一个CompletableFuture完成后， 创建一个完成的CompletableFuture.</p>
<p>待处理的阶段首先创建， 每个阶段都是转换一个字符串为大写。因为本例中这些阶段都是同步地执行(thenApply), 从<code>anyOf</code>中创建的CompletableFuture会立即完成，这样所有的阶段都已完成，我们使用<code>whenComplete(BiConsumer&lt;? super Object, ? super Throwable&gt; action)</code>处理完成的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> anyOfExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</div><div class="line">            .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApply(s -&gt; delayedUpperCase(s)))</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    CompletableFuture.anyOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()])).whenComplete((res, th) -&gt; {</div><div class="line">        <span class="keyword">if</span>(th == <span class="keyword">null</span>) {</div><div class="line">            assertTrue(isUpperCase((String) res));</div><div class="line">            result.append(res);</div><div class="line">        }</div><div class="line">    });</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>18、当所有的阶段都完成后创建一个阶段</p>
<p>上一个例子是当任意一个阶段完成后接着处理，接下来的两个例子演示当所有的阶段完成后才继续处理, 同步地方式和异步地方式两种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> allOfExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</div><div class="line">            .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApply(s -&gt; delayedUpperCase(s)))</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()])).whenComplete((v, th) -&gt; {</div><div class="line">        futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="keyword">null</span>))));</div><div class="line">        result.append(<span class="string">"done"</span>);</div><div class="line">    });</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>19、当所有的阶段都完成后异步地创建一个阶段<br>使用<code>thenApplyAsync()</code>替换那些单个的CompletableFutures的方法，<code>allOf()</code>会在通用池中的线程中异步地执行。所以我们需要调用<code>join</code>方法等待它完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> allOfAsyncExample() {</div><div class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</div><div class="line">            .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApplyAsync(s -&gt; delayedUpperCase(s)))</div><div class="line">            .collect(Collectors.toList());</div><div class="line">    CompletableFuture allOf = CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()]))</div><div class="line">            .whenComplete((v, th) -&gt; {</div><div class="line">                futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="keyword">null</span>))));</div><div class="line">                result.append(<span class="string">"done"</span>);</div><div class="line">            });</div><div class="line">    allOf.join();</div><div class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>20、真实的例子</p>
<p>Now that the functionality of CompletionStage and specifically CompletableFuture is explored, the below example applies them in a practical scenario:</p>
<p>现在你已经了解了CompletionStage 和 CompletableFuture 的一些函数的功能，下面的例子是一个实践场景：</p>
<ol>
<li>首先异步调用<code>cars</code>方法获得Car的列表，它返回CompletionStage场景。<code>cars</code>消费一个远程的REST API。</li>
<li>然后我们复合一个CompletionStage填写每个汽车的评分，通过<code>rating(manufacturerId)</code>返回一个CompletionStage, 它会异步地获取汽车的评分(可能又是一个REST API调用)</li>
<li>当所有的汽车填好评分后，我们结束这个列表，所以我们调用<code>allOf</code>得到最终的阶段， 它在前面阶段所有阶段完成后才完成。</li>
<li>在最终的阶段调用<code>whenComplete()</code>,我们打印出每个汽车和它的评分。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cars().thenCompose(cars -&gt; {</div><div class="line">    List&lt;CompletionStage&gt; updatedCars = cars.stream()</div><div class="line">            .map(car -&gt; rating(car.manufacturerId).thenApply(r -&gt; {</div><div class="line">                car.setRating(r);</div><div class="line">                <span class="keyword">return</span> car;</div><div class="line">            })).collect(Collectors.toList());</div><div class="line"> </div><div class="line">    CompletableFuture done = CompletableFuture</div><div class="line">            .allOf(updatedCars.toArray(<span class="keyword">new</span> CompletableFuture[updatedCars.size()]));</div><div class="line">    <span class="keyword">return</span> done.thenApply(v -&gt; updatedCars.stream().map(CompletionStage::toCompletableFuture)</div><div class="line">            .map(CompletableFuture::join).collect(Collectors.toList()));</div><div class="line">}).whenComplete((cars, th) -&gt; {</div><div class="line">    <span class="keyword">if</span> (th == <span class="keyword">null</span>) {</div><div class="line">        cars.forEach(System.out::println);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(th);</div><div class="line">    }</div><div class="line">}).toCompletableFuture().join();</div></pre></td></tr></table></figure>

<p>因为每个汽车的实例都是独立的，得到每个汽车的评分都可以异步地执行，这会提高系统的性能(延迟)，而且，等待所有的汽车评分被处理使用的是<code>allOf</code>方法，而不是手工的线程等待(Thread#join() 或 a CountDownLatch)。</p>
<p>这些例子可以帮助你更好的理解相关的API,你可以在<a href="https://github.com/manouti/completablefuture-examples" target="_blank" rel="external">github</a>上得到所有的例子的代码。</p>
<p><strong>其它参考文档</strong></p>
<ol>
<li><a href="https://medium.com/@johnmcclean/reactive-programming-with-java-8-and-simple-react-the-tutorial-3634f512eeb1" target="_blank" rel="external">Reactive programming with Java 8 and simple-react : The Tutorial</a></li>
<li><a href="http://javaday.org.ua/completablefuture-overview/" target="_blank" rel="external">CompletableFuture Overview</a></li>
<li><a href="https://blog.takipi.com/back-to-the-completablefuture-java-8-feature-highlight/" target="_blank" rel="external">CompletableFuture vs Future: going async with Java 8 new features</a></li>
<li><a href="https://github.com/spotify/completable-futures" target="_blank" rel="external">spotify/completable-futures</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在Java中异步编程，不一定非要使用rxJava, Java本身的库中的CompletableFuture可以很好的应对大部分的场景。</p>
</blockquote>
<p>原文: <a href="https://mahmoudanouti.wordpress.com/2018/01/26/20-examples-of-using-javas-completablefuture/" target="_blank" rel="external">20 Examples of Using Java’s CompletableFuture</a>, 作者 Mahmoud Anouti。</p>
<p>这篇文章介绍 Java 8 的 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletionStage.html" target="_blank" rel="external">CompletionStage API</a>和它的标准库的实现 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">CompletableFuture</a>。API通过例子的方式演示了它的行为，每个例子演示一到两个行为。</p>
<p>既然<code>CompletableFuture</code>类实现了<code>CompletionStage</code>接口，首先我们需要理解这个接口的契约。它代表了一个特定的计算的阶段，可以同步或者异步的被完成。你可以把它看成一个计算流水线上的一个单元，最终会产生一个最终结果，这意味着几个<code>CompletionStage</code>可以串联起来，一个完成的阶段可以触发下一阶段的执行，接着触发下一次，接着……</p>
<p>除了实现<code>CompletionStage</code>接口， <code>CompletableFuture</code>也实现了<code>future</code>接口, 代表一个未完成的异步事件。<code>CompletableFuture</code>提供了方法，能够显式地完成这个future,所以它叫<code>CompletableFuture</code>。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]使用 LLDB 调试 Go 程序]]></title>
    <link href="http://colobu.com/2018/03/12/Debugging-Go-Code-with-LLDB/"/>
    <id>http://colobu.com/2018/03/12/Debugging-Go-Code-with-LLDB/</id>
    <published>2018-03-12T04:09:38.000Z</published>
    <updated>2018-03-26T13:58:03.833Z</updated>
    <content type="html"><![CDATA[<p>我一般调试Go程序都是通过log日志，性能调试的话通过 pprof 、trace、flamegraph等，主要是Go没有一个很好的集成的debugger,前两年虽然关注了delve，但是在IDE中集成比较粗糙，调试也很慢，所以基本不使用debugger进行调试， 最近看到滴滴的工程师分享的使用debugger在调试Go程序，我觉得有必要在尝试一下这方面的技术了。</p>
<p>本文翻译自 <a href="http://ribrdb.github.io/lldb/" target="_blank" rel="external">Debugging Go Code with LLDB</a>, 更好的调试Go程序的工具是<a href="https://github.com/derekparker/delve" target="_blank" rel="external">delve</a>, 因为它是专门为Go开发， 使用起来也很简单，并且还可以远程调试。delve的命令还可参考： <a href="https://github.com/derekparker/delve/tree/master/Documentation/cli" target="_blank" rel="external">dlv cli</a>，但是流行的通用的基础的debugger也是常用的手段之一。我在译文后面也列出了几篇其它关于go debug的相关文章，有兴趣的话也可以扩展阅读一下。</p>
<a id="more"></a>
<blockquote>
<p>本文主要介绍应用于glang compiler 工具链的技术， 除了本文的介绍外，你还可以参考 <a href="http://lldb.llvm.org/tutorial.html" target="_blank" rel="external">LLDB 手册</a></p>
</blockquote>
<h2 id="介绍">介绍</h2>
<p>在 Linux、Mac OS X, FreeBSD 或者 NetBSD环境中，当你使用 gc工具链编译和链接Go程序的时候， 编译出的二进制文件会携带<a href="http://dwarfstd.org/Dwarf3Std.php" target="_blank" rel="external">DWARFv3</a>调试信息。 LLDB调试器( &gt; 3.7)可以使用这个信息调试进程或者core dump文件。</p>
<blockquote>
<p>使用<code>-w</code>可以告诉链接器忽略这个调试信息， 比如<code>go build -ldflags &quot;-w&quot; prog.go</code>。</p>
</blockquote>
<p>gc编译器产生的代码可能会包含内联的优化，这不方便调试器调试，为了禁止内联， 你可以使用<code>-gcflags &quot;-N -l&quot;</code>参数。</p>
<h3 id="安装lldb">安装lldb</h3>
<p>MacOS下如果你安装了XCode,应该已经安装了LLDB， LLDB是XCode默认的调试器。</p>
<p>Linux/MacOS/Windows下的安装方法可以参考： <a href="https://github.com/vadimcn/vscode-lldb/wiki/Installing-LLDB" target="_blank" rel="external">Installing-LLDB</a>。</p>
<h3 id="通用操作">通用操作</h3>
<ul>
<li>显示文件和行号，设置断点以及反编译:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) l</div><div class="line">(lldb) l <span class="built_in">line</span></div><div class="line">(lldb) l <span class="built_in">file</span>.go:<span class="built_in">line</span></div><div class="line">(lldb) b <span class="built_in">line</span></div><div class="line">(lldb) b <span class="built_in">file</span>.go:<span class="built_in">line</span></div><div class="line">(lldb) disas</div></pre></td></tr></table></figure>

<ul>
<li>显示 backtrace 和 unwind stack frame:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">bt</span></div><div class="line">(lldb) frame n</div></pre></td></tr></table></figure>

<ul>
<li>Show the name, type and location on the stack frame of local variables, arguments and return values:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) frame <span class="built_in">variable</span></div><div class="line">(lldb) p varname</div><div class="line">(lldb) expr -T <span class="comment">-- varname</span></div></pre></td></tr></table></figure>

<h2 id="Go扩展">Go扩展</h2>
<h3 id="表达式解析">表达式解析</h3>
<p>LLDB支持Go表达式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) p x</div><div class="line">(lldb) <span class="type">expr</span> *(*<span class="type">int32</span>)(t)</div><div class="line">(lldb) help <span class="type">expr</span></div></pre></td></tr></table></figure>

<h3 id="Interface">Interface</h3>
<p>默认LLDB显示接口的动态类型。通常它是一个指针， 比如<code>func foo(a interface{}) { ... }</code>, 如果你调用<code>callfoo(1.0)</code>, lldb会把<code>a</code>看作<code>*float64inside</code>，你也可以禁止为一个表达式禁止这种处理，或者在全局禁用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) expr -<span class="keyword">d</span> <span class="keyword">no</span>-dynamic-<span class="built_in">values</span> -- <span class="keyword">a</span></div><div class="line">(lldb) settings <span class="keyword">set</span> target.prefer-dynamic-<span class="built_in">values</span> <span class="keyword">no</span>-dynamic-<span class="built_in">values</span></div></pre></td></tr></table></figure>

<h3 id="Data_Formatter">Data Formatter</h3>
<p>LLDB包含 go string 和 slice的格式化输出器，查看<a href="http://lldb.llvm.org/varformats.html" target="_blank" rel="external">LLDB docs</a>文档学习定制格式化输出。如果你想扩展内建的格式化方式，可以参考<a href="https://github.com/ribrdb/lldb/blob/gogogo/source/Plugins/LanguageRuntime/Go/GoLanguageRuntime.cpp" target="_blank" rel="external">GoLanguageRuntime.cpp</a>。</p>
<p>Channel和map被看作引用类型，lldb把它们作为指针类型， 就像C++的类型<code>hash&lt;int,string&gt;*</code>。Dereferencing会显示类型内部的表示。</p>
<h3 id="Goroutine">Goroutine</h3>
<p>LLDB 把 Goroutine 看作 thread。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">thread</span> <span class="built_in">list</span></div><div class="line">(lldb) bt <span class="literal">all</span></div><div class="line">(lldb) <span class="keyword">thread</span> <span class="keyword">select</span> <span class="number">2</span></div></pre></td></tr></table></figure>

<h3 id="已知问题">已知问题</h3>
<ul>
<li>如果编译时开启优化，调试信息可能是错误的。请确保开启参数 <code>-gcflags &quot;-N -l&quot;</code></li>
<li>不能改变变量的值，或者调用goh函数</li>
<li>需要更好的支持 chan 和 map 类型</li>
<li>调试信息不包含输入的package, 所以你在表达式中需要package的全路径。当package中包含 non-identifier 字符的时候你需要用引号包含它: <code>x.(*foo/bar.BarType)</code> 或者 <code>(*“v.io/x/foo”.FooType)(x)</code></li>
<li>调试信息不包含作用域，所以变量在它们初始化之前是可见的。 如果有同名的本地变量，比如shadowed 变量， 你不知道哪个是哪个</li>
<li>调试信息仅仅描述了变量在内存中的位置,所以你可能看到寄存器中的变量的stale数据</li>
<li>不能打印函数类型</li>
</ul>
<h2 id="教程">教程</h2>
<p>在这个例子中我们可以检查标准库正则表达式。为了构建二进制文件， 进入<code>$GOROOT/src/regexp</code>然后运行<code>run go test -gcflags &quot;-N -l&quot; -c</code>,这会产生可执行文件 <code>regexp.test</code>。</p>
<h3 id="启动">启动</h3>
<p>启动 lldb, 调试 regexp.test:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ lldb regexp.test</div><div class="line">(lldb) target <span class="operator"><span class="keyword">create</span> <span class="string">"regexp.test"</span></span></div><div class="line"><span class="keyword">Current</span> executable <span class="keyword">set</span> <span class="keyword">to</span> <span class="string">'regexp.test'</span> (x86_64).</div><div class="line">(lldb)</div></pre></td></tr></table></figure>

<h3 id="设置断点">设置断点</h3>
<p>在TestFind 函数上设置断点:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(lldb) b <span class="built_in">regexp</span>.TestFind</div></pre></td></tr></table></figure>

<p>有时候 go编译器会使用全路径为函数名添加前缀，如果你不能使用上面简单的名称，你可以使用正则表达式设置断点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) break <span class="operator"><span class="keyword">set</span> -r <span class="keyword">regexp</span>.TestFind$</span></div><div class="line">Breakpoint <span class="number">5</span>: <span class="keyword">where</span> = <span class="keyword">regexp</span>.test<span class="string">`_/code/go/src/regexp.TestFind + 37 at find_test.go:149, address = 0x00000000000863a5</span></div></pre></td></tr></table></figure>

<p>运行程序:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(lldb) run <span class="subst">--</span>test<span class="built_in">.</span>run<span class="subst">=</span>TestFind</div><div class="line">Process <span class="number">8496</span> launched: <span class="string">'/code/go/src/regexp/regexp.test'</span> (x86_64)</div><div class="line">Process <span class="number">8496</span> stopped</div><div class="line"><span class="subst">*</span> <span class="keyword">thread</span> <span class="variable">#9</span>: tid <span class="subst">=</span> <span class="number">0x0017</span>, <span class="number">0x00000000000863a5</span> regexp<span class="built_in">.</span>test<span class="string">`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, stop reason = breakpoint 2.1 3.1 5.1</span></div><div class="line">    frame #0: 0x00000000000863a5 regexp.test`_/code/go/src/regexp<span class="built_in">.</span>TestFind(t<span class="subst">=</span><span class="number">0x000000020834a000</span>) <span class="subst">+</span> <span class="number">37</span> at find_test<span class="built_in">.</span>go:<span class="number">149</span></div><div class="line">   <span class="number">146</span>         <span class="comment">// First the simple cases.</span></div><div class="line">   <span class="number">147</span></div><div class="line">   <span class="number">148</span>         func TestFind(t <span class="subst">*</span>testing<span class="built_in">.</span>T) {</div><div class="line"><span class="subst">-&gt; </span><span class="number">149</span>                 for _, test <span class="subst">:=</span> range findTests {</div><div class="line">   <span class="number">150</span>                         re <span class="subst">:=</span> MustCompile(test<span class="built_in">.</span>pat)</div><div class="line">   <span class="number">151</span>                         <span class="keyword">if</span> re<span class="built_in">.</span><span class="built_in">String</span>() <span class="subst">!=</span> test<span class="built_in">.</span>pat {</div><div class="line">   <span class="number">152</span>                                 t<span class="built_in">.</span>Errorf(<span class="string">"String() = `%s`; should be `%s`"</span>, re<span class="built_in">.</span><span class="built_in">String</span>(), test<span class="built_in">.</span>pat)</div></pre></td></tr></table></figure>

<p>程序会运行到设置的断点上，查看运行的goroutine以及它们在做什么：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(lldb) thread list</div><div class="line">Process 8496 stopped</div><div class="line">  thread #1: tid = 0x12201, 0x000000000003c0ab regexp.test`runtime.mach_semaphore_wait + 11 at sys_darwin_amd64.s:412</div><div class="line">  thread #2: tid = 0x122fa, 0x000000000003bf7c regexp.test`runtime.usleep + 44 at sys_darwin_amd64.s:290</div><div class="line">  thread #4: tid = 0x0001, 0x0000000000015865 regexp.test`runtime.gopark(unlockf=0x00000000000315a0, <span class="operator"><span class="keyword">lock</span>=<span class="number">0x00000002083220b8</span>, reason=<span class="string">"chan receive"</span>) + <span class="number">261</span> <span class="keyword">at</span> proc.<span class="keyword">go</span>:<span class="number">131</span></span></div><div class="line">  thread #<span class="number">5</span>: tid = <span class="number">0x0002</span>, <span class="number">0x0000000000015865</span> <span class="keyword">regexp</span>.test<span class="string">`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002990d0, reason="force gc (idle)") + 261 at proc.go:131</span></div><div class="line">  thread #6: tid = 0x0003, 0x0000000000015754 regexp.test`runtime.Gosched + <span class="number">20</span> <span class="keyword">at</span> proc.<span class="keyword">go</span>:<span class="number">114</span></div><div class="line">  thread #<span class="number">7</span>: tid = <span class="number">0x0004</span>, <span class="number">0x0000000000015865</span> <span class="keyword">regexp</span>.test<span class="string">`runtime.gopark(unlockf=0x00000000000315a0, lock=0x00000000002a07d8, reason="finalizer wait") + 261 at proc.go:131</span></div><div class="line">* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/<span class="keyword">go</span>/src/<span class="keyword">regexp</span>.TestFind(t=<span class="number">0x000000020834a000</span>) + <span class="number">37</span> <span class="keyword">at</span> find_test.<span class="keyword">go</span>:<span class="number">149</span>, <span class="keyword">stop</span> reason = breakpoint <span class="number">2.1</span> <span class="number">3.1</span> <span class="number">5.1</span></div></pre></td></tr></table></figure>

<p>用<code>*</code>标出的那个goroutine是当前的goroutine。</p>
<h3 id="查看代码">查看代码</h3>
<p>使用<code>l</code>或者<code>list</code>查看代码， <code>#</code>重复最后的命令：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) <span class="keyword">l</span></div><div class="line">(lldb) # Hit enter <span class="keyword">to</span> <span class="built_in">repeat</span> <span class="keyword">last</span> <span class="keyword">command</span>. Here, <span class="keyword">list</span> the <span class="keyword">next</span> few lines</div></pre></td></tr></table></figure>

<h3 id="命名">命名</h3>
<p>变量和函数名必须使用它们所隶属的package的全名， 比如<code>Compile</code>函数的名称是<code>regexp.Compile</code>。</p>
<p>方法必须使用receiver类型的全程， 比如<code>*Regexp</code>类型的<code>String</code>方法是<code>regexp.(*Regexp).String</code>。</p>
<p>被closure引用的变量会有<code>&amp;</code>前缀。</p>
<h3 id="查看堆栈">查看堆栈</h3>
<p>查看程序暂停的位置处的堆栈：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #9: tid = 0x0017, 0x00000000000863a5 regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149, <span class="operator"><span class="keyword">stop</span> reason = breakpoint <span class="number">2.1</span> <span class="number">3.1</span> <span class="number">5.1</span></span></div><div class="line">  * frame #<span class="number">0</span>: <span class="number">0x00000000000863a5</span> <span class="keyword">regexp</span>.test<span class="string">`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 37 at find_test.go:149</span></div><div class="line">    frame #1: 0x0000000000056e3f regexp.test`testing.tRunner(t=<span class="number">0x000000000003b671</span>, test=<span class="number">0x000000020834a000</span>) + <span class="number">191</span> <span class="keyword">at</span> testing.<span class="keyword">go</span>:<span class="number">447</span></div><div class="line">    frame #<span class="number">2</span>: <span class="number">0x00000000002995a0</span> <span class="keyword">regexp</span>.test<span class="string">`/code/go/src/regexp.statictmp_3759 + 96</span></div><div class="line">    frame #3: 0x000000000003b671 regexp.test`runtime.goexit + <span class="number">1</span> <span class="keyword">at</span> asm_amd64.s:<span class="number">2232</span></div><div class="line">The stack frame shows we’re currently executing the <span class="keyword">regexp</span>.TestFind <span class="keyword">function</span>, <span class="keyword">as</span> expected.</div></pre></td></tr></table></figure>

<p>命令<code>frame variable</code>会列出这个函数所有的本地变量以及它们的值。但是使用它有点危险，因为它会尝试打印出未初始化的变量。未初始化的slice可能会导致lldb打印出巨大的数组。</p>
<p>函数参数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag"><span class="php"><span class="function"><span class="params">(lldb)</span> <span class="title">frame</span> <span class="title">var</span> -<span class="title">l</span></span></span></span></span></div><div class="line"><span class="params">(*testing.T)</span> <span class="title">t</span> = 0<span class="title">x000000020834a000</span></div></pre></td></tr></table></figure>

<p>打印这个参数的时候，你会注意到它是一个指向<code>Regexp</code>的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">(lldb) p re</div><div class="line">(*_/code/<span class="keyword">go</span>/src/regexp.Regexp) <span class="number">$3</span> =<span class="number"> 0</span>x000000020834a090</div><div class="line">(lldb) p t</div><div class="line">(*testing.T) <span class="number">$4</span> =<span class="number"> 0</span>x000000020834a000</div><div class="line">(lldb) p *t</div><div class="line">(testing.T) <span class="number">$5</span> = {</div><div class="line">  testing.common = {</div><div class="line">    mu = {</div><div class="line">      w = (state =<span class="number"> 0</span>, sema =<span class="number"> 0</span>)</div><div class="line">      writerSem =<span class="number"> 0</span></div><div class="line">      readerSem =<span class="number"> 0</span></div><div class="line">      readerCount =<span class="number"> 0</span></div><div class="line">      readerWait =<span class="number"> 0</span></div><div class="line">    }</div><div class="line">    output = (<span class="built_in">len</span><span class="number"> 0</span>, <span class="built_in">cap</span><span class="number"> 0</span>) {}</div><div class="line">    failed = <span class="constant">false</span></div><div class="line">    skipped = <span class="constant">false</span></div><div class="line">    finished = <span class="constant">false</span></div><div class="line">    start = {</div><div class="line">      sec =<span class="number"> 63579066045</span></div><div class="line">      nsec =<span class="number"> 777400918</span></div><div class="line">      loc =<span class="number"> 0</span>x00000000002995a0</div><div class="line">    }</div><div class="line">    duration =<span class="number"> 0</span></div><div class="line">    self =<span class="number"> 0</span>x000000020834a000</div><div class="line">    signal =<span class="number"> 0</span>x0000000208322060</div><div class="line">  }</div><div class="line">  name = <span class="string">"TestFind"</span></div><div class="line">  startParallel =<span class="number"> 0</span>x0000000208322240</div><div class="line">}</div><div class="line">(lldb) p *t.startParallel</div><div class="line">(hchan&lt;<span class="typename">bool</span>&gt;) <span class="number">$3</span> = {</div><div class="line">  qcount =<span class="number"> 0</span></div><div class="line">  dataqsiz =<span class="number"> 0</span></div><div class="line">  buf =<span class="number"> 0</span>x0000000208322240</div><div class="line">  elemsize =<span class="number"> 1</span></div><div class="line">  closed =<span class="number"> 0</span></div><div class="line">  elemtype =<span class="number"> 0</span>x000000000014eda0</div><div class="line">  sendx =<span class="number"> 0</span></div><div class="line">  recvx =<span class="number"> 0</span></div><div class="line">  recvq = {</div><div class="line">    first =<span class="number"> 0</span>x0000000000000000</div><div class="line">    last =<span class="number"> 0</span>x0000000000000000</div><div class="line">  }</div><div class="line">  sendq = {</div><div class="line">    first =<span class="number"> 0</span>x0000000000000000</div><div class="line">    last =<span class="number"> 0</span>x0000000000000000</div><div class="line">  }</div><div class="line">  lock = (key =<span class="number"> 0</span>x0000000000000000)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>hchan&lt;bool&gt;</code>是这个channel的在运行时的内部数据结构。</p>
<p>步进:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">(lldb) n <span class="comment"># execute next line</span></div><div class="line">(lldb) <span class="comment"># enter is repeat</span></div><div class="line">(lldb) <span class="comment"># enter is repeat</span></div><div class="line">Process <span class="number">17917</span> stopped</div><div class="line">* thread <span class="comment">#8: tid = 0x0017, 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151, stop reason = step over</span></div><div class="line">    frame <span class="comment">#0: 0x000000000008648f regexp.test`_/code/go/src/regexp.TestFind(t=0x000000020834a000) + 271 at find_test.go:151</span></div><div class="line">   <span class="number">148</span>         func TestFind(t *testing.T) {</div><div class="line">   <span class="number">149</span>                 for _, test := range findTests {</div><div class="line">   <span class="number">150</span>                         re := MustCompile(test.pat)</div><div class="line">-&gt; <span class="number">151</span>                         <span class="keyword">if</span> re.String() != test.pat {</div><div class="line">   <span class="number">152</span>                                 t.Errorf(<span class="string">"String() = `%s`; should be `%s`"</span>, re.String(), test.pat)</div><div class="line">   <span class="number">153</span>                         }</div><div class="line">   <span class="number">154</span>                         result := re.Find([]byte(test.text))</div><div class="line">(lldb) p test.pat</div><div class="line">(string) $<span class="number">4</span> = <span class="string">""</span></div><div class="line">(lldb) p re</div><div class="line">(*_/code/go/src/regexp.Regexp) $<span class="number">5</span> = <span class="number">0</span>x0000000208354320</div><div class="line">(lldb) p *re</div><div class="line">(_/code/go/src/regexp.Regexp) $<span class="number">6</span> = {</div><div class="line">  <span class="variable">expr =</span> <span class="string">""</span></div><div class="line">  <span class="variable">prog =</span> <span class="number">0</span>x0000000208ac6090</div><div class="line">  <span class="variable">onepass =</span> <span class="number">0</span>x0000000000000000</div><div class="line">  <span class="variable">prefix =</span> <span class="string">""</span></div><div class="line">  <span class="variable">prefixBytes =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">  <span class="variable">prefixComplete =</span> <span class="constant">true</span></div><div class="line">  <span class="variable">prefixRune =</span> <span class="number">0</span></div><div class="line">  <span class="variable">prefixEnd =</span> <span class="number">0</span></div><div class="line">  <span class="variable">cond =</span> <span class="number">0</span></div><div class="line">  <span class="variable">numSubexp =</span> <span class="number">0</span></div><div class="line">  <span class="variable">subexpNames =</span> (len <span class="number">1</span>, cap <span class="number">1</span>) {</div><div class="line">    [<span class="number">0</span>] = <span class="string">""</span></div><div class="line">  }</div><div class="line">  <span class="variable">longest =</span> <span class="constant">false</span></div><div class="line">  <span class="variable">mu =</span> (<span class="variable">state =</span> <span class="number">0</span>, <span class="variable">sema =</span> <span class="number">0</span>)</div><div class="line">  <span class="variable">machine =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">}</div><div class="line">(lldb) p *re.prog</div><div class="line">(regexp/syntax.Prog) $<span class="number">7</span> = {</div><div class="line">  <span class="variable">Inst =</span> (len <span class="number">3</span>, cap <span class="number">4</span>) {</div><div class="line">    [<span class="number">0</span>] = {</div><div class="line">      <span class="variable">Op =</span> <span class="number">5</span></div><div class="line">      <span class="variable">Out =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Arg =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Rune =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">    }</div><div class="line">    [<span class="number">1</span>] = {</div><div class="line">      <span class="variable">Op =</span> <span class="number">6</span></div><div class="line">      <span class="variable">Out =</span> <span class="number">2</span></div><div class="line">      <span class="variable">Arg =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Rune =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">    }</div><div class="line">    [<span class="number">2</span>] = {</div><div class="line">      <span class="variable">Op =</span> <span class="number">4</span></div><div class="line">      <span class="variable">Out =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Arg =</span> <span class="number">0</span></div><div class="line">      <span class="variable">Rune =</span> (len <span class="number">0</span>, cap <span class="number">0</span>) {}</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="variable">Start =</span> <span class="number">1</span></div><div class="line">  <span class="variable">NumCap =</span> <span class="number">2</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们还可以通过<code>s</code>命令 <code>Step Into</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(lldb) s</div><div class="line">Process <span class="number">17917</span> stopped</div><div class="line"><span class="subst">*</span> <span class="keyword">thread</span> <span class="variable">#8</span>: tid <span class="subst">=</span> <span class="number">0x0017</span>, <span class="number">0x0000000000067332</span> regexp<span class="built_in">.</span>test<span class="string">`_/code/go/src/regexp.(re=0x0000000208354320, ~r0="").String + 18 at regexp.go:104, stop reason = step in</span></div><div class="line">    frame #0: 0x0000000000067332 regexp.test`_/code/go/src/regexp<span class="built_in">.</span>(re<span class="subst">=</span><span class="number">0x0000000208354320</span>, ~r0<span class="subst">=</span><span class="string">""</span>)<span class="built_in">.</span><span class="built_in">String</span> <span class="subst">+</span> <span class="number">18</span> at regexp<span class="built_in">.</span>go:<span class="number">104</span></div><div class="line">   <span class="number">101</span></div><div class="line">   <span class="number">102</span>         <span class="comment">// String returns the source text used to compile the regular expression.</span></div><div class="line">   <span class="number">103</span>         func (re <span class="subst">*</span>Regexp) <span class="built_in">String</span>() <span class="built_in">string</span> {</div><div class="line"><span class="subst">-&gt; </span><span class="number">104</span>                 <span class="keyword">return</span> re<span class="built_in">.</span>expr</div><div class="line">   <span class="number">105</span>         }</div><div class="line">   <span class="number">106</span></div><div class="line">   <span class="number">107</span>         <span class="comment">// Compile parses a regular expression and returns, if successful,</span></div></pre></td></tr></table></figure>

<p>查看堆栈信息，看看目前我们停在哪儿：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(lldb) bt</div><div class="line">* thread #<span class="number">8</span>: tid = <span class="number">0x0017</span>, <span class="number">0x0000000000067332</span> <span class="built_in">regexp</span>.test`_/code/go/src/<span class="built_in">regexp</span>.(re=<span class="number">0x0000000208354320</span>, ~r0=<span class="string">""</span>).<span class="built_in">String</span> + <span class="number">18</span> at <span class="built_in">regexp</span>.go:<span class="number">104</span>, <span class="keyword">stop</span> reason = <span class="keyword">step</span> <span class="keyword">in</span></div><div class="line">  * frame #<span class="number">0</span>: <span class="number">0x0000000000067332</span> <span class="built_in">regexp</span>.test`_/code/go/src/<span class="built_in">regexp</span>.(re=<span class="number">0x0000000208354320</span>, ~r0=<span class="string">""</span>).<span class="built_in">String</span> + <span class="number">18</span> at <span class="built_in">regexp</span>.go:<span class="number">104</span></div><div class="line">    frame #<span class="number">1</span>: <span class="number">0x00000000000864a0</span> <span class="built_in">regexp</span>.test`_/code/go/src/<span class="built_in">regexp</span>.TestFind(t=<span class="number">0x000000020834a000</span>) + <span class="number">288</span> at find_test.go:<span class="number">151</span></div><div class="line">    frame #<span class="number">2</span>: <span class="number">0x0000000000056e3f</span> <span class="built_in">regexp</span>.test`testing.tRunner(t=<span class="number">0x000000000003b671</span>, test=<span class="number">0x000000020834a000</span>) + <span class="number">191</span> at testing.go:<span class="number">447</span></div><div class="line">    frame #<span class="number">3</span>: <span class="number">0x00000000002995a0</span> <span class="built_in">regexp</span>.test`/code/go/src/<span class="built_in">regexp</span>.statictmp_3759 + <span class="number">96</span></div><div class="line">    frame #<span class="number">4</span>: <span class="number">0x000000000003b671</span> <span class="built_in">regexp</span>.test`runtime.goexit + <span class="number">1</span> at asm_amd64.s:<span class="number">2232</span></div></pre></td></tr></table></figure>

<h2 id="其它调试参考文章">其它调试参考文章</h2>
<ol>
<li><a href="https://github.com/Microsoft/vscode-go/wiki/Debugging-Go-code-using-VS-Code" target="_blank" rel="external">Debugging Go code using VS Code</a></li>
<li><a href="https://golang.org/doc/gdb" target="_blank" rel="external">Debugging Go Code with GDB</a></li>
<li><a href="https://lincolnloop.com/blog/debugging-go-code/" target="_blank" rel="external">Debugging Go Code</a></li>
<li><a href="https://blog.gopheracademy.com/advent-2015/debugging-with-delve/" target="_blank" rel="external">Debugging Go programs with Delve</a></li>
<li><a href="https://www.youtube.com/watch?v=iPBUaDcehJo" target="_blank" rel="external">debug by Goland</a></li>
<li><a href="https://blog.codeship.com/using-gdb-debugger-with-go/" target="_blank" rel="external">Using the gdb debugger with Go</a></li>
<li><a href="https://gocn.io/article/657" target="_blank" rel="external">用 debugger 学习 golang</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>我一般调试Go程序都是通过log日志，性能调试的话通过 pprof 、trace、flamegraph等，主要是Go没有一个很好的集成的debugger,前两年虽然关注了delve，但是在IDE中集成比较粗糙，调试也很慢，所以基本不使用debugger进行调试， 最近看到滴滴的工程师分享的使用debugger在调试Go程序，我觉得有必要在尝试一下这方面的技术了。</p>
<p>本文翻译自 <a href="http://ribrdb.github.io/lldb/" target="_blank" rel="external">Debugging Go Code with LLDB</a>, 更好的调试Go程序的工具是<a href="https://github.com/derekparker/delve" target="_blank" rel="external">delve</a>, 因为它是专门为Go开发， 使用起来也很简单，并且还可以远程调试。delve的命令还可参考： <a href="https://github.com/derekparker/delve/tree/master/Documentation/cli" target="_blank" rel="external">dlv cli</a>，但是流行的通用的基础的debugger也是常用的手段之一。我在译文后面也列出了几篇其它关于go debug的相关文章，有兴趣的话也可以扩展阅读一下。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go网络开发中的两个技术点]]></title>
    <link href="http://colobu.com/2018/03/08/two-issues-in-go-development/"/>
    <id>http://colobu.com/2018/03/08/two-issues-in-go-development/</id>
    <published>2018-03-08T07:32:50.000Z</published>
    <updated>2018-03-26T13:58:03.950Z</updated>
    <content type="html"><![CDATA[<p>最近碰到群里网友问如果检查网络连接的Timeout,联想最近看到的另一个问题， 在这篇文章统一记录一下。</p>
<a id="more"></a>
<h3 id="如果检查一个网络错误是Timeout导致的？">如果检查一个网络错误是Timeout导致的？</h3>
<p>自 Go 1.6开始， 所有的超时导致的网络错误都可以通过<code>net.Error</code>的<code>Timeout()</code>方法检查。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> err, ok := err.(net.Error); ok && err.Timeout() {</div><div class="line">    ……</div><div class="line">}</div></pre></td></tr></table></figure>

<p>更早版本的Go并没有专门的检查Timeout方法。</p>
<p>可以参考： <a href="https://stackoverflow.com/questions/23494950/specifically-check-for-timeout-error" target="_blank" rel="external">https://stackoverflow.com/questions/23494950/specifically-check-for-timeout-error</a></p>
<h3 id="产品中一定不要使用默认的http-Get">产品中一定不要使用默认的<code>http.Get</code></h3>
<p>如果你觉得方便，直接使用<code>http.Get</code>或者类似的方法发送请求，可能会导致一些问题， 因为这默认是使用<code>DefaultClient</code>作为client:</p>
<ol>
<li>多goroutine共享，这意味着在别处对<code>DefaultClient</code>的改动会影响你当前的使用</li>
<li>未设置connection timeout和 read/write timeout</li>
<li>默认的idle connection等设置可能不满足你的需求</li>
</ol>
<p>一个具体的使用默认的client导致的问题可以参考 <a href="https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779" target="_blank" rel="external">Don’t use Go’s default HTTP client (in production)</a>。</p>
<p>所以Go开发过程中最好使用自己定制的Client:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> timeout = time.Duration<span class="number">(2</span> * time.Second)</div><div class="line"></div><div class="line"><span class="keyword">func</span> dialTimeout(network, addr <span class="typename">string</span>) (net.Conn, error) {</div><div class="line">    <span class="keyword">return</span> net.DialTimeout(network, addr, timeout)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    transport := http.Transport{</div><div class="line">        Dial: dialTimeout,</div><div class="line">        Proxy: ...,</div><div class="line">        MaxIdleConns: ...,</div><div class="line">        MaxIdleConnsPerHost: ...,</div><div class="line">        IdleConnTimeout: ...,</div><div class="line">        ResponseHeaderTimeout: ...,</div><div class="line">        DisableCompression:...,</div><div class="line">    }</div><div class="line"></div><div class="line">    client := http.Client{</div><div class="line">        Transport: &transport,</div><div class="line">    }</div><div class="line"></div><div class="line">    resp, err := client.Get(<span class="string">"http://some.url"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>酌情设置<code>Transport</code>的参数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近碰到群里网友问如果检查网络连接的Timeout,联想最近看到的另一个问题， 在这篇文章统一记录一下。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go addressable 详解]]></title>
    <link href="http://colobu.com/2018/02/27/go-addressable/"/>
    <id>http://colobu.com/2018/02/27/go-addressable/</id>
    <published>2018-02-27T10:48:46.000Z</published>
    <updated>2018-03-26T13:58:03.918Z</updated>
    <content type="html"><![CDATA[<p>Go语言规范中规定了可寻址(addressable)对象的定义,</p>
<blockquote>
<p>For an operand x of type T, the address operation &amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, x may also be a (possibly parenthesized) composite literal. If the evaluation of x would cause a run-time panic, then the evaluation of &amp;x does too.</p>
</blockquote>
<p>对于一个对象<code>x</code>, 如果它的类型为<code>T</code>, 那么<code>&amp;x</code>则会产生一个类型为<code>*T</code>的指针，这个指针指向<code>x</code>, 这是这一段的第一句话，也是我们在开发过程中经常使用的一种获取对象指针的一种方式。 </p>
<a id="more"></a>
<p><img src="memory.jpg" alt=""></p>
<h2 id="addressable">addressable</h2>
<p>上面规范中的这段话规定， <code>x</code>必须是可寻址的， 也就是说，它只能是以下几种方式：</p>
<ul>
<li>一个变量: <code>&amp;x</code></li>
<li>指针引用(pointer indirection): <code>&amp;*x</code></li>
<li>slice索引操作(不管slice是否可寻址): <code>&amp;s[1]</code></li>
<li>可寻址struct的字段: <code>&amp;point.X</code></li>
<li>可寻址数组的索引操作: <code>&amp;a[0]</code></li>
<li>composite literal类型: <code>&amp;struct{ X int }{1}</code></li>
</ul>
<p>下列情况<code>x</code>是不可以寻址的，你不能使用<code>&amp;x</code>取得指针：</p>
<ul>
<li>字符串中的字节:</li>
<li>map对象中的元素</li>
<li>接口对象的动态值(通过type assertions获得)</li>
<li>常数</li>
<li>literal值(非composite literal)</li>
<li>package 级别的函数</li>
<li>方法method (用作函数值)</li>
<li>中间值(intermediate value):<ul>
<li>函数调用</li>
<li>显式类型转换</li>
<li>各种类型的操作 （除了指针引用pointer dereference操作 <code>*x</code>):<ul>
<li>channel receive operations</li>
<li>sub-string operations</li>
<li>sub-slice operations</li>
<li>加减乘除等运算符</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tapir Games在他的文章<a href="http://www.tapirgames.com/blog/golang-unofficial-faq#unaddressable-values" target="_blank" rel="external">unaddressable-values</a>中做了很好的整理。</p>
</blockquote>
<p>有几个点需要解释下：</p>
<ul>
<li>常数为什么不可以寻址?： 如果可以寻址的话，我们可以通过指针修改常数的值，破坏了常数的定义。</li>
<li>map的元素为什么不可以寻址？:两个原因，如果对象不存在，则返回零值，零值是不可变对象，所以不能寻址，如果对象存在，因为Go中map实现中元素的地址是变化的，这意味着寻址的结果是无意义的。</li>
<li>为什么slice不管是否可寻址，它的元素读是可以寻址的？:因为slice底层实现了一个数组，它是可以寻址的。</li>
<li>为什么字符串中的字符/字节又不能寻址呢：因为字符串是不可变的。</li>
</ul>
<p>规范中还有几处提到了 <code>addressable</code>:</p>
<ul>
<li>调用一个receiver为指针类型的方法时，使用一个addressable的值将自动获取这个值的指针</li>
<li><code>++</code>、<code>--</code>语句的操作对象必须是addressable或者是map的index操作</li>
<li>赋值语句<code>=</code>的左边对象必须是addressable,或者是map的index操作，或者是<code>_</code></li>
<li>上条同样使用<code>for ... range</code>语句</li>
</ul>
<h2 id="reflect-Value的CanAddr方法和CanSet方法"><code>reflect.Value</code>的<code>CanAddr</code>方法和<code>CanSet</code>方法</h2>
<p>在我们使用<code>reflect</code>执行一些底层的操作的时候， 比如编写序列化库、rpc框架开发、编解码、插件开发等业务的时候，经常会使用到<code>reflect.Value</code>的<code>CanSet</code>方法，用来动态的给对象赋值。 <code>CanSet</code>比<code>CanAddr</code>只加了一个限制，就是struct类型的<code>unexported</code>的字段不能<code>Set</code>，所以我们这节主要介绍<code>CanAddr</code>。</p>
<p>并不是任意的<code>reflect.Value</code>的<code>CanAddr</code>方法都返回<code>true</code>,根据它的godoc,我们可以知道：</p>
<blockquote>
<p>CanAddr reports whether the value&#39;s address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.</p>
</blockquote>
<p>也就是只有下面的类型<code>reflect.Value</code>的<code>CanAddr</code>才是<code>true</code>, 这样的值是<code>addressable</code>:</p>
<ul>
<li>slice的元素</li>
<li>可寻址数组的元素</li>
<li>可寻址struct的字段</li>
<li>指针引用的结果</li>
</ul>
<p>与规范中规定的<code>addressable</code>, <code>reflect.Value</code>的<code>addressable</code>范围有所缩小， 比如对于栈上分配的变量， 随着方法的生命周期的结束， 栈上的对象也就被回收掉了，这个时候如果获取它们的地址，就会出现不一致的结果，甚至安全问题。</p>
<blockquote>
<p>对于栈和堆的对象分配以及逃逸分析，你可以看 William Kennedy  写的系列文章: <a href="https://studygolang.com/articles/12444" target="_blank" rel="external">Go 语言机制之逃逸分析</a></p>
</blockquote>
<p>所以如果你想通过<code>reflect.Value</code>对它的值进行更新，应该确保它的<code>CanSet</code>方法返回<code>true</code>,这样才能调用<code>SetXXX</code>进行设置。</p>
<p>使用<code>reflect.Value</code>的时候有时会对<code>func Indirect(v Value) Value</code>和<code>func (v Value) Elem() Value</code>两个方法有些迷惑，有时候他们俩会返回同样的值，有时候又不会。</p>
<p>总结一下：</p>
<ol>
<li>如果<code>reflect.Value</code>是一个指针， 那么<code>v.Elem()</code>等价于<code>reflect.Indirect(v)</code></li>
<li>如果不是指针<br>2.1 如果是<code>interface</code>, 那么<code>reflect.Indirect(v)</code>返回同样的值，而<code>v.Elem()</code>返回接口的动态的值<br>2.2 如果是其它值, <code>v.Elem()</code>会panic,而<code>reflect.Indirect(v)</code>返回原值</li>
</ol>
<p>下面的代码列出一些<code>reflect.Value</code>是否可以addressable, 你需要注意数组和struct字段的情况，也就是<code>x7</code>、<code>x9</code>、<code>x14</code>、<code>x15</code>的正确的处理方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"reflect"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	checkCanAddr()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	X <span class="typename">int</span></div><div class="line">	Y <span class="typename">string</span></div><div class="line">	z <span class="typename">int</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> M() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 100</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> x0 =<span class="number"> 0</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> checkCanAddr() {</div><div class="line">	<span class="comment">// 可寻址的情况</span></div><div class="line">	v := reflect.ValueOf(x0)</div><div class="line">	fmt.Printf(<span class="string">"x0: %v \tcan be addressable and set: %t, %t\n"</span>, x0, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x1 =<span class="number"> 1</span></div><div class="line">	v = reflect.Indirect(reflect.ValueOf(x1))</div><div class="line">	fmt.Printf(<span class="string">"x1: %v \tcan be addressable and set: %t, %t\n"</span>, x1, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x2 = &x1</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(x2))</div><div class="line">	fmt.Printf(<span class="string">"x2: %v \tcan be addressable and set: %t, %t\n"</span>, x2, v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x3 = time.Now()</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(x3))</div><div class="line">	fmt.Printf(<span class="string">"x3: %v \tcan be addressable and set: %t, %t\n"</span>, x3, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x4 = &x3</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(x4))</div><div class="line">	fmt.Printf(<span class="string">"x4: %v \tcan be addressable and set: %t, %t\n"</span>, x4, v.CanAddr(), v.CanSet()) <span class="comment">// true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x5 = []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	v = reflect.ValueOf(x5)</div><div class="line">	fmt.Printf(<span class="string">"x5: %v \tcan be addressable and set: %t, %t\n"</span>, x5, v.CanAddr(), v.CanSet()) <span class="comment">// false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x6 = []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	v = reflect.ValueOf(x6<span class="number">[0</span>])</div><div class="line">	fmt.Printf(<span class="string">"x6: %v \tcan be addressable and set: %t, %t\n"</span>, x6<span class="number">[0</span>], v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x7 = []<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	v = reflect.ValueOf(x7).Index<span class="number">(0</span>)</div><div class="line">	fmt.Printf(<span class="string">"x7: %v \tcan be addressable and set: %t, %t\n"</span>, x7<span class="number">[0</span>], v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	v = reflect.ValueOf(&x7<span class="number">[1</span>])</div><div class="line">	fmt.Printf(<span class="string">"x7.1: %v \tcan be addressable and set: %t, %t\n"</span>, x7<span class="number">[1</span>], v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x8 = <span class="number">[3</span>]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	v = reflect.ValueOf(x8<span class="number">[0</span>])</div><div class="line">	fmt.Printf(<span class="string">"x8: %v \tcan be addressable and set: %t, %t\n"</span>, x8<span class="number">[0</span>], v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="comment">// https://groups.google.com/forum/#!topic/golang-nuts/RF9zsX82MWw</span></div><div class="line">	<span class="keyword">var</span> x9 = <span class="number">[3</span>]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(x9).Index<span class="number">(0</span>))</div><div class="line">	fmt.Printf(<span class="string">"x9: %v \tcan be addressable and set: %t, %t\n"</span>, x9<span class="number">[0</span>], v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x10 = <span class="number">[3</span>]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(&x10)).Index<span class="number">(0</span>)</div><div class="line">	fmt.Printf(<span class="string">"x9: %v \tcan be addressable and set: %t, %t\n"</span>, x10<span class="number">[0</span>], v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x11 = S{}</div><div class="line">	v = reflect.ValueOf(x11)</div><div class="line">	fmt.Printf(<span class="string">"x11: %v \tcan be addressable and set: %t, %t\n"</span>, x11, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x12 = S{}</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(&x12))</div><div class="line">	fmt.Printf(<span class="string">"x12: %v \tcan be addressable and set: %t, %t\n"</span>, x12, v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x13 = S{}</div><div class="line">	v = reflect.ValueOf(x13).FieldByName(<span class="string">"X"</span>)</div><div class="line">	fmt.Printf(<span class="string">"x13: %v \tcan be addressable and set: %t, %t\n"</span>, x13, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x14 = S{}</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(&x14)).FieldByName(<span class="string">"X"</span>)</div><div class="line">	fmt.Printf(<span class="string">"x14: %v \tcan be addressable and set: %t, %t\n"</span>, x14, v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x15 = S{}</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(&x15)).FieldByName(<span class="string">"z"</span>)</div><div class="line">	fmt.Printf(<span class="string">"x15: %v \tcan be addressable and set: %t, %t\n"</span>, x15, v.CanAddr(), v.CanSet()) <span class="comment">//true,false</span></div><div class="line"></div><div class="line">	v = reflect.Indirect(reflect.ValueOf(&S{}))</div><div class="line">	fmt.Printf(<span class="string">"x15.1: %v \tcan be addressable and set: %t, %t\n"</span>, &S{}, v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x16 = M</div><div class="line">	v = reflect.ValueOf(x16)</div><div class="line">	fmt.Printf(<span class="string">"x16: %p \tcan be addressable and set: %t, %t\n"</span>, x16, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x17 = M</div><div class="line">	v = reflect.Indirect(reflect.ValueOf(&x17))</div><div class="line">	fmt.Printf(<span class="string">"x17: %p \tcan be addressable and set: %t, %t\n"</span>, x17, v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x18 <span class="keyword">interface</span>{} = &x11</div><div class="line">	v = reflect.ValueOf(x18)</div><div class="line">	fmt.Printf(<span class="string">"x18: %v \tcan be addressable and set: %t, %t\n"</span>, x18, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x19 <span class="keyword">interface</span>{} = &x11</div><div class="line">	v = reflect.ValueOf(x19).Elem()</div><div class="line">	fmt.Printf(<span class="string">"x19: %v \tcan be addressable and set: %t, %t\n"</span>, x19, v.CanAddr(), v.CanSet()) <span class="comment">//true,true</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> x20 = [...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>}</div><div class="line">	v = reflect.ValueOf([...]<span class="typename">int</span><span class="number">{1</span>,<span class="number"> 2</span>,<span class="number"> 3</span>})</div><div class="line">	fmt.Printf(<span class="string">"x20: %v \tcan be addressable and set: %t, %t\n"</span>, x20, v.CanAddr(), v.CanSet()) <span class="comment">//false,false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.tapirgames.com/blog/golang-unofficial-faq#unaddressable-values" target="_blank" rel="external">http://www.tapirgames.com/blog/golang-unofficial-faq#unaddressable-values</a></li>
<li><a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="external">https://blog.golang.org/laws-of-reflection</a></li>
<li><a href="https://stackoverflow.com/questions/25384640/why-golang-reflect-makeslice-returns-un-addressable-value" target="_blank" rel="external">https://stackoverflow.com/questions/25384640/why-golang-reflect-makeslice-returns-un-addressable-value</a></li>
<li><a href="http://grokbase.com/t/gg/golang-nuts/13bwpzedxh/go-nuts-golang-reflect-addressable-is-not-consistency" target="_blank" rel="external">http://grokbase.com/t/gg/golang-nuts/13bwpzedxh/go-nuts-golang-reflect-addressable-is-not-consistency</a></li>
<li><a href="https://github.com/golang/go/issues/11865" target="_blank" rel="external">https://github.com/golang/go/issues/11865</a></li>
<li><a href="https://stackoverflow.com/questions/20224478/dereferencing-a-map-index-in-golang" target="_blank" rel="external">https://stackoverflow.com/questions/20224478/dereferencing-a-map-index-in-golang</a></li>
<li><a href="https://stackoverflow.com/questions/38168329/why-are-map-values-not-addressable" target="_blank" rel="external">https://stackoverflow.com/questions/38168329/why-are-map-values-not-addressable</a></li>
<li><a href="https://stackoverflow.com/questions/40793289/go-struct-literals-why-is-this-one-addressable" target="_blank" rel="external">https://stackoverflow.com/questions/40793289/go-struct-literals-why-is-this-one-addressable</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/FnTCX9R_PbM" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/FnTCX9R_PbM</a></li>
<li><a href="https://stackoverflow.com/questions/24318389/golang-elem-vs-indirect-in-the-reflect-package" target="_blank" rel="external">https://stackoverflow.com/questions/24318389/golang-elem-vs-indirect-in-the-reflect-package</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Go语言规范中规定了可寻址(addressable)对象的定义,</p>
<blockquote>
<p>For an operand x of type T, the address operation &amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, x may also be a (possibly parenthesized) composite literal. If the evaluation of x would cause a run-time panic, then the evaluation of &amp;x does too.</p>
</blockquote>
<p>对于一个对象<code>x</code>, 如果它的类型为<code>T</code>, 那么<code>&amp;x</code>则会产生一个类型为<code>*T</code>的指针，这个指针指向<code>x</code>, 这是这一段的第一句话，也是我们在开发过程中经常使用的一种获取对象指针的一种方式。 </p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转][译]在 Java 中运用动态挂载实现 Bug 的热修复]]></title>
    <link href="http://colobu.com/2018/02/24/Fixing-Bugs-in-Running-Java-Code-with-Dynamic-Attach/"/>
    <id>http://colobu.com/2018/02/24/Fixing-Bugs-in-Running-Java-Code-with-Dynamic-Attach/</id>
    <published>2018-02-24T11:00:24.000Z</published>
    <updated>2018-02-27T13:03:20.252Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://www.sitepoint.com/fixing-bugs-in-running-java-code-with-dynamic-attach/" target="_blank" rel="external">Fixing Bugs in Running Java Code with Dynamic Attach</a> by Rafael Winterhalter</p>
<p><a href="https://www.oschina.net" target="_blank" rel="external">开源中国</a>组织翻译: <a href="http://www.oschina.net/translate/fixing-bugs-in-running-java-code-with-dynamic-attach" target="_blank" rel="external">在 Java 中运用动态挂载实现 Bug 的热修复</a> by TedCruz、<br>无若、LeoXu、Tocy等。</p>
<p>大多数 JVM 具备 Java 的 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/enhancements1.4.html#hotswap" target="_blank" rel="external">HotSwap</a> 特性，大部分开发者认为它仅仅是一个调试工具。利用这一特性,有可能在不重启 Java 进程条件下，改变 Java 方法的实现。典型的例子是使用 IDE 来编码。然而 HotSwap 可以在生产环境中实现这一功能。通过这种方式，不用停止运行程序，就可以扩展在线的应用程序，或者在运行的项目上修复小的错误。这篇文章中，我将演示动态绑定、应用运行期代码变化进行绑定、介绍一些工具 API 以及 <a href="http://bytebuddy.net/" target="_blank" rel="external">Byte Buddy 库</a>，这个库提供了一些 API 代码改变更方便。</p>
<a id="more"></a>
<p>假设有一个正在运行的应用程序，通过校验 HTTP 请求中的 <code>X-Priority</code> 头部，来执行服务器的特殊处理。该校验使用下面的工具类来实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class HeaderUtility {</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> isPriorityCall(HttpServletRequest request) {</div><div class="line">        <span class="keyword">return</span> request.getHeader(<span class="string">"X-Pirority"</span>) != <span class="keyword">null</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>你发现拼写错误了吗 (<code>Pirority</code>)？这样的错误很常见，尤其是在测试代码中常量值分解为静态字段重用。在不太理想的情况下，这个错误只会在产品被安装的时候才被发现，其中头通过另外一个应用生成并没有拼写错误。</p>
<p>修复这样的错误并不难。在持续交付的时代，重新部署一个新的版本只需要点击一下按钮。但在其他情况下，变更可能就不是那么简单了，重新部署过程可能比较复杂，其中停机是不允许的，带着错误运行可能会比较好。但 HotSwap 给我们提供了另外一种选择：在不重启应用的前提下进行小幅改动。</p>
<h2 id="Attach_API：使用动态附件来渗透另外一个_JVM">Attach API：使用动态附件来渗透另外一个 JVM</h2>
<p>为了修改一个运行中的 Java 程序，我们首先需要一种可以同处在运行状态的 JVM 进行通信的方式。因为 Java 的虚拟机实现是一个受到管理的系统，因此拥有进行这些操作的标准 API。提问中涉及到的 API 被称作 attachment API，它是官方 Java 工具的一部分。使用这个由运行之中的 JVM 所暴露的 API，能让第二个 Java 进程来同其进行通信。</p>
<p>事实上，我们已经用到了该 API: 它已经由诸如 <a href="https://github.com/visualvm" target="_blank" rel="external">VisualVM</a> 或者 <a href="http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html" target="_blank" rel="external">Java Mission Control</a> 这样的调试和模拟工具进行了应用。应用这些附件的 API 并没有同日常使用的标准 Java API 打包在一起，而是被打包到了一个特殊的文件之中，叫做 tools.jar，它只包含了一个虚拟机的 JDK 打包发布版本。更糟糕的是，这个 JAR 文件的位置并没有进行设置，它在 Windows、Linux，特别是在 Macintosh 上的 VM 都存在差别，不光文件的位置，连文件名也各异，有些发行版上就被叫做 classes.jar。最后，IBM 甚至决定对这个 JAR 中包含的一些类的名称进行修改，将所有 com.sun 类挪到 com.ibm 命名空间之中, 又添了一个乱子。在 Java 9 中，乱糟糟的状态才最终得以清理，tools.jar 被 <a href="http://download.java.net/java/jigsaw/docs/jdk/api/attach/spec/jdk.attach-summary.html" target="_blank" rel="external">Jigsaw 的模块 jdk.attach</a> 所替代。</p>
<p><img src="dynamic-attach.png" alt=""></p>
<p>在对 API 的 JAR (或者模块) 进行了定位之后，我们就该让其对附件进程可用。在 OpenJDK 上，被用来连接到另外一个 JVM 的类叫做 <code>VirtualMachine</code>，它向任何由位于同一台物理机器上的 JDK 或者是一个普通的 HtpSpot JVM 所运行的 VM 提供了一个入口点。在通过进程 id 附加到另外一台虚拟机上之后，我们就能够在目标 VM 指定的一个线程中运行一个 JAR 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// the following strings must be provided by us</span></div><div class="line">String processId = processId();</div><div class="line">String jarFileName = jarFileName();</div><div class="line">VirtualMachine virtualMachine = VirtualMachine.attach(processId);</div><div class="line"><span class="keyword">try</span> {</div><div class="line">    virtualMachine.loadAgent(jarFileName, <span class="string">"World!"</span>);</div><div class="line">} <span class="keyword">finally</span> {</div><div class="line">    virtualMachine.detach();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在收到一个 JAR 文件之后，目标虚拟机会查看该 JAR 的程序清单描述文件（manifest），并定位处在 <code>Premain-Class</code> 属性之下的类。这非常类似于 VM 执行一个<code>main</code>方法的方式。有了一个 Java 代理，VM 和指定的进程 id 就可以查找到一个名为 <code>agentmain</code> 的方法，该方法可以由指定线程中的远程进程来执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAgent</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span>(String arg) {</div><div class="line">        System.out.println(<span class="string">"Hello, "</span> + arg);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用该 API，只要我们知道一个 JVM 的进程 id，就可以来在其上运行代码，打印出一条 <code>Hello, World!</code> 消息。甚至有可能同并不熟 JDK 发行版一部分的 JVM 进行通信，只要附加的 VM 是一个用来访问 tools.jar 的 JDK 安装程序。</p>
<h2 id="Instrumentation_API：修改目标_VM_的程序">Instrumentation API：修改目标 VM 的程序</h2>
<p>到目前来看一切顺利。但是除了成功地同目标 VM 建立起了通信之外，我们还不能够修改目标 VM 上的代码以及 BUG。后续的修改，Java 代理可以定义第二参数来接收一个 <code>Instrumentation</code> 的实例 。稍后要实现的接口提供了向几个底层方法的访问途径，它们中的一个就能够对已经加载的代码进行修改。</p>
<p>为了修正 &quot;X-Pirority&quot; 错字，我们首先来假设为 <code>HeaderUtility</code> 引入了一个修复类，叫做 <code>typo.fix</code>，就在我们下面所开发的 <code>BugFixAgent</code> 后面的代理的 JAR 文件中。此外，我们需要给予代理通过向 manifest 文件添加 <code>Can-Redefine-Classes: true</code> 来替换现有类的能力。有了现在这些东西，我们就可以使用 instrumentation 的 API 来对类进行重新定义，该 API 会接受一对已经加载的类以及用来执行类重定义的字节数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BugFixAgent</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span>(String arg, Instrumentation inst)</div><div class="line">            <span class="keyword">throws</span> Exception {</div><div class="line">        <span class="comment">// only if header utility is on the class path; otherwise,</span></div><div class="line">        <span class="comment">// a class can be found within any class loader by iterating</span></div><div class="line">        <span class="comment">// over the return value of Instrumentation::getAllLoadedClasses</span></div><div class="line">        Class&lt;?&gt; headerUtility = Class.forName(<span class="string">"HeaderUtility"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// copy the contents of typo.fix into a byte array</span></div><div class="line">        ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        <span class="keyword">try</span> (InputStream input =</div><div class="line">                BugFixAgent.class.getResourceAsStream(<span class="string">"/typo.fix"</span>)) {</div><div class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            <span class="keyword">int</span> length;</div><div class="line">            <span class="keyword">while</span> ((length = input.read(buffer)) != -<span class="number">1</span>) {</div><div class="line">                output.write(buffer, <span class="number">0</span>, length);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Apply the redefinition</span></div><div class="line">        instrumentation.redefineClasses(</div><div class="line">                <span class="keyword">new</span> ClassDefinition(headerUtility, output.toByteArray()));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>运行上述代码后，HeaderUtility 类会被重定义以对应其修补的版本。对 isPrivileged 的任何后续调用现在将读取正确的头信息。作为一个小的附加说明，JVM 可能会在应用类重定义时执行完全的垃圾回收，并且会对受影响的代码进行重新优化。 总之，这会导致应用程序性能的短时下降。然而，在大多数情况下，这是较之完全重启进程更好的方式。</p>
<p>当应用代码更改时，要确保新类定义了与它替换的类完全相同的字段、方法和修饰符。 尝试修改任何此类属性的类重定义行为都会导致 <code>UnsupportedOperationException</code>。现在 HotSpot 团队正<a href="http://openjdk.java.net/jeps/159" target="_blank" rel="external">试图去掉这个限制</a>。此外，基于 OpenJDK 的<a href="https://java.net/projects/dcevm" target="_blank" rel="external">动态代码演变虚拟机</a>支持预览此功能。</p>
<h2 id="使用_Byte_Buddy_来追踪内存泄漏">使用 Byte Buddy 来追踪内存泄漏</h2>
<p>一个如上述示例的简单的 BUG 修复代理在你熟悉了 instrumentation 的 API 的时候是比较容易实现的。只要更加深入一点，也可以在运行代理的时候，无需手动创建附加的 class 文件，而是通过重写现有的 class 来应用更多通用的代码修改。</p>
<h3 id="字节码操作">字节码操作</h3>
<p>编译好的 Java 代码所呈现的是一系列字节码指令。从这个角度来看，一个 Java 方法无非就是一个字节数组，其每一个字节都是在表示一个向运行时发出的指令，或者是最近一个指令的参数。每个字节对应其意义的映射在 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="external">《Java 虚拟机规范》</a> 中进行了定义，例如字节 <code>0xB1</code> 就是在指示 VM 从一个带有 void 返回类型的方法返回。因此，对字节码进行增强就是对一个方法的字节数字进行扩展，将我们想要应用的表示额外的业务逻辑指令包含进去。</p>
<p>当然，逐个字节的操作会特别麻烦，而且容易出错。为了避免手工的处理，许多的库都提供了更高级一点的 API，使用它们不需要我们直接同 Java 字节码打交道。这样的库其中就有一个叫做 <a href="https://github.com/raphw/byte-buddy" target="_blank" rel="external">Byte Buddy</a> (当然我就是该库的作者)。它的功能之一就是能够定义可以在方法原来的代码之前和之后被执行的模板方法。</p>
<h3 id="分析一个发生泄漏的应用程序">分析一个发生泄漏的应用程序</h3>
<p>这里的示例假定一个应用程序在生产环境运行了几周之后，被发现发生了泄漏资源的现象。像这样的 BUG 很难去跟踪，因为在一个可观察的测试环境中重现这样一个类似的问题状态比较困难。因此，（目前）要排除这样的问题除了重新启动崩溃的应用程序之外，我们还可以在当前线程中修改应用程序的代码来对泄漏进行跟踪。为了找出哪里才是应用程序泄漏句柄的位置，我们会对任何 <a href="https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html" target="_blank" rel="external">Closableobject</a> 的生命周期进行跟踪。使用一个 Java 代理，我们可以修改任何构造，或者关闭任意一个这样的对象。有了这个信息，我们就有希望确认哪个对象在哪种情况下会发生泄漏。</p>
<h3 id="使用模板进行操作">使用模板进行操作</h3>
<p>为了实现这一行为，我们首先要定义模板，模板里面包含了我们想要添加到任意一个 <code>Closeable</code> 的对象的构造器或者关闭方法调用中去的代码。为了了解发生泄漏的对象是在哪里被创建或者关闭的，我们就会想要在每一个这样的时间发生时将跟踪栈打印出来。针对这一逻辑的模板方法代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class ConstructionTemplate {</div><div class="line"></div><div class="line">    <span class="annotation">@Advice</span>.OnMethodExit</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> exit(<span class="annotation">@Advice</span>.This Object self) {</div><div class="line">        <span class="keyword">new</span> RuntimeException(<span class="string">"Created: "</span> + self).printStackTrace();</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line">class CloseTemplate {</div><div class="line"></div><div class="line">    <span class="annotation">@Advice</span>.OnMethodEnter</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> enter(<span class="annotation">@Advice</span>.This Object self) {</div><div class="line">        <span class="keyword">new</span> RuntimeException(<span class="string">"Closed: "</span> + self).printStackTrace();</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>模板方法上加上了 <code>OnMethodExit</code> 和 <code>OnMethodEnter</code> 注解，以通知 Byte Buddy 我们会想要它在什么时候被调用。它们的任何参数都会被加上注解，以指定其在被重新定义的方法中所表示的值。当应用了该模板时，Byte Buddy 接着就会将任何针对一个参数的访问映射到对注解的值进行加载，就好像方法实例一般就是由<code>this</code>来表示的。</p>
<p>为了将该修改应用到任何实现了 Closable 接口的类，Byte Buddy 提供了一种特定领域语言用以创建来匹配类型和方法的 Java 代理，并在其可应用时对上述模板进行应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TracingAgent</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span>(String arg, Instrumentation inst) {</div><div class="line">        <span class="keyword">new</span> AgentBuilder.Default()</div><div class="line">                <span class="comment">// by default, JVM classes are not instrumented</span></div><div class="line">                .ignore(none())</div><div class="line">                .disableClassFormatChanges()</div><div class="line">                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)</div><div class="line">                .type(isSubTypeOf(Closable.class))</div><div class="line">                .transform((builder, type, loader) -&gt; builder</div><div class="line">                        .visit(Advice</div><div class="line">                                .to(ConstructionTemplate.class)</div><div class="line">                                .on(isConstructor()))</div><div class="line">                        .visit(Advice</div><div class="line">                                .to(CloseTemplate.class)</div><div class="line">                                .on(named(<span class="string">"close"</span>).and(takesArguments(<span class="number">0</span>)))</div><div class="line">                        ))</div><div class="line">                .installOn(inst);</div><div class="line">    }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在默认情况下，Byte Buddy 不会对位于 <code>java.*</code> 命名空间中定义的类进行修改，它们可以通过设置一个无效的忽略匹配器来被修改。此外， Byte Buddy 需要在我们对重新转换进行应用的时候被告知不要去修改我们前面讨论过的 class 文件格式。只有这样做，Byte Buddy 才可以自动地侦测到任何实现了 <code>Closable</code> 接口的现有或者未来将会有的类型，并将上述的模板代码添加到其构造器和关闭方法。</p>
<h3 id="附加代理">附加代理</h3>
<p>Byte Buddy 还提供了在运行时附加一个代理的便利方法。为了应对 tools.jar 位置和虚拟机类型的差异, Byte Buddy 给附件添加了一个抽象层，在这一层可以自动检测到正确的设置。在将上述的代理打包到一个 JAR 文件中之后，就可以通过调用如下代码来附加到发生资源泄漏的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File jarFile = getAgent();</div><div class="line">String processId = getProcessId();</div><div class="line">ByteBuddyAgent.install(jarFile, processId);</div></pre></td></tr></table></figure>

<p>当然，上述代理很快就会为手动处理创建太多的输出。为了提供更多的便利，在释放之前再来收集被创建的对象也许会更有用。通过创建一个 Java 代理，这样也可以同编写一个 Java 应用程序来实现此行为一样的简单。</p>
<h2 id="总结">总结</h2>
<p>在本文中，我们深入了解了 attach API，它使得将一个 Java 代理按顺序注入到任意一个运行中的 JVM 进程成为可能。该代理被表示为一个 JAR 文件，里面包含了一个类，类里面有一个远程进程可以在一个指定线程中执行的 agentmain 方法。该方法可以接收一个 Instrumentation 接口的实例作为参数，可以读已经加载的类进行重新定义。对代码的重定义，既可以通过用打了补丁的版本替换整个 class 文件来实现，也可以通过对现有类的字节码进行修改来实现，这样的操作可以比较简单的用诸如 Byte Buddy 这样的库来完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://www.sitepoint.com/fixing-bugs-in-running-java-code-with-dynamic-attach/" target="_blank" rel="external">Fixing Bugs in Running Java Code with Dynamic Attach</a> by Rafael Winterhalter</p>
<p><a href="https://www.oschina.net" target="_blank" rel="external">开源中国</a>组织翻译: <a href="http://www.oschina.net/translate/fixing-bugs-in-running-java-code-with-dynamic-attach" target="_blank" rel="external">在 Java 中运用动态挂载实现 Bug 的热修复</a> by TedCruz、<br>无若、LeoXu、Tocy等。</p>
<p>大多数 JVM 具备 Java 的 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/enhancements1.4.html#hotswap" target="_blank" rel="external">HotSwap</a> 特性，大部分开发者认为它仅仅是一个调试工具。利用这一特性,有可能在不重启 Java 进程条件下，改变 Java 方法的实现。典型的例子是使用 IDE 来编码。然而 HotSwap 可以在生产环境中实现这一功能。通过这种方式，不用停止运行程序，就可以扩展在线的应用程序，或者在运行的项目上修复小的错误。这篇文章中，我将演示动态绑定、应用运行期代码变化进行绑定、介绍一些工具 API 以及 <a href="http://bytebuddy.net/" target="_blank" rel="external">Byte Buddy 库</a>，这个库提供了一些 API 代码改变更方便。</p>
]]>
    
    </summary>
    
      <category term="Java" scheme="http://colobu.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[10秒钟，让你的方法变为RPC服务]]></title>
    <link href="http://colobu.com/2018/02/13/make-your-methods-as-services-in-10-seconds/"/>
    <id>http://colobu.com/2018/02/13/make-your-methods-as-services-in-10-seconds/</id>
    <published>2018-02-13T06:04:01.000Z</published>
    <updated>2018-03-26T13:58:03.934Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/smallnest/rpcx" target="_blank" rel="external"><img src="https://img.shields.io/github/stars/smallnest/rpcx.svg?style=social&amp;logo=github&amp;label=Stars" alt="GitHub stars"></a></p>
<p><a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>一个服务治理的Go RPC框架， 拥有非常多的特性，支持跨语言的服务调用。 众多的特性可以参考<a href="https://doc.rpcx.site" target="_blank" rel="external">doc.rpcx.site</a>。它的服务治理的特性深受阿里巴巴的Dubbo框架的启发。</p>
<p>在实际的产品应用中，用户使用两台服务器+8台日志搜集服务(Client)，轻松处理每天几十亿的服务调用， 除了中间一个路由器硬件闪断， 整个系统平稳运行多半年。 相比较之前Java的实现， 服务器节省了一半。 用户使用rpcx框架重构后的系统每月为公司节省了几十万元的成本。</p>
<p>rpcx框架的一个设计哲学就是<strong>简单</strong>。不希望用户需要花费大量的时间在框架的学习上，并且不需要proto文件或者重复且冗余的服务配置。最少只需要10行代码就可以创建一个服务， 如果需要额外的配置，也只需要几十行的代码。</p>
<p>虽然rpcx开发简单，但是作为开发人员来说，如果可以更加的偷懒， 那更是极好的一件事情了，这就是<a href="https://github.com/smallnest/rpcx/tree/master/tool/xgen" target="_blank" rel="external">xgen</a>开发的目的。</p>
<p>这个工具可以搜寻指定的<code>package</code>下可以配置成rpcx服务的类型， 并且生成一个服务器程序，将这些服务注册到服务器程序中。你可以指定是否需要<code>zookeeper</code>、<code>etcd</code>、<code>consul</code>作为注册中心。</p>
<p>这个工具的开发参考了Go的tools的实现以及DigitalOcean公司的Fatih Arslan<br>开发的<a href="https://github.com/fatih/gomodifytags" target="_blank" rel="external">gomodifytags</a>的实现。</p>
<a id="more"></a>
<p>首先看一下这个工具参数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ xgen -h</div><div class="line">Usage of xgen:</div><div class="line">  -o string</div><div class="line">    	specify the filename of the output</div><div class="line">  -pkg</div><div class="line">    	process the whole package instead of just the given file</div><div class="line">  -r string</div><div class="line">    	registry type. support etcd, consul, zookeeper, mdns</div><div class="line">  -tags string</div><div class="line">    	build tags to add to generated file</div></pre></td></tr></table></figure>

<p>你可以使用 <code>xgen file1.go file2.go file3.go</code> 搜寻指定的文件生成服务，也可以 <code>xgen -pkg github.com/rpcx-ecosystem/rpcx-examples3/xgen</code> 为<code>GOPATH</code>中指定的<code>package</code>生成服务。 <code>-pkg</code>选项优先于程序参数。</p>
<p><code>-o</code> 选项指定生成的程序输出到哪个文件，如果不指定，则输出到控制台<code>Stdout</code>。</p>
<p><code>-r</code> 选项指定注册中心的类型，支持<code>zookeeper</code>、<code>etcd</code>、<code>consul</code> 和 <code>mdns</code>。如果不指定,则采用点对点的rpc调用方式。</p>
<p><code>-tags</code> 选项指定生成的文件是否要加上<code>build conditions</code>。</p>
<p>看一个例子， <a href="https://github.com/rpcx-ecosystem/rpcx-examples3/tree/master/xgen" target="_blank" rel="external">rpcx-examples3/xgen</a>中有一个server.go文件，它定义几个类型和方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> xgen</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"context"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	example <span class="string">"github.com/rpcx-ecosystem/rpcx-examples3"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Arith <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Mul(ctx context.Context, args example.Args, reply *example.Reply) error {</div><div class="line">	reply.C = args.A * args.B</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t *Arith) Add(ctx context.Context, args *example.Args, reply *example.Reply) error {</div><div class="line">	reply.C = args.A + args.B</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Echo <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *Echo) Echo(ctx context.Context, args <span class="typename">string</span>, reply *<span class="typename">string</span>) error {</div><div class="line">	*reply = fmt.Sprintf(<span class="string">"Hello %s from %s"</span>, args, *reply)</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> TimeS <span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (s *TimeS) Time(ctx context.Context, args time.Time, reply *time.Time) error {</div><div class="line">	*reply = time.Now()</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这三个类型<code>Arith</code>、<code>Echo</code>、<code>TimeS</code> 都有符合rpcx服务的方法。</p>
<blockquote>
<p>rpcx的服务的方法需要满足下面的规则:</p>
<ul>
<li>类型和参数都是exported</li>
<li>方法有三个参数，并且第一个参数是<code>context.Context</code></li>
<li>方法的第三个参数是指针类型</li>
<li>方法类型为error</li>
</ul>
</blockquote>
<p>现在你就可以使用<code>xgen</code>生成服务端代码。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xgen -o cmd/main.go -r <span class="string">"etcd"</span> -pkg github.com/rpcx-ecosystem/rpcx-examples3/xgen</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xgen -o cmd/main.go -r <span class="string">"etcd"</span> ./server.go</div></pre></td></tr></table></figure>

<p>这样就生成了一个服务器端的代码。</p>
<p>你可以运行你的服务器了: <code>go run -tags &quot;etcd&quot; cmd/main.go</code>,就这么简单。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/smallnest/rpcx" target="_blank" rel="external"><img src="https://img.shields.io/github/stars/smallnest/rpcx.svg?style=social&amp;logo=github&amp;label=Stars" alt="GitHub stars"></a></p>
<p><a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>一个服务治理的Go RPC框架， 拥有非常多的特性，支持跨语言的服务调用。 众多的特性可以参考<a href="https://doc.rpcx.site" target="_blank" rel="external">doc.rpcx.site</a>。它的服务治理的特性深受阿里巴巴的Dubbo框架的启发。</p>
<p>在实际的产品应用中，用户使用两台服务器+8台日志搜集服务(Client)，轻松处理每天几十亿的服务调用， 除了中间一个路由器硬件闪断， 整个系统平稳运行多半年。 相比较之前Java的实现， 服务器节省了一半。 用户使用rpcx框架重构后的系统每月为公司节省了几十万元的成本。</p>
<p>rpcx框架的一个设计哲学就是<strong>简单</strong>。不希望用户需要花费大量的时间在框架的学习上，并且不需要proto文件或者重复且冗余的服务配置。最少只需要10行代码就可以创建一个服务， 如果需要额外的配置，也只需要几十行的代码。</p>
<p>虽然rpcx开发简单，但是作为开发人员来说，如果可以更加的偷懒， 那更是极好的一件事情了，这就是<a href="https://github.com/smallnest/rpcx/tree/master/tool/xgen" target="_blank" rel="external">xgen</a>开发的目的。</p>
<p>这个工具可以搜寻指定的<code>package</code>下可以配置成rpcx服务的类型， 并且生成一个服务器程序，将这些服务注册到服务器程序中。你可以指定是否需要<code>zookeeper</code>、<code>etcd</code>、<code>consul</code>作为注册中心。</p>
<p>这个工具的开发参考了Go的tools的实现以及DigitalOcean公司的Fatih Arslan<br>开发的<a href="https://github.com/fatih/gomodifytags" target="_blank" rel="external">gomodifytags</a>的实现。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转][译]只用200行Go代码写一个自己的区块链]]></title>
    <link href="http://colobu.com/2018/02/05/code-your-own-blockchain-in-less-than-200-lines-of-go/"/>
    <id>http://colobu.com/2018/02/05/code-your-own-blockchain-in-less-than-200-lines-of-go/</id>
    <published>2018-02-05T05:23:12.000Z</published>
    <updated>2018-02-27T13:03:20.262Z</updated>
    <content type="html"><![CDATA[<p>这篇文章的原文为英文，出自 Coral Health公司: <a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc" target="_blank" rel="external">Code your own blockchain in less than 200 lines of Go!</a>，</p>
<p>本篇转载的译文来自魏佳翻译的: <a href="http://www.10tiao.com/html/175/201801/2653549361/1.html" target="_blank" rel="external">只用200行Go代码写一个自己的区块链！</a>,高可用架构的公众号， 开头部分我改为了原文的直接翻译。</p>
<a id="more"></a>
<p>这篇教程改编自<a href="https://medium.com/@lhartikk/a-blockchain-in-200-lines-of-code-963cc1cc0e54" target="_blank" rel="external">Javascript版本实现的区块链文章</a> (译文: <a href="https://mp.weixin.qq.com/s/Ghgaxt22Ob2p-Q7cuzKHNA" target="_blank" rel="external">200行代码就能写出区块链</a>)。我们使用Go语言实现了它，并且增加了一些额外的功能，比如可以在浏览器中查看区块链信息。如果对本教程有什么问题，欢迎加入 <a href="https://t.me/joinchat/FX6A7UThIZ1WOUNirDS_Ew" target="_blank" rel="external">Telegram chat</a>讨论。</p>
<p>因为我们是一家从事医疗健康领域的科技公司，所以我们采用人类平静时的心跳数据（BPM心率）作为这篇文章中的示例数据。让我们先来统计一下你一分钟内的心跳数，然后记下来，这个数字可能会在接下来的内容中用到。</p>
<p>几乎每个开发者都听说过区块链但是大部分人还是不清楚它是如何工作的。他们可能只是因为比特币才知道区块链，或许还知道一些智能合约的东东。这篇文章尝试帮助你使用Go编写你自己的简单的区块链。通过本教程，你可以编写和运行一个本地的区块链，并且可以在浏览器中查看它。</p>
<p>通过本文，你将可以做到：</p>
<ul>
<li>创建自己的区块链</li>
<li>理解 hash 函数是如何保持区块链的完整性</li>
<li>如何创造并添加新的块</li>
<li>多个节点如何竞争生成块</li>
<li>通过浏览器来查看整个链</li>
<li>所有其他关于区块链的基础知识</li>
</ul>
<p>但是，对于比如<strong>工作量证明算法（PoW）</strong> 以及 <strong>权益证明算法（PoS）</strong>这类的共识算法文章中将不会涉及。同时为了让你更清楚的查看区块链以及块的添加，我们将网络交互的过程简化了，关于 P2P 网络比如“全网广播”这个过程等内容将在下一篇文章中补上。</p>
<h2 id="让我们开始吧！">让我们开始吧！</h2>
<h3 id="设置">设置</h3>
<p>我们假设你已经具备一点 Go 语言的开发经验。在安装和配置 Go 开发环境后之后，我们还要获取以下一些依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/davecgh/go-spew/spew</div></pre></td></tr></table></figure>

<p><code>spew</code> 可以帮助我们在 <code>console</code> 中直接查看 <code>struct</code> 和 <code>slice</code> 这两种数据结构。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/gorilla/mux</div></pre></td></tr></table></figure>

<p><code>Gorilla</code> 的 mux 包非常流行， 我们用它来写 web handler。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/joho/godotenv</div></pre></td></tr></table></figure>

<p>godotenv 可以帮助我们读取项目根目录中的 <code>.env</code> 配置文件，这样我们就不用将 http port 之类的配置硬编码进代码中了。比如像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ADDR</span>=<span class="string">8080</span></div></pre></td></tr></table></figure>

<p>接下来，我们创建一个 <code>main.go</code> 文件。之后我们的大部分工作都围绕这个文件，让我开始编码吧！</p>
<h3 id="导入依赖">导入依赖</h3>
<p>我们将所有的依赖包以声明的方式导入进去：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"crypto/sha256"</span></div><div class="line">    <span class="string">"encoding/hex"</span></div><div class="line">    <span class="string">"encoding/json"</span></div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"log"</span></div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/davecgh/go-spew/spew"</span></div><div class="line">    <span class="string">"github.com/gorilla/mux"</span></div><div class="line">    <span class="string">"github.com/joho/godotenv"</span></div><div class="line">)</div></pre></td></tr></table></figure>

<h3 id="数据模型">数据模型</h3>
<p>接着我们来定义一个结构体，它代表组成区块链的每一个块的数据模型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> {</div><div class="line">    Index     <span class="typename">int</span></div><div class="line">    Timestamp <span class="typename">string</span></div><div class="line">    BPM       <span class="typename">int</span></div><div class="line">    Hash      <span class="typename">string</span></div><div class="line">    PrevHash  <span class="typename">string</span></div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><code>Index</code> 是这个块在整个链中的位置</li>
<li><code>Timestamp</code> 显而易见就是块生成时的时间戳</li>
<li><code>Hash</code> 是这个块通过 SHA256 算法生成的散列值</li>
<li><code>PrevHash</code> 代表前一个块的 SHA256 散列值</li>
<li><code>BPM</code> 每分钟心跳数，也就是心率。还记得文章开头说到的吗？</li>
</ul>
<p>接着，我们再定义一个结构表示整个链，最简单的表示形式就是一个 <code>Block</code> 的 slice：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Blockchain []Block</div></pre></td></tr></table></figure>

<p>我们使用散列算法（SHA256）来确定和维护链中块和块正确的顺序，确保每一个块的 PrevHash 值等于前一个块中的 Hash 值，这样就以正确的块顺序构建出链：</p>
<p><img src="1.png" alt=""></p>
<h3 id="散列和生成块">散列和生成块</h3>
<p>我们为什么需要散列？主要是两个原因：</p>
<ul>
<li>在节省空间的前提下去唯一标识数据。散列是用整个块的数据计算得出，在我们的例子中，将整个块的数据通过 <code>SHA256</code> 计算成一个定长不可伪造的字符串。</li>
<li>维持链的完整性。通过存储前一个块的散列值，我们就能够确保每个块在链中的正确顺序。任何对数据的篡改都将改变散列值，同时也就破坏了链。以我们从事的医疗健康领域为例，比如有一个恶意的第三方为了调整“人寿险”的价格，而修改了一个或若干个块中的代表不健康的 BPM 值，那么整个链都变得不可信了。</li>
</ul>
<p>我们接着写一个函数，用来计算给定的数据的 SHA256 散列值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> calculateHash(block Block) <span class="typename">string</span> {</div><div class="line">    record := <span class="typename">string</span>(block.Index) + block.Timestamp + <span class="typename">string</span>(block.BPM) + block.PrevHash</div><div class="line">    h := sha256.New()</div><div class="line">    h.Write([]<span class="typename">byte</span>(record))</div><div class="line">    hashed := h.Sum(<span class="constant">nil</span>)</div><div class="line">    <span class="keyword">return</span> hex.EncodeToString(hashed)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个 <code>calculateHash</code> 函数接受一个块，通过块中的 Index，Timestamp，BPM，以及 PrevHash 值来计算出 SHA256 散列值。接下来我们就能便携一个生成块的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> generateBlock(oldBlock Block, BPM <span class="typename">int</span>) (Block, error) {</div><div class="line">    <span class="keyword">var</span> newBlock Block</div><div class="line"></div><div class="line">    t := time.Now()</div><div class="line">    newBlock.Index = oldBlock.Index +<span class="number"> 1</span></div><div class="line">    newBlock.Timestamp = t.String()</div><div class="line">    newBlock.BPM = BPM</div><div class="line">    newBlock.PrevHash = oldBlock.Hash</div><div class="line">    newBlock.Hash = calculateHash(newBlock)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newBlock, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中，<code>Index</code> 是从给定的前一块的 <code>Index</code> 递增得出，时间戳是直接通过 <code>time.Now()</code> 函数来获得的，<code>Hash</code> 值通过前面的 <code>calculateHash</code> 函数计算得出，<code>PrevHash</code> 则是给定的前一个块的 <code>Hash</code> 值。</p>
<h3 id="校验块">校验块</h3>
<p>搞定了块的生成，接下来我们需要有函数帮我们判断一个块是否有被篡改。检查 Index 来看这个块是否正确得递增，检查 PrevHash 与前一个块的 Hash 是否一致，再来通过 calculateHash 检查当前块的 Hash 值是否正确。通过这几步我们就能写出一个校验函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> isBlockValid(newBlock, oldBlock Block) <span class="typename">bool</span> {</div><div class="line">    <span class="keyword">if</span> oldBlock.Index<span class="number">+1</span> != newBlock.Index {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> oldBlock.Hash != newBlock.PrevHash {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> calculateHash(newBlock) != newBlock.Hash {</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了校验块以外，我们还会遇到一个问题：两个节点都生成块并添加到各自的链上，那我们应该以谁为准？这里的细节我们留到下一篇文章，这里先让我们记住一个原则：始终选择最长的链。</p>
<p><img src="2.png" alt=""></p>
<p>通常来说，更长的链表示它的数据（状态）是更新的，所以我们需要一个函数</p>
<p>能帮我们将本地的过期的链切换成最新的链：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func replaceChain(newBlocks []Block) {</div><div class="line">    <span class="keyword">if</span> len(newBlocks) &gt; len(Blockchain) {</div><div class="line">        Blockchain = newBlocks</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>到这一步，我们基本就把所有重要的函数完成了。接下来，我们需要一个方便直观的方式来查看我们的链，包括数据及状态。通过浏览器查看 web 页面可能是最合适的方式！</p>
<h3 id="Web_服务">Web 服务</h3>
<p>我猜你一定对传统的 web 服务及开发非常熟悉，所以这部分你肯定一看就会。<br>借助 Gorilla/mux 包，我们先写一个函数来初始化我们的 web 服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> run() error {</div><div class="line">    mux := makeMuxRouter()</div><div class="line">    httpAddr := os.Getenv(<span class="string">"ADDR"</span>)</div><div class="line">    log.Println(<span class="string">"Listening on "</span>, os.Getenv(<span class="string">"ADDR"</span>))</div><div class="line">    s := &http.Server{</div><div class="line">        Addr:           <span class="string">":"</span> + httpAddr,</div><div class="line">        Handler:        mux,</div><div class="line">        ReadTimeout:   <span class="number"> 10</span> * time.Second,</div><div class="line">        WriteTimeout:  <span class="number"> 10</span> * time.Second,</div><div class="line">        MaxHeaderBytes:<span class="number"> 1</span> &lt;&lt;<span class="number"> 20</span>,</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> err := s.ListenAndServe(); err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中的端口号是通过前面提到的 .env 来获得，再添加一些基本的配置参数，这个 web 服务就已经可以 listen and serve 了！<br>接下来我们再来定义不同 endpoint 以及对应的 handler。例如，对“/”的 GET 请求我们可以查看整个链，“/”的 POST 请求可以创建块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> makeMuxRouter() http.Handler {</div><div class="line">    muxRouter := mux.NewRouter()</div><div class="line">    muxRouter.HandleFunc(<span class="string">"/"</span>, handleGetBlockchain).Methods(<span class="string">"GET"</span>)</div><div class="line">    muxRouter.HandleFunc(<span class="string">"/"</span>, handleWriteBlock).Methods(<span class="string">"POST"</span>)</div><div class="line">    <span class="keyword">return</span> muxRouter</div><div class="line">}</div></pre></td></tr></table></figure>

<p>GET 请求的 handler：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> handleGetBlockchain(w http.ResponseWriter, r *http.Request) {</div><div class="line">    bytes, err := json.MarshalIndent(Blockchain, <span class="string">""</span>, <span class="string">"  "</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    io.WriteString(w, <span class="typename">string</span>(bytes))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为了简化，我们直接以 JSON 格式返回整个链，你可以在浏览器中访问 localhost:8080 或者 127.0.0.1:8080 来查看（这里的8080就是你在 .env 中定义的端口号 ADDR）。</p>
<p>POST 请求的 handler 稍微有些复杂，我们先来定义一下 POST 请求的 payload：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> {</div><div class="line">    BPM <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>再看看 handler 的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> handleWriteBlock(w http.ResponseWriter, r *http.Request) {</div><div class="line">    <span class="keyword">var</span> m Message</div><div class="line"></div><div class="line">    decoder := json.NewDecoder(r.Body)</div><div class="line">    <span class="keyword">if</span> err := decoder.Decode(&m); err != <span class="constant">nil</span> {</div><div class="line">        respondWithJSON(w, r, http.StatusBadRequest, r.Body)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    <span class="keyword">defer</span> r.Body.Close()</div><div class="line"></div><div class="line">    newBlock, err := generateBlock(Blockchain[<span class="built_in">len</span>(Blockchain<span class="number">)-1</span>], m.BPM)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        respondWithJSON(w, r, http.StatusInternalServerError, m)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> isBlockValid(newBlock, Blockchain[<span class="built_in">len</span>(Blockchain<span class="number">)-1</span>]) {</div><div class="line">        newBlockchain := <span class="built_in">append</span>(Blockchain, newBlock)</div><div class="line">        replaceChain(newBlockchain)</div><div class="line">        spew.Dump(Blockchain)</div><div class="line">    }</div><div class="line"></div><div class="line">    respondWithJSON(w, r, http.StatusCreated, newBlock)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们的 POST 请求体中可以使用上面定义的 payload，比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">{"<span class="attribute">BPM</span>":<span class="value"><span class="number">75</span></span>}</div></pre></td></tr></table></figure>

<p>还记得前面我们写的 generateBlock 这个函数吗？它接受一个“前一个块”参数，和一个 BPM 值。POST handler 接受请求后就能获得请求体中的 BPM 值，接着借助生成块的函数以及校验块的函数就能生成一个新的块了！</p>
<p>除此之外，你也可以：</p>
<p>使用spew.Dump 这个函数可以以非常美观和方便阅读的方式将 struct、slice 等数据打印在控制台里，方便我们调试。</p>
<p>测试 POST 请求时，可以使用 POSTMAN 这个 chrome 插件，相比 curl它更直观和方便。</p>
<p>POST 请求处理完之后，无论创建块成功与否，我们需要返回客户端一个响应：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> respondWithJSON(w http.ResponseWriter, r *http.Request, code <span class="typename">int</span>, payload <span class="keyword">interface</span>{}) {</div><div class="line">    response, err := json.MarshalIndent(payload, <span class="string">""</span>, <span class="string">"  "</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        w.WriteHeader(http.StatusInternalServerError)</div><div class="line">        w.Write([]<span class="typename">byte</span>(<span class="string">"HTTP 500: Internal Server Error"</span>))</div><div class="line">        <span class="keyword">return</span></div><div class="line">    }</div><div class="line">    w.WriteHeader(code)</div><div class="line">    w.Write(response)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="快要大功告成了">快要大功告成了</h3>
<p>接下来，我们把这些关于区块链的函数，web 服务的函数“组装”起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    err := godotenv.Load()</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatal(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        t := time.Now()</div><div class="line">        genesisBlock := Block<span class="number">{0</span>, t.String(),<span class="number"> 0</span>, <span class="string">""</span>, <span class="string">""</span>}</div><div class="line">        spew.Dump(genesisBlock)</div><div class="line">        Blockchain = <span class="built_in">append</span>(Blockchain, genesisBlock)</div><div class="line">    }()</div><div class="line">    log.Fatal(run())</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的 <code>genesisBlock （创世块）</code>是 <code>main</code> 函数中最重要的部分，通过它来初始化区块链，毕竟第一个块的 <code>PrevHash</code> 是空的。</p>
<h2 id="哦耶！完成了">哦耶！完成了</h2>
<p>你们可以从这里获得完整的代码：<a href="https://github.com/mycoralhealth/blockchain-tutorial" target="_blank" rel="external">Github repo</a>。<br>让我们来启动它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go run main.go</div></pre></td></tr></table></figure>

<p>在终端中，我们可以看到 web 服务器启动的日志信息，并且打印出了创世块的信息：<br><img src="3.png" alt=""></p>
<p>接着我们打开浏览器，访问 localhost:8080 这个地址，我们可以看到页面中展示了当前整个区块链的信息（当然，目前只有一个创世块）：<br><img src="4.png" alt=""></p>
<p>接着，我们再通过 POSTMAN 来发送一些 POST 请求：<br><img src="5.png" alt=""></p>
<p>刷新刚才的页面，现在的链中多了一些块，正是我们刚才生成的，同时你们可以看到，块的顺序和散列值都正确。<br><img src="6.png" alt=""></p>
<h3 id="下一步">下一步</h3>
<p>刚刚我们完成了一个自己的区块链，虽然很简单（陋），但它具备块生成、散列计算、块校验等基本能力。接下来你就可以继续深入的学习区块链的其他重要知识，比如工作量证明、权益证明这样的共识算法，或者是智能合约、Dapp、侧链等等。</p>
<p>目前这个实现中不包括任何 P2P 网络的内容，我们会在下一篇文章中补充这部分内容，当然，我们鼓励你在这个基础上自己实践一遍！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章的原文为英文，出自 Coral Health公司: <a href="https://medium.com/@mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc" target="_blank" rel="external">Code your own blockchain in less than 200 lines of Go!</a>，</p>
<p>本篇转载的译文来自魏佳翻译的: <a href="http://www.10tiao.com/html/175/201801/2653549361/1.html" target="_blank" rel="external">只用200行Go代码写一个自己的区块链！</a>,高可用架构的公众号， 开头部分我改为了原文的直接翻译。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[流行的rpc框架benchmark 2018新春版]]></title>
    <link href="http://colobu.com/2018/01/31/benchmark-2018-spring-of-popular-rpc-frameworks/"/>
    <id>http://colobu.com/2018/01/31/benchmark-2018-spring-of-popular-rpc-frameworks/</id>
    <published>2018-01-31T07:00:38.000Z</published>
    <updated>2018-02-27T13:03:20.262Z</updated>
    <content type="html"><![CDATA[<p>随着公司规模的扩大，以及业务量的激增，单体应用逐步演化为服务/微服务的架构模式， 服务之间的调用大多采用rpc的方式调用，或者消息队列的方式进行解耦。几乎每个大厂都会创建自己的rpc框架，或者基于知名的rpc框架进行改造。</p>
<p>目前, rpc框架主要沿着两条路线发展，一个是目标为了跨语言，服务端可以用不同的语言实现，客户端也可以用不同的语言实现，不同的语言实现的客户端和服务器端可以互相调用。很显然，要支持不同的语言，需要基于那种语言实现相同协议的框架，并且协议设计应该也是跨语言的，其中比较典型的是 grpc,基于同一个IDL，可以生成不同语言的代码，并且语言的支持也非常的多。</p>
<p>另一个rpc框架发展的目标是支持服务治理，主要的精力放在服务发现、路由、容错处理等方面，主要围绕一个语言开发，可能也有一些第三方曲折的实现服务的调用和服务的实现，这其中的代表，也是比较早的开源的框架就是阿里巴巴的dubbo。</p>
<p>有些rpc框架协议的涉及一开始就没有考虑的跨语言，其中使用了语言的一些特有的属性，比如Java的ObjectInputStream/ObjectOutputStream, Golang的Gob等，有些在协议的设计上就考虑了通用性， 使用JSON或者Protobuffer作为数据序列化。</p>
<p>有些框架是基于TCP的二进制流的数据传输，有些基于http的request/response模型进行请求，也有基于http2的流式传输，更有一些支持可信赖的UDP进行数据传入，比如quic、kcp等。</p>
<p>有些提供了生态圈的一些框架，比如gateway、agent等，有些restful风格的rpc框架天然支持API gateway进行负载均衡。</p>
<p>有些已经得到了大厂的广泛应用，有的大厂内部得到了大量应用，但目前还没有广泛的推开来。</p>
<p>选择一个rpc框架会基于多方面的考虑： 框架特性、性能、成熟度、技术支持、社区活跃度等多个方面，本文只比较各个流行框架的benchmark，基于几个固定的场景提供benchmark数据支持。</p>
<a id="more"></a>
<p>本文所使用的benchmark代码位于: <a href="https://github.com/rpcx-ecosystem/rpcx-benchmark" target="_blank" rel="external">rpcx-benchmark</a>, 这是我在开发<a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>框架的时候为了检验框架性能而抽取出来的一个项目，也欢迎各框架的作者和爱好者提供相应的框架benchmark代码，或者修正其中的错误。</p>
<h2 id="本文测试的RPC框架">本文测试的RPC框架</h2>
<ul>
<li><a href="https://github.com/smallnest/rpcx" target="_blank" rel="external">rpcx</a>: 基于Go的服务治理的rpc框架、客户端支持跨语言</li>
<li><a href="https://grpc.io" target="_blank" rel="external">grpc</a>: Google 出品的跨语言rpc框架，很弱的(实验性的)负载均衡, 测试使用的是grpc-go</li>
<li><a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="external">go std rpc</a>: Go标准库的rpc, 不支持跨语言(jsonrpc支持json rpc 1.0)</li>
<li><a href="https://thrift.apache.org" target="_blank" rel="external">thrift</a>: 跨语言的rpc框架，facebook贡献</li>
<li><a href="https://thrift.apache.org" target="_blank" rel="external">dubbo</a>: 国内较早开源的服务治理的Java rpc框架，虽然在阿里巴巴内部竞争中落败于HSF，沉寂了几年，但是在国内得到了广泛的应用，目前dubbo项目又获得了支持，并且dubbo 3.0也开始开发</li>
<li><a href="https://thrift.apache.org" target="_blank" rel="external">motan</a>: 微博内部使用的rpc框架，底层支持java,生态圈往service mesh发展以支持多语言</li>
<li><a href="https://github.com/hprose" target="_blank" rel="external">hprose</a>: 国内开发人员开发的一个跨语言的rpc框架，非服务治理但是性能高效</li>
<li><a href="https://github.com/twitchtv/twirp" target="_blank" rel="external">twirp</a>: twitch.tv刚刚开源的一个restful风格的rpc框架</li>
<li><a href="https://github.com/micro/go-micro" target="_blank" rel="external">go-micro</a>: Go语言的一个服务治理rpc框架， 在测试中发现性能不太好，所以没有继续测试，相关的测试代码已在github库中</li>
<li><a href="https://github.com/go-kit/kit" target="_blank" rel="external">go kit</a>: 欢迎提供测试代码</li>
<li><a href="https://github.com/Tencent/Tars" target="_blank" rel="external">腾讯 Tars</a>:腾讯公司的rpc框架， 欢迎提供c++ benchmark代码</li>
<li><a href="https://github.com/brpc/brpc" target="_blank" rel="external">百度 brpc</a>: 百度公司的rpc框架， 欢迎提供c++ benchmark代码</li>
<li><a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="external">spring cloud</a>: 本次没有测试</li>
</ul>
<h2 id="测试场景">测试场景</h2>
<h3 id="模拟业务处理时间">模拟业务处理时间</h3>
<p>测试模拟了三种业务处理的场景(模拟业务处理时间):</p>
<ul>
<li>0ms:   业务很简单，可以快速返回。业务处理主要是将反序列化的对象设置几个字段后返回</li>
<li>10ms:  模拟一般的业务处理，这些业务处理主要是本地操作，比如读取本地的数据库等，处理时间相对较短</li>
<li>30ms:  模拟复杂的业务处理， 这些服务可能需要访问第三方服务，或者远程的数据等，处理时间相对较长</li>
</ul>
<p>当处理时间为0ms时，我们主要测试的整个框架空转的处理能力，涉及的数据的传输，数据的序列化、服务的调度等等。<br>当处理时间为10ms、30ms时，这个时间业务处理时间一般要远远大于数据传输和序列化所需的时间，主要比较在大并发的性能框架的调度、处理能力。</p>
<h3 id="测试数据">测试数据</h3>
<p>所有的测试都是基于相同的数据, 为了公平起见，统一采用protobuffer进行序列化和反序列化。</p>
<p>数据格式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">BenchmarkMessage</span> </span>{</div><div class="line">  <span class="keyword">required</span> <span class="built_in">string</span> field1 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> field9 = <span class="number">9</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> field18 = <span class="number">18</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field80 = <span class="number">80</span> [default=<span class="literal">false</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field81 = <span class="number">81</span> [default=<span class="literal">true</span>];</div><div class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> field2 = <span class="number">2</span>;</div><div class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> field3 = <span class="number">3</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field280 = <span class="number">280</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field6 = <span class="number">6</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int64</span> field22 = <span class="number">22</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> field4 = <span class="number">4</span>;</div><div class="line">  <span class="keyword">repeated</span> <span class="built_in">fixed64</span> field5 = <span class="number">5</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field59 = <span class="number">59</span> [default=<span class="literal">false</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> field7 = <span class="number">7</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field16 = <span class="number">16</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field130 = <span class="number">130</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field12 = <span class="number">12</span> [default=<span class="literal">true</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field17 = <span class="number">17</span> [default=<span class="literal">true</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field13 = <span class="number">13</span> [default=<span class="literal">true</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field14 = <span class="number">14</span> [default=<span class="literal">true</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field104 = <span class="number">104</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field100 = <span class="number">100</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field101 = <span class="number">101</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> field102 = <span class="number">102</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> field103 = <span class="number">103</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field29 = <span class="number">29</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field30 = <span class="number">30</span> [default=<span class="literal">false</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field60 = <span class="number">60</span> [default=-<span class="number">1</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field271 = <span class="number">271</span> [default=-<span class="number">1</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field272 = <span class="number">272</span> [default=-<span class="number">1</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field150 = <span class="number">150</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field23 = <span class="number">23</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field24 = <span class="number">24</span> [default=<span class="literal">false</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field25 = <span class="number">25</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">bool</span> field78 = <span class="number">78</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field67 = <span class="number">67</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field68 = <span class="number">68</span>;</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field128 = <span class="number">128</span> [default=<span class="number">0</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> field129 = <span class="number">129</span> [default=<span class="string">"xxxxxxxxxxxxxxxxxxxxx"</span>];</div><div class="line">  <span class="keyword">optional</span> <span class="built_in">int32</span> field131 = <span class="number">131</span> [default=<span class="number">0</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>测试的时候会初始化这个数据，序列化后的数据大小为 581 字节。</p>
<h3 id="测试client">测试client</h3>
<p>测试 client类似apache bench工具， 主要通过<code>-c</code>和<code>-n</code>来控制并发数和测试请求量。</p>
<p><code>-c</code> 指定并发的client,每个client都是独立的，在各自的goroutine或者Thread中运行。 Client采用同步的方式调用服务,也就是前一个服务调用完成后才发出下一个服务调用，因此并发量主要靠client的数量来确定。(当然有些rpc框架，比如rpcx/go std rpc支持异步调用，性能会更高，但是统一起见我们对所有的client都采用了同步调用的方式)</p>
<p><code>-n</code> 只发送服务的总的请求数，由client平分。</p>
<p>client在所有调用完成后统一计算吞吐率和延迟。</p>
<h3 id="测试指标">测试指标</h3>
<ul>
<li>吞吐率: 每秒完成的请求量</li>
<li>平均延迟: 服务发出到收到response所需的时间</li>
<li>P99延迟：99%的调用的延迟时间</li>
</ul>
<h3 id="测试环境">测试环境</h3>
<p>server和client在同一台服务器上，使用loopback网络。</p>
<p>cpu cores为 32, Intel Xeon E5-2630 V3 @2.4GHz</p>
<h2 id="测试结果">测试结果</h2>
<h3 id="处理时间_0ms">处理时间 0ms</h3>
<table><tr><th>吞吐率</th><th>平均延迟</th><th>P99 延迟</th></tr><tr><td width="30%"><img src="p0-throughput.png" alt=""></td><td width="30%"><img src="p0-latency.png" alt=""></td><td width="30%"><img src="p0-p99.png" alt=""></td></tr></table>


<p>平均延迟 rpcx和hprose重合。</p>
<p><strong>解读</strong>: 简单而高效的Go标准库的rpc性能优异，因为没有额外的服务治理和插件、过滤器的设置，它本身采用一个简单的<code>header</code> + <code>payload</code>的协议，运行高效。</p>
<p>rpcx表现不错，排名第二，并发量变化时吞吐率基本保持不变。</p>
<p>hprose在并发量低的情况下排名第三，但是在并发量大的情况下和rpcx持平。</p>
<p>其次是Google的grpc，吞吐率基本为Go标准rpc的一半。grpc经过去年下半年的性能优化，已经提升了不少的性能。</p>
<p>再其次是thrift,吞吐率在7万左右。</p>
<p>最后几个基本是dubbo、motan和twirp。</p>
<p>基本上，基于Go的rpc框架吞吐率还是很强大的, 除了twirp。</p>
<p>这里有一个奇怪的现象，在0ms这种case下， Go实现的框架P99延迟很大，但是在10ms/30ms下去很小。我在测试web框架的时候一位外国程序员也指出了一个问题，在业务逻辑中加上了runtime.Gosched()解决了这个问题。我想rpc测试也是这个问题，因为服务实现中没有机会让调度器抢走这个goroutine的执行，导致goroutine排队，并不能均匀地执行goroutine，我会在将来的时候验证这个猜想。</p>
<h3 id="处理时间_10ms">处理时间 10ms</h3>
<p>当处理时间为10ms时， 本测试的理论上的吞吐率 = clients <em> (1000ms/10ms) = clients \</em> 100. 实际由于服务的调度等原因，肯定是达不到这个吞吐率。</p>
<table><tr><th>吞吐率</th><th>平均延迟</th><th>P99 延迟</th></tr><tr><td width="30%"><img src="p10-throughput.png" alt=""></td><td width="30%"><img src="p10-latency.png" alt=""></td><td width="30%"><img src="p10-p99.png" alt=""></td></tr></table>


<p>当业务处理时间为10毫秒的时候，服务器需要花一部分时间在线程/goroutine调度上，对于Go来说，它基于goroutine实现并发，对于Java，它基于线程池。</p>
<p>排名前4位的框架基本未变，go stdrpc、rpcx、hprose从趋势上看，随着并发数的增大，还有提升的空间，但是对于grpc,它基本处于一个平缓的趋势了。</p>
<p>其它几种Java框架已经呈现下降的趋势。</p>
<p>当然，在并发数很小的时候，吞吐率差别还不是很明显，基本请求都在10+ms的时候返回，都接近理论数字。</p>
<p>吞吐率高的rpc框架的延迟反而很低， 这也正说明了吞吐率高的原因。在并发数很大的时候，延迟已经远远大于业务处理时间了。</p>
<h3 id="处理时间_30ms">处理时间 30ms</h3>
<p>当处理时间为30ms时， 本测试的理论上的吞吐率 = clients <em> (1000ms/30ms) = clients \</em> 33. 实际由于服务的调度等原因，肯定是达不到这个吞吐率。</p>
<table><tr><th>吞吐率</th><th>平均延迟</th><th>P99 延迟</th></tr><tr><td width="30%"><img src="p30-throughput.png" alt=""></td><td width="30%"><img src="p30-latency.png" alt=""></td><td width="30%"><img src="p30-p99.png" alt=""></td></tr></table>


<p>业务处理时间为30ms的时候，排名前4位的还是go stdrpc、rpcx、hprose和grpc。</p>
<p>排名第五的是twirp，它也是用Go开发的。第6位是dubbo，在2000并发的情况下性能还好。</p>
<blockquote>
<p>在这个月全食的凌晨终于完成了测试，也欢迎大家提供bench代码和讨论。</p>
</blockquote>
<p><strong>Updated</strong>: 正好看到另外一位同学做的java的rpc/restful框架的<a href="https://mp.weixin.qq.com/s/TTcQJM9s5OhyY7dmpJlcfQ" target="_blank" rel="external">benchmark</a>, 可以和本文的对照。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>随着公司规模的扩大，以及业务量的激增，单体应用逐步演化为服务/微服务的架构模式， 服务之间的调用大多采用rpc的方式调用，或者消息队列的方式进行解耦。几乎每个大厂都会创建自己的rpc框架，或者基于知名的rpc框架进行改造。</p>
<p>目前, rpc框架主要沿着两条路线发展，一个是目标为了跨语言，服务端可以用不同的语言实现，客户端也可以用不同的语言实现，不同的语言实现的客户端和服务器端可以互相调用。很显然，要支持不同的语言，需要基于那种语言实现相同协议的框架，并且协议设计应该也是跨语言的，其中比较典型的是 grpc,基于同一个IDL，可以生成不同语言的代码，并且语言的支持也非常的多。</p>
<p>另一个rpc框架发展的目标是支持服务治理，主要的精力放在服务发现、路由、容错处理等方面，主要围绕一个语言开发，可能也有一些第三方曲折的实现服务的调用和服务的实现，这其中的代表，也是比较早的开源的框架就是阿里巴巴的dubbo。</p>
<p>有些rpc框架协议的涉及一开始就没有考虑的跨语言，其中使用了语言的一些特有的属性，比如Java的ObjectInputStream/ObjectOutputStream, Golang的Gob等，有些在协议的设计上就考虑了通用性， 使用JSON或者Protobuffer作为数据序列化。</p>
<p>有些框架是基于TCP的二进制流的数据传输，有些基于http的request/response模型进行请求，也有基于http2的流式传输，更有一些支持可信赖的UDP进行数据传入，比如quic、kcp等。</p>
<p>有些提供了生态圈的一些框架，比如gateway、agent等，有些restful风格的rpc框架天然支持API gateway进行负载均衡。</p>
<p>有些已经得到了大厂的广泛应用，有的大厂内部得到了大量应用，但目前还没有广泛的推开来。</p>
<p>选择一个rpc框架会基于多方面的考虑： 框架特性、性能、成熟度、技术支持、社区活跃度等多个方面，本文只比较各个流行框架的benchmark，基于几个固定的场景提供benchmark数据支持。</p>
]]>
    
    </summary>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用二进制形式发布go package]]></title>
    <link href="http://colobu.com/2018/01/10/use-binary-package-in-go/"/>
    <id>http://colobu.com/2018/01/10/use-binary-package-in-go/</id>
    <published>2018-01-10T08:25:08.000Z</published>
    <updated>2018-01-20T06:23:31.299Z</updated>
    <content type="html"><![CDATA[<p>我们在使用Go进行开发的时候， 经常会使用到第三方的库， 这时候我们一般都会通过<code>go get</code>到github.com、bitbucket或者自己私有库中去拉取第三库的源代码。 今天正好群里有网友问能不能将自己开发的库以二进制形式提供给用户，我就顺便整理了一下。</p>
<p>以二进制方式提供库的动机可能是为了保护自己公司的知识产权，也有可能是从安全的角度考虑，避免一些关键信息的泄漏等等，这不是本文讨论的范围。</p>
<a id="more"></a>
<p>虽然以前的版本能够曲折的实现使用二进制的库，但是正式提供的方案是在Go 1.7中。 在 <a href="https://golang.org/doc/go1.7" target="_blank" rel="external">Go 1.7 Release Notes</a>提到：</p>
<blockquote>
<p>This release adds experimental, minimal support for building programs using binary-only packages, packages distributed in binary form without the corresponding source code. This feature is needed in some commercial settings but is not intended to be fully integrated into the rest of the toolchain. For example, tools that assume access to complete source code will not work with such packages, and there are no plans to support such packages in the “go get” command.</p>
<p>在 <a href="https://golang.org/pkg/go/build/#hdr-Binary_Only_Packages" target="_blank" rel="external">Package build</a>文档中也有相关的介绍：</p>
<p>It is possible to distribute packages in binary form without including the source code used for compiling the package. To do this, the package must be distributed with a source file not excluded by build constraints and containing a &quot;//go:binary-only-package&quot; comment. Like a build constraint, this comment must appear near the top of the file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.</p>
<p>The minimal source code for a binary-only package is therefore:</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">//go:binary-only-package</span></div><div class="line">&gt; </div><div class="line">&gt; <span class="keyword">package</span> mypkg</div><div class="line">&gt;</div></pre></td></tr></table></figure>

<blockquote>
<p>The source code may include additional Go code. That code is never compiled but will be processed by tools like godoc and might be useful as end-user documentation.</p>
</blockquote>
<p>你只需要提供一个编译好的库， 同时提供为这个package提供一个源文件。这个源文件不用包含任何代码逻辑，只需增加<code>//go:binary-only-package</code>指令即可(注意<code>//</code>和<code>go:...</code>之间不要加空格)。 这样用户在使用的时候，就可以直接使用你这个二进制的库了。</p>
<p>当然，为了用户方便，比如一些工具和IDE的支持，你可以将<code>exported</code>的类型定义到这个文件中。并且， 只需提供一些&quot;虚假&quot;的实现即可，只是为了IDE工具知道这个package包含的<code>exported</code>类型而已。</p>
<p>这个特性的实现是由Russ Cox在这两个提交中实现的： <a href="https://go-review.googlesource.com/c/go/+/22432" target="_blank" rel="external">CL#22432</a>、<a href="https://go-review.googlesource.com/c/go/+/22433" target="_blank" rel="external">CL#22433</a>, 他还提交了一个设计文档：<a href="https://github.com/golang/proposal/blob/master/design/2775-binary-only-packages.md" target="_blank" rel="external">Proposal: Binary-Only Package</a>。</p>
<p>相关的讨论在: <a href="https://github.com/golang/go/issues/12186" target="_blank" rel="external">#12186</a>、<a href="https://github.com/golang/go/issues/2775" target="_blank" rel="external">#2775</a>。</p>
<p>下面我们以一个实例看看如何使用的。</p>
<p>下面是我们实现业务逻辑的一个package，提供了一些常量、变量、函数和struct类型，把它编译成<code>x.a</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> x</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> PI =<span class="number"> 3.14</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	X =<span class="number"> 100</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> init() {</div><div class="line">	fmt.Println(<span class="string">"x init"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Add(x, y <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> x + y</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	X, Y <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是我们公司的核心资产，靠这个库卖钱呢，所以我们不想把这个源代码公开出去。那么我们可以提供给用户编译好的<code>x.a</code>，并且提供一个<code>dummy</code>的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:binary-only-package</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> x</div><div class="line"></div><div class="line"><span class="keyword">const</span> PI =<span class="number"> 0.0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	X =<span class="number"> 0</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> Add(x, y <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span><span class="number"> 0</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	X, Y <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>用户拿到这个<code>x.a</code>后放在<code>$GOPATH/pkg</code>相应的package下，同时将这个go文件放在<code>$GOPATH/src</code>，这样用户就可以正常使用这个库了。</p>
<p>当然，你最好将你的库打包成一个zip,这样用户unzip一下就可以方便的copy到<code>$GOPATH</code>中。</p>
<p>用<code>golang binary-only packages</code>也能搜到一些相关的<a href="https://medium.com/@shijuvar/using-binary-only-packages-in-go-667bd7b123c8" target="_blank" rel="external">教程</a>，有人还写了一个样板例子：<a href="https://github.com/tcnksm/go-binary-only-package" target="_blank" rel="external">tcnksm/go-binary-only-package</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们在使用Go进行开发的时候， 经常会使用到第三方的库， 这时候我们一般都会通过<code>go get</code>到github.com、bitbucket或者自己私有库中去拉取第三库的源代码。 今天正好群里有网友问能不能将自己开发的库以二进制形式提供给用户，我就顺便整理了一下。</p>
<p>以二进制方式提供库的动机可能是为了保护自己公司的知识产权，也有可能是从安全的角度考虑，避免一些关键信息的泄漏等等，这不是本文讨论的范围。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Xtrabackup全量备份/增量备份脚本]]></title>
    <link href="http://colobu.com/2018/01/09/xtrabackup-full-increament-backup/"/>
    <id>http://colobu.com/2018/01/09/xtrabackup-full-increament-backup/</id>
    <published>2018-01-09T09:24:34.000Z</published>
    <updated>2018-01-20T06:23:31.304Z</updated>
    <content type="html"><![CDATA[<p>本文收集了几篇关于使用 <code>Xtrabackup/innobackupex</code>进行mysql数据库全量和增量备份的脚本，学习之用。搜集的几篇都是转载，非本文原创。</p>
<a id="more"></a>
<h1 id="Xtrabackup全量备份/增量备份脚本">Xtrabackup全量备份/增量备份脚本</h1>
<p>这篇转载的文章源于 <a href="http://powermichael.blog.51cto.com/12450987/1954307，但目前这篇原始文章已经无法访问了。" target="_blank" rel="external">http://powermichael.blog.51cto.com/12450987/1954307，但目前这篇原始文章已经无法访问了。</a></p>
<h2 id="全量备份脚本">全量备份脚本</h2>
<h3 id="全量备份脚本-1">全量备份脚本</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment">#Description:xtrabackup complete</span></div><div class="line"><span class="comment">#Author:created by michael</span></div><div class="line"><span class="comment">#2017-08-07 v0.1</span></div><div class="line"><span class="comment">#</span></div><div class="line">USER=root</div><div class="line">PASSWD=<span class="number">123456</span></div><div class="line">BACKUP_DIR=/backup/mysql/complete</div><div class="line">DATE=$(date +<span class="string">"%F_%T"</span>)</div><div class="line">[[ <span class="operator">-d</span> <span class="variable">$BACKUP_DIR</span> ]] || mkdir <span class="variable">$DATE_DIR</span></div><div class="line">innobackupex --user=<span class="variable">$USER</span> --password=<span class="variable">$PASSWD</span> <span class="variable">$BACKUP_DIR</span> &&gt; /tmp/mysql/<span class="string">"<span class="variable">$DATE</span>"</span>.txt</div><div class="line">egrep <span class="string">".* Backup created in directory.*"</span> /tmp/mysql/<span class="string">"<span class="variable">$DATE</span>"</span>.txt &gt;&gt; <span class="variable">$BACKUP_DIR</span>/complete.info</div><div class="line">rm -rf /tmp/mysql/<span class="string">"<span class="variable">$DATE</span>"</span>.txt</div></pre></td></tr></table></figure>

<h3 id="启动crond以及开机自启动crond">启动crond以及开机自启动crond</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl start crond</div><div class="line">systemctl enable crond</div></pre></td></tr></table></figure>

<h3 id="授予执行权限">授予执行权限</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod <span class="number">755</span> /root/script/backup_complete.sh</div></pre></td></tr></table></figure>

<h3 id="每周六的凌晨4点整定时执行全量备份">每周六的凌晨4点整定时执行全量备份</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@michaelos complete]<span class="comment"># crontab -e</span></div><div class="line">crontab: installing new crontab</div><div class="line">[root@michaelos complete]<span class="comment"># crontab -l</span></div><div class="line"><span class="number">0</span> <span class="number">4</span> * * <span class="number">6</span> /root/script/backup_complete.sh</div></pre></td></tr></table></figure>

<h2 id="增量备份脚本">增量备份脚本</h2>
<h3 id="增量备份脚本-1">增量备份脚本</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[root@michaelos script]<span class="comment"># cat backup_increment.sh </span></div><div class="line"><span class="shebang">#!/bin/bash </span></div><div class="line"><span class="comment">#Description: mysql backup incremention</span></div><div class="line"><span class="comment">#Author:michael</span></div><div class="line"><span class="comment">#2017-08-07 v0.1</span></div><div class="line"><span class="comment">#</span></div><div class="line">USER=root</div><div class="line">PASSWORD=<span class="number">123456</span></div><div class="line">BACKUP_DIR=/backup/mysql/increment</div><div class="line">DATE=$(date +<span class="string">"%F_<span class="variable">$T</span>"</span>)</div><div class="line">BASE_DIR=$(tail -<span class="number">1</span> /backup/mysql/complete/complete.info | cut <span class="operator">-d</span>\<span class="string">' -f2)</span></div><div class="line">[[ -d $BACKUP_DIR ]] || mkdir $BACKUP_DIR</div><div class="line">innobackupex --user=$USER --password=$PASSWORD --incremental $BACKUP_DIR --incremental-basedir=$BASE_DIR &&gt; /tmp/mysql/"$DATE".txt</div><div class="line">egrep ".*Backup created in directory.*" /tmp/mysql/"$DATE".txt &gt;&gt; $BACKUP_DIR/backup.info</div><div class="line">rm -rf /tmp/mysql/"$DATE".txt</div></pre></td></tr></table></figure>

<h3 id="授予执行权限-1">授予执行权限</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod <span class="number">755</span> backup_increment.sh</div></pre></td></tr></table></figure>

<h3 id="每周二、四、日的凌晨2点执行增量备份">每周二、四、日的凌晨2点执行增量备份</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@michaelos script]<span class="comment"># crontab -l</span></div><div class="line"><span class="number">0</span> <span class="number">4</span> * * <span class="number">6</span> /root/script/backup_complete.sh</div><div class="line"><span class="number">0</span> <span class="number">2</span> * * <span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span> /root/script/backup_increment.sh</div></pre></td></tr></table></figure>

<h1 id="xtrabackup全量增量备份脚本">xtrabackup全量增量备份脚本</h1>
<p>这篇文章来自 <a href="https://segmentfault.com/a/1190000009379775" target="_blank" rel="external">segmentfault</a>的<a href="https://segmentfault.com/u/lindaling" target="_blank" rel="external">linda玲</a>。</p>
<h2 id="全量备份脚本-2">全量备份脚本</h2>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/sh</span></div><div class="line"><span class="comment"># add ling</span></div><div class="line"> </div><div class="line">INNOBACKUPEX=innobackupex</div><div class="line">INNOBACKUPEXFULL=/usr/bin/<span class="variable">$INNOBACKUPEX</span></div><div class="line">TODAY=`date +%Y%m%d%H%M`</div><div class="line">YESTERDAY=`date <span class="operator">-d</span><span class="string">"yesterday"</span> +%Y%m%d%H%M`</div><div class="line">USEROPTIONS=<span class="string">"--user=user --password=123456"</span></div><div class="line">TMPFILE=<span class="string">"/logs/mysql/innobackup_<span class="variable">$TODAY</span>.$$.tmp"</span></div><div class="line">MYCNF=/etc/my.cnf</div><div class="line">MYSQL=/usr/local/mariadb/bin/mysql</div><div class="line">MYSQLADMIN=/usr/local/mariadb/bin/mysqladmin</div><div class="line">BACKUPDIR=/backup/mysql <span class="comment"># 备份的主目录</span></div><div class="line">FULLBACKUPDIR=<span class="variable">$BACKUPDIR</span>/full <span class="comment"># 全库备份的目录</span></div><div class="line">INCRBACKUPDIR=<span class="variable">$BACKUPDIR</span>/incr <span class="comment"># 增量备份的目录</span></div><div class="line">KEEP=<span class="number">1</span> <span class="comment"># 保留几个全库备份</span></div><div class="line"> </div><div class="line"><span class="comment"># Grab start time</span></div><div class="line"><span class="comment">#############################################################################</span></div><div class="line"><span class="comment"># Display error message and exit</span></div><div class="line"><span class="comment">#############################################################################</span></div><div class="line"><span class="function"><span class="title">error</span></span>()</div><div class="line">{</div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="number">1</span>&gt;&<span class="number">2</span></div><div class="line">    <span class="keyword">exit</span> <span class="number">1</span></div><div class="line">}</div><div class="line"> </div><div class="line"><span class="comment"># Check options before proceeding</span></div><div class="line"><span class="keyword">if</span> [ ! -x <span class="variable">$INNOBACKUPEXFULL</span> ]; <span class="keyword">then</span></div><div class="line">  error <span class="string">"<span class="variable">$INNOBACKUPEXFULL</span> does not exist."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$BACKUPDIR</span> ]; <span class="keyword">then</span></div><div class="line">  error <span class="string">"Backup destination folder: <span class="variable">$BACKUPDIR</span> does not exist."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> [ -z <span class="string">"`<span class="variable">$MYSQLADMIN</span> <span class="variable">$USEROPTIONS</span> status | grep 'Uptime'`"</span> ] ; <span class="keyword">then</span></div><div class="line"> error <span class="string">"HALTED: MySQL does not appear to be running."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> ! `<span class="built_in">echo</span> <span class="string">'exit'</span> | <span class="variable">$MYSQL</span> <span class="operator">-s</span> <span class="variable">$USEROPTIONS</span>` ; <span class="keyword">then</span></div><div class="line"> error <span class="string">"HALTED: Supplied mysql username or password appears to be incorrect (not copied here for security, see script)."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="comment"># Some info output</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"----------------------------"</span></div><div class="line"><span class="built_in">echo</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>: MySQL backup script"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"started: `date`"</span></div><div class="line"><span class="built_in">echo</span></div><div class="line"> </div><div class="line"><span class="comment"># Create full and incr backup directories if they not exist.</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$FULLBACKUPDIR</span> <span class="variable">$INCRBACKUPDIR</span></div><div class="line"><span class="keyword">do</span></div><div class="line">        <span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$i</span> ]; <span class="keyword">then</span></div><div class="line">                mkdir -pv <span class="variable">$i</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line"> </div><div class="line"><span class="comment"># 压缩上传前一天的备份</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"压缩前一天的备份，scp到远程主机"</span></div><div class="line"><span class="built_in">cd</span> <span class="variable">$BACKUPDIR</span></div><div class="line">tar -zcvf <span class="variable">$YESTERDAY</span>.tar.gz ./full/ ./incr/</div><div class="line">scp -P <span class="number">8022</span> <span class="variable">$YESTERDAY</span>.tar.gz root@<span class="number">192.168</span>.<span class="number">10.46</span>:/data/backup/mysql/</div><div class="line"><span class="keyword">if</span> [ $? = <span class="number">0</span> ]; <span class="keyword">then</span></div><div class="line">  rm -rf <span class="variable">$BACKUPDIR</span>/full <span class="variable">$BACKUPDIR</span>/incr</div><div class="line">  <span class="built_in">echo</span> <span class="string">"Running new full backup."</span></div><div class="line">  innobackupex --defaults-file=<span class="variable">$MYCNF</span> <span class="variable">$USEROPTIONS</span> <span class="variable">$FULLBACKUPDIR</span> &gt; <span class="variable">$TMPFILE</span> <span class="number">2</span>&gt;&<span class="number">1</span></div><div class="line"><span class="keyword">else</span></div><div class="line">  <span class="built_in">echo</span> <span class="string">"Error with scp."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> [ -z <span class="string">"`tail -1 <span class="variable">$TMPFILE</span> | grep 'completed OK!'`"</span> ] ; <span class="keyword">then</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$INNOBACKUPEX</span> failed:"</span>; <span class="built_in">echo</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"---------- ERROR OUTPUT from <span class="variable">$INNOBACKUPEX</span> ----------"</span></div><div class="line"><span class="comment"># cat $TMPFILE</span></div><div class="line"><span class="comment"># rm -f $TMPFILE</span></div><div class="line"> <span class="keyword">exit</span> <span class="number">1</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment"># 这里获取这次备份的目录 </span></div><div class="line">THISBACKUP=`awk -- <span class="string">"/Backup created in directory/ { split( \\\$0, p, \"'\" ) ; print p[2] }"</span> <span class="variable">$TMPFILE</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"THISBACKUP=<span class="variable">$THISBACKUP</span>"</span></div><div class="line"><span class="comment">#rm -f $TMPFILE</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Databases backed up successfully to: <span class="variable">$THISBACKUP</span>"</span></div><div class="line"></div><div class="line"><span class="comment"># Cleanup</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"delete tar files of 3 days ago"</span></div><div class="line">find <span class="variable">$BACKUPDIR</span>/ -mtime +<span class="number">3</span> -name <span class="string">"*.tar.gz"</span>  -exec rm -rf {} \;</div><div class="line"> </div><div class="line"><span class="built_in">echo</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"completed: `date`"</span></div><div class="line"><span class="keyword">exit</span> <span class="number">0</span></div></pre></td></tr></table></figure>

<h2 id="增量备份脚本-2">增量备份脚本</h2>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/sh</span></div><div class="line"><span class="comment"># add ling</span></div><div class="line"> </div><div class="line">INNOBACKUPEX=innobackupex</div><div class="line">INNOBACKUPEXFULL=/usr/bin/<span class="variable">$INNOBACKUPEX</span></div><div class="line">TODAY=`date +%Y%m%d%H%M`</div><div class="line">USEROPTIONS=<span class="string">"--user=user --password=123456"</span></div><div class="line">TMPFILE=<span class="string">"/logs/mysql/incr_<span class="variable">$TODAY</span>.$$.tmp"</span></div><div class="line">MYCNF=/etc/my.cnf</div><div class="line">MYSQL=/usr/local/mariadb/bin/mysql</div><div class="line">MYSQLADMIN=/usr/local/mariadb/bin/mysqladmin</div><div class="line">BACKUPDIR=/backup/mysql <span class="comment"># 备份的主目录</span></div><div class="line">FULLBACKUPDIR=<span class="variable">$BACKUPDIR</span>/full <span class="comment"># 全库备份的目录</span></div><div class="line">INCRBACKUPDIR=<span class="variable">$BACKUPDIR</span>/incr <span class="comment"># 增量备份的目录</span></div><div class="line"></div><div class="line"><span class="comment">#############################################################################</span></div><div class="line"><span class="comment"># Display error message and exit</span></div><div class="line"><span class="comment">#############################################################################</span></div><div class="line"><span class="function"><span class="title">error</span></span>()</div><div class="line">{</div><div class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="number">1</span>&gt;&<span class="number">2</span></div><div class="line">    <span class="keyword">exit</span> <span class="number">1</span></div><div class="line">}</div><div class="line"> </div><div class="line"><span class="comment"># Check options before proceeding</span></div><div class="line"><span class="keyword">if</span> [ ! -x <span class="variable">$INNOBACKUPEXFULL</span> ]; <span class="keyword">then</span></div><div class="line">  error <span class="string">"<span class="variable">$INNOBACKUPEXFULL</span> does not exist."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$BACKUPDIR</span> ]; <span class="keyword">then</span></div><div class="line">  error <span class="string">"Backup destination folder: <span class="variable">$BACKUPDIR</span> does not exist."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> [ -z <span class="string">"`<span class="variable">$MYSQLADMIN</span> <span class="variable">$USEROPTIONS</span> status | grep 'Uptime'`"</span> ] ; <span class="keyword">then</span></div><div class="line"> error <span class="string">"HALTED: MySQL does not appear to be running."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> ! `<span class="built_in">echo</span> <span class="string">'exit'</span> | <span class="variable">$MYSQL</span> <span class="operator">-s</span> <span class="variable">$USEROPTIONS</span>` ; <span class="keyword">then</span></div><div class="line"> error <span class="string">"HALTED: Supplied mysql username or password appears to be incorrect (not copied here for security, see script)."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"> </div><div class="line"><span class="comment"># Some info output</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"----------------------------"</span></div><div class="line"><span class="built_in">echo</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$0</span>: MySQL backup script"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"started: `date`"</span></div><div class="line"><span class="built_in">echo</span></div><div class="line"> </div><div class="line"><span class="comment"># Create full and incr backup directories if they not exist.</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$FULLBACKUPDIR</span> <span class="variable">$INCRBACKUPDIR</span></div><div class="line"><span class="keyword">do</span></div><div class="line">        <span class="keyword">if</span> [ ! <span class="operator">-d</span> <span class="variable">$i</span> ]; <span class="keyword">then</span></div><div class="line">                mkdir -pv <span class="variable">$i</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line"> </div><div class="line"><span class="comment"># Find latest full backup</span></div><div class="line">LATEST_FULL=`find <span class="variable">$FULLBACKUPDIR</span> -mindepth <span class="number">1</span> -maxdepth <span class="number">1</span> -type d -printf <span class="string">"%P\n"</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"LATEST_FULL=<span class="variable">$LATEST_FULL</span>"</span> </div><div class="line"></div><div class="line"><span class="comment"># Run an incremental backup if latest full is still valid.</span></div><div class="line"><span class="comment"># Create incremental backups dir if not exists.</span></div><div class="line">TMPINCRDIR=<span class="variable">$INCRBACKUPDIR</span>/<span class="variable">$LATEST_FULL</span></div><div class="line">mkdir -p <span class="variable">$TMPINCRDIR</span></div><div class="line">BACKTYPE=<span class="string">"incr"</span></div><div class="line"><span class="comment"># Find latest incremental backup.</span></div><div class="line">LATEST_INCR=`find <span class="variable">$TMPINCRDIR</span> -mindepth <span class="number">1</span> -maxdepth <span class="number">1</span> -type d | sort -nr | head -<span class="number">1</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"LATEST_INCR=<span class="variable">$LATEST_INCR</span>"</span></div><div class="line">  <span class="comment"># If this is the first incremental, use the full as base. Otherwise, use the latest incremental as base.</span></div><div class="line"><span class="keyword">if</span> [ ! <span class="variable">$LATEST_INCR</span> ] ; <span class="keyword">then</span></div><div class="line">  INCRBASEDIR=<span class="variable">$FULLBACKUPDIR</span>/<span class="variable">$LATEST_FULL</span></div><div class="line"><span class="keyword">else</span></div><div class="line">  INCRBASEDIR=<span class="variable">$LATEST_INCR</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Running new incremental backup using <span class="variable">$INCRBASEDIR</span> as base."</span></div><div class="line">innobackupex --defaults-file=<span class="variable">$MYCNF</span> <span class="variable">$USEROPTIONS</span> --incremental <span class="variable">$TMPINCRDIR</span> --incremental-basedir <span class="variable">$INCRBASEDIR</span> &gt; <span class="variable">$TMPFILE</span> <span class="number">2</span>&gt;&<span class="number">1</span></div><div class="line"></div><div class="line"> </div><div class="line"><span class="keyword">if</span> [ -z <span class="string">"`tail -1 <span class="variable">$TMPFILE</span> | grep 'completed OK!'`"</span> ] ; <span class="keyword">then</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$INNOBACKUPEX</span> failed:"</span>; <span class="built_in">echo</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"---------- ERROR OUTPUT from <span class="variable">$INNOBACKUPEX</span> ----------"</span></div><div class="line"> <span class="keyword">exit</span> <span class="number">1</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment"># 这里获取这次备份的目录 </span></div><div class="line">THISBACKUP=`awk -- <span class="string">"/Backup created in directory/ { split( \\\$0, p, \"'\" ) ; print p[2] }"</span> <span class="variable">$TMPFILE</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"THISBACKUP=<span class="variable">$THISBACKUP</span>"</span></div><div class="line"><span class="built_in">echo</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Databases backed up successfully to: <span class="variable">$THISBACKUP</span>"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"incremental completed: `date`"</span></div><div class="line"><span class="keyword">exit</span> <span class="number">0</span></div></pre></td></tr></table></figure>

<h1 id="分别基于innobackupex备份工具的mysql全量备份和增量备份shell脚本">分别基于innobackupex备份工具的mysql全量备份和增量备份shell脚本</h1>
<p>这是另一篇mysql全量和增量备份的脚本， 来自 <a href="http://www.21yunwei.com/archives/5013" target="_blank" rel="external">21运维</a>。</p>
<p>之前有过一个基于innobackupex备份mysql文章，不是很简单实用。这里是一个更为简单的脚本，可以实现分别基于innobackupex备份工具的mysql全量备份和增量备份。<br>注意：<br>1，线上用的时候请注意将自己的用户名和密码都设置对，这里password密码我暂时用xxxxxx代替。当然，你也可以建立专用于备份用的数据库用户并设置权限。<br>2，根据情况设置一个任务计划。</p>
<h2 id="mysql全量备份脚本如下">mysql全量备份脚本如下</h2>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment">#author:21yunwei</span></div><div class="line">logfile=<span class="string">"/home/mysqlbak/mysql_full_bak_time.log"</span></div><div class="line">backuplogfile=<span class="string">"/home/mysqlbak/mysqlbackup.log"</span></div><div class="line">mysql_bakdir=<span class="string">"/home/mysqlbak/"</span></div><div class="line">user=root</div><div class="line">password=xxxxxx</div><div class="line"> </div><div class="line">[ ! <span class="operator">-d</span> <span class="variable">$mysql_bakdir</span>  ] &&  mkdir -p <span class="variable">$mysql_bakdir</span></div><div class="line">[ ! <span class="operator">-f</span>  <span class="variable">$logfile</span> ] && touch  <span class="variable">$logfile</span></div><div class="line"> </div><div class="line">innobackupex --defaults-file=/etc/my.cnf --user=<span class="variable">${user}</span> --password=<span class="variable">${password}</span> --compress –-parallel=<span class="number">4</span> –-throttle=<span class="number">400</span> --stream=tar <span class="variable">${mysql_bakdir}</span> <span class="number">2</span>&gt;&<span class="number">1</span> &gt;&gt; <span class="variable">$backuplogfile</span></div><div class="line">reset=$?</div><div class="line">finishtime=`date +%Y%m%d_%H%M%S`</div><div class="line">[ <span class="variable">${reset}</span> <span class="operator">-eq</span> <span class="number">0</span> ] && <span class="built_in">echo</span>  <span class="string">"Mysql fullbakup  finished, time: <span class="variable">$finishtime</span>"</span>&gt;&gt;  <span class="variable">$logfile</span> || <span class="built_in">echo</span> <span class="string">"Mysql fullbakup failed,please check time:<span class="variable">$finishtime</span>"</span> &gt;&gt;  <span class="variable">$logfile</span></div></pre></td></tr></table></figure>

<h2 id="mysql增量备份脚本如下">mysql增量备份脚本如下</h2>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="shebang">#!/bin/bash</span></div><div class="line"><span class="comment">#author:21yunwei</span></div><div class="line">time=`date <span class="operator">-d</span> <span class="string">'-3 day'</span> +%Y-%m-%d`</div><div class="line">logfile=<span class="string">"/home/mysqlbak/mysql_full_bak_time.log"</span></div><div class="line">mysql_bakdir=<span class="string">"/home/mysqlbak/"</span></div><div class="line">user=root</div><div class="line">password=xxxxxx</div><div class="line">lastfullbakdir=`ls /home/mysqlbak/ |grep <span class="variable">${time}</span>`</div><div class="line"> </div><div class="line">[ ! <span class="operator">-d</span> <span class="variable">$mysql_bakdir</span>  ] &&  mkdir -p <span class="variable">$mysql_bakdir</span></div><div class="line">[ ! <span class="operator">-d</span>  <span class="variable">$logfile</span> ] && touch  <span class="variable">$logfile</span></div><div class="line"> </div><div class="line">innobackupex --defaults-file=/etc/my.cnf --user=<span class="variable">${user}</span> --password=<span class="variable">${password}</span> --incremental-basedir=<span class="variable">${mysql_bakdir}</span>/<span class="variable">${lastfullbakdir}</span>  --incremental <span class="variable">${mysql_bakdir}</span></div><div class="line">finishtime=`date +%Y%m%d_%H%M%S`</div><div class="line">[ $? <span class="operator">-eq</span> <span class="number">0</span> ] && <span class="built_in">echo</span>  <span class="string">"Mysql fullbakup  finished, time: <span class="variable">$finishtime</span>"</span>&gt;&gt;   <span class="variable">$logfile</span> || <span class="built_in">echo</span> <span class="string">"Mysql fullbakup failed,please check time:<span class="variable">$finishtime</span>"</span>&gt;&gt;  <span class="variable">$logfile</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>本文收集了几篇关于使用 <code>Xtrabackup/innobackupex</code>进行mysql数据库全量和增量备份的脚本，学习之用。搜集的几篇都是转载，非本文原创。</p>
]]>
    
    </summary>
    
      <category term="运维" scheme="http://colobu.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]编写高性能的Go代码的最佳实践]]></title>
    <link href="http://colobu.com/2017/12/29/best-practices-for-writing-high-performance-Go-code/"/>
    <id>http://colobu.com/2017/12/29/best-practices-for-writing-high-performance-Go-code/</id>
    <published>2017-12-29T03:43:09.000Z</published>
    <updated>2018-01-20T06:23:31.274Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://github.com/dgryski/go-perfbook/blob/master/performance.md" target="_blank" rel="external">go-perfbook/performance</a></p>
<p>This document outlines best practices for writing high-performance Go code.</p>
<p>At the moment, it&#39;s a collection of links to videos, slides, and blog posts<br>(&quot;awesome-go-performance&quot;), but I would like this to evolve into a longer book<br>format where the content is here instead of external.  The links should be sorted into categories.</p>
<p>All the content will be licensed under CC-BY-SA.</p>
<a id="more"></a>
<h2 id="Optimization_Workflow">Optimization Workflow</h2>
<ul>
<li><p>All optimizations should follow these steps:</p>
<ol>
<li>determine your performance goals and confirm you are not meeting them</li>
<li>profile to identify the areas to improve.  This can be CPU, heap allocations, or goroutine blocking.</li>
<li>benchmark to determine the speed up your solution will provide using<br>the built-in benchmarking framework (<a href="http://golang.org/pkg/testing/" target="_blank" rel="external">http://golang.org/pkg/testing/</a>)<br>Make sure you&#39;re benchmarking the right thing, and benchmarking it on your target operating system and architecture. Benchmarking on your macbook is not the same as benchmarking in a production-like environment.</li>
<li>profile again afterwards to verify the issue is gone</li>
<li>use <a href="https://godoc.org/golang.org/x/perf/benchstat" target="_blank" rel="external">https://godoc.org/golang.org/x/perf/benchstat</a> or<br><a href="https://github.com/codahale/tinystat" target="_blank" rel="external">https://github.com/codahale/tinystat</a> to verify that a set of timings<br>are &#39;sufficiently&#39; different for an optimization to be worth the<br>added code complexity.</li>
<li>use <a href="https://github.com/tsenart/vegeta" target="_blank" rel="external">https://github.com/tsenart/vegeta</a> for load testing http services</li>
<li>make sure your latency numbers make sense: <a href="https://youtu.be/lJ8ydIuPFeU" target="_blank" rel="external">https://youtu.be/lJ8ydIuPFeU</a></li>
</ol>
</li>
</ul>
<p>The first step is important. It tells you when and where to start optimizing.<br>More importantly, it also tells you when to stop.  Pretty much all<br>optimizations add code complexity in exchange for speed.  And you can <em>always</em><br>make code faster.  It&#39;s a balancing act.</p>
<p>The basic rules of the game are:</p>
<ol>
<li>minimize CPU usage<ul>
<li>do less work</li>
<li>this generally means &quot;a faster algorithm&quot;</li>
<li>but CPU caches and the hidden constants in O() can play tricks on you</li>
</ul>
</li>
<li>minimize allocations (which leads to less CPU stolen by the GC)</li>
<li>make your data quick to access</li>
</ol>
<p>This book is split into different sections:<br>   1) basic tips for writing not-slow software</p>
<pre><code> <span class="keyword">*</span> CS 101-level stuff
</code></pre><p>   2) tips for writing fast software</p>
<pre><code> * Go-specific sections <span class="function_start"><span class="keyword">on</span></span> how <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">the</span> best <span class="keyword">from</span> Go
</code></pre><p>   3) advanced tips for writing <em>really</em> fast software</p>
<pre><code> * <span class="keyword">For</span> <span class="keyword">when</span> your optimized code isn<span class="comment">'t fast enough</span>
</code></pre><h2 id="Basics">Basics</h2>
<ol>
<li>choose the best algorithm<ul>
<li>traditional computer science analysis</li>
<li>O(n^2) vs O(n log n) vs O(log n) vs O(1)</li>
<li>this should handle the majority of your optimization cases</li>
<li>be aware of <a href="http://accidentallyquadratic.tumblr.com/" target="_blank" rel="external">http://accidentallyquadratic.tumblr.com/</a></li>
<li><a href="https://agtb.wordpress.com/2010/12/23/progress-in-algorithms-beats-moore%E2%80%99s-law/" target="_blank" rel="external">https://agtb.wordpress.com/2010/12/23/progress-in-algorithms-beats-moore%E2%80%99s-law/</a></li>
</ul>
</li>
<li>pre-compute things you need</li>
<li>add a cache -&gt; reduces work</li>
</ol>
<h2 id="Introductory_Profiling">Introductory Profiling</h2>
<p>Techniques applicable to source code in general</p>
<ol>
<li>introduction to pprof<ul>
<li>go tool pprof (and <a href="https://github.com/google/pprof" target="_blank" rel="external">https://github.com/google/pprof</a>)</li>
</ul>
</li>
<li>Writing and running (micro)benchmarks<ul>
<li>-cpuprofile / -memprofile / -benchmem</li>
</ul>
</li>
<li>How to read it pprof output</li>
<li>What are the different pieces of the runtime that show up</li>
<li>Macro-benchmarks (Profiling in production)<ul>
<li>net/http/pprof</li>
</ul>
</li>
</ol>
<h2 id="Tracer">Tracer</h2>
<h2 id="Advanced_Techniques">Advanced Techniques</h2>
<ul>
<li><p>Techniques specific to the architecture running the code</p>
<ul>
<li>introduction to CPU caches<ul>
<li>building intuition around cache-lines: sizes, padding, alignment</li>
<li>false-sharing</li>
<li>OS tools to view cache-misses</li>
</ul>
</li>
<li>(also branch prediction)</li>
</ul>
</li>
<li><p>Comment about Jeff Dean&#39;s 2002 numbers (plus updates)</p>
<ul>
<li>cpus have gotten faster, but memory hasn&#39;t kept up</li>
</ul>
</li>
</ul>
<h2 id="Heap_Allocations">Heap Allocations</h2>
<ul>
<li>Stack vs. heap allocations</li>
<li>What causes heap allocations?</li>
<li>Understanding escape analysis</li>
<li>Using sync.Pool effectively</li>
</ul>
<h2 id="Runtime">Runtime</h2>
<ul>
<li>cost of calls via interfaces (indirect calls on the CPU level)</li>
<li>runtime.convT2E / runtime.convT2I</li>
<li>type assertions vs. type switches</li>
<li>defer</li>
<li>special-case map implementations for ints, strings</li>
</ul>
<h2 id="Common_gotchas_with_the_standard_library">Common gotchas with the standard library</h2>
<ul>
<li>time.After() leaks until it fires</li>
<li>Reusing HTTP connections...</li>
<li>....</li>
</ul>
<h2 id="Unsafe">Unsafe</h2>
<ul>
<li>And all the dangers that go with it</li>
<li>Common uses for unsafe</li>
<li>mmap&#39;ing data files</li>
<li>speedy de-serialization</li>
</ul>
<h2 id="cgo">cgo</h2>
<ul>
<li>Performance characteristics of cgo calls</li>
<li>Tricks to reduce the costs</li>
<li>Passing pointers between Go and C</li>
</ul>
<h2 id="Assembly">Assembly</h2>
<ul>
<li>Stuff about writing assembly code for Go</li>
<li>brief intro to syntax</li>
<li>calling convention</li>
<li>using opcodes unsupported by the asm</li>
<li>notes about why intrinsics are hard</li>
</ul>
<h2 id="Alternate_implementations">Alternate implementations</h2>
<ul>
<li>Popular replacements for standard library packages:<ul>
<li>encoding/json -&gt; ffjson</li>
<li>net/http -&gt; fasthttp</li>
<li>regexp -&gt; ragel (or other regular expression package)</li>
<li>serialization<ul>
<li>encoding/gob -&gt; <a href="https://github.com/alecthomas/go_serialization_benchmarks" target="_blank" rel="external">https://github.com/alecthomas/go_serialization_benchmarks</a></li>
<li>protobuf -&gt; <a href="https://github.com/gogo/protobuf" target="_blank" rel="external">https://github.com/gogo/protobuf</a></li>
<li>all formats have trade-offs; choose one that matches what you need</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Tooling">Tooling</h2>
<p>Look at some more interesting/advanced tooling</p>
<ul>
<li><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="external">perf</a>  (<a href="https://github.com/rsc/perf2pprof" target="_blank" rel="external">perf2pprof</a>、<a href="https://github.com/google/pprof" target="_blank" rel="external">pprof</a>)</li>
<li><a href="https://github.com/uber/go-torch" target="_blank" rel="external">go-torch</a> (+flamegraphs)</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://github.com/dgryski/go-perfbook/blob/master/performance.md" target="_blank" rel="external">go-perfbook/performance</a></p>
<p>This document outlines best practices for writing high-performance Go code.</p>
<p>At the moment, it&#39;s a collection of links to videos, slides, and blog posts<br>(&quot;awesome-go-performance&quot;), but I would like this to evolve into a longer book<br>format where the content is here instead of external.  The links should be sorted into categories.</p>
<p>All the content will be licensed under CC-BY-SA.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[年终盘点！2017年超有价值的Golang文章]]></title>
    <link href="http://colobu.com/2017/12/28/top-golang-articles-of-2017/"/>
    <id>http://colobu.com/2017/12/28/top-golang-articles-of-2017/</id>
    <published>2017-12-28T13:32:38.000Z</published>
    <updated>2018-01-20T06:23:31.298Z</updated>
    <content type="html"><![CDATA[<p>马上就要进入2018年了，作为年终的盘点，本文列出了一些2017年的关于Go编程的一些文章，并加上简短的介绍。</p>
<p>文章排名不分先后， 文章也不一定完全按照日期来排列。我按照文章的大致内容分了类，便于查找。</p>
<p>文章主要从golangweekly、gocn每日新闻、medium、reddit、twitter、、知名博主的文章搜集而来。如果你发现好的2017年的Go文章没有列出来，欢迎在评论中粘帖出来，我会加入到文章正文中。</p>
<p>本文主要列出的是文章，2017年也涌现出来很多优秀的库和工具，但是不是本文要介绍的内容，所以没有列出来。</p>
<a id="more"></a>
<p><img src="go.jpg" alt=""></p>
<h2 id="语言规范">语言规范</h2>
<ul>
<li><a href="http://www.tapirgames.com/blog/golang-channel-closing" target="_blank" rel="external">Close Channels Gracefully in Golang</a>: 如何优雅地关闭channel?</li>
<li><a href="http://commaok.xyz/post/compile-time-assertions/" target="_blank" rel="external">Compile-time assertions in Go</a>: 编译时断言</li>
<li><a href="https://www.calhoun.io/why-are-slices-sometimes-altered-when-passed-by-value-in-go/" target="_blank" rel="external">Why are slices sometimes altered when passed by value in Go?</a>: Go不是按值传递么，怎么slice传入后被更改了呢？其实map也一样</li>
<li><a href="https://dev.to/vladimirvivien/bit-hacking-with-go" target="_blank" rel="external">Bit Hacking with Go</a>: Go的位操作</li>
<li><a href="https://garbagecollected.org/2017/02/22/go-range-loop-internals/" target="_blank" rel="external">Go Range Loop Internals</a>: range内幕</li>
<li><a href="http://www.tapirgames.com/blog/golang-block-and-scope" target="_blank" rel="external">Blocks and Scopes in Golang</a>: 代码块和作用域</li>
<li><a href="http://www.tapirgames.com/blog/golang-memory-alignment" target="_blank" rel="external">Address Alignments in Go</a>:地址对齐</li>
<li><a href="https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back" target="_blank" rel="external">Understand Go pointers in less than 800 words</a>:回顾一下指针的概念</li>
<li><a href="https://golangbot.com/pointers/" target="_blank" rel="external">Another Introduction to Pointers in Go</a>:另一篇关于指针的介绍</li>
<li><a href="https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go" target="_blank" rel="external">There is no pass-by-reference in Go</a>: Go中没有引用传值</li>
<li><a href="https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ" target="_blank" rel="external">Why golang garbage-collector not implement Generational and Compact gc?</a>: 为什么不使用分代或者压缩的垃圾回收器？</li>
<li><a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e" target="_blank" rel="external">Modern garbage collection</a>: Go的垃圾回收器</li>
<li><a href="https://www.goinggo.net/2017/05/language-mechanics-on-stacks-and-pointers.html" target="_blank" rel="external">Language Mechanics On Stacks And Pointers</a>: William Kennedy写的系列， 一共四篇， 深入底层</li>
<li><a href="https://golangbot.com/shttps://medium.com/golangspec/init-functions-in-go-eac191b3860atructs/" target="_blank" rel="external">Structures</a>: Go struct介绍</li>
<li><a href="https://zhuanlan.zhihu.com/p/27056944" target="_blank" rel="external">Go调度详解</a>: 调度概览</li>
<li><a href="http://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="external">也谈goroutine调度器</a>: 也谈谈Go的调度器</li>
<li><a href="http://colobu.com/2017/06/26/learn-go-type-aliases/" target="_blank" rel="external">了解 Go 1.9 的类型别名</a>: Go 1.9中的类型别名</li>
<li><a href="https://blog.minio.io/golang-internals-part-2-nice-benefits-of-named-return-values-1e95305c8687" target="_blank" rel="external">Golang Internals Part 2: Nice benefits of named return values</a>: 返回值采用命名方式的好处</li>
<li><a href="http://legendtkl.com/2017/07/01/golang-interface-implement/" target="_blank" rel="external">Go Interface 源码剖析</a>: interface源代码</li>
<li><a href="https://www.cockroachlabs.com/blog/rounding-implementations-in-go/" target="_blank" rel="external">Survey of Rounding Implementations in Go</a>: 四舍五入不简单</li>
<li><a href="http://www.cppblog.com/sunicdavy/archive/2017/07/06/215057.html" target="_blank" rel="external">Golang 热更新研究笔记</a>: 热更新笔记</li>
<li><a href="https://flaviocopes.com/go-empty-interface/" target="_blank" rel="external">go empty interface</a>:空接口</li>
<li><a href="http://sanyuesha.com/2017/07/22/how-to-understand-go-interface/" target="_blank" rel="external">理解 go interface 的 5 个关键点</a>: 接口关键点</li>
<li><a href="https://mzh.io/golang-asm-notes" target="_blank" rel="external">Go汇编实战的坑</a>: 赞，国人给golang提patch</li>
<li><a href="http://www.cnxct.com/why-golang-elf-binary-file-is-large-than-c/" target="_blank" rel="external">golang语言编译的二进制可执行文件为什么比 C 语言大</a>:深入分析</li>
<li><a href="https://medium.com/golangspec/init-functions-in-go-eac191b3860a" target="_blank" rel="external">init functions in Go</a>:init函数不简单</li>
<li><a href="http://herman.asia/bit-manipulation-in-go-1-9" target="_blank" rel="external">Efficient Bit Manipulation in Go 1.9</a>: 有效的位操作</li>
<li><a href="https://blog.learngoprogramming.com/learn-golang-typed-untyped-constants-70b4df443b61" target="_blank" rel="external">Learn Go constants — A visual guide</a>:可视化系列</li>
<li><a href="https://devhints.io/go" target="_blank" rel="external">Go cheatsheet</a>:小抄</li>
<li><a href="https://blog.learngoprogramming.com/gotchas-of-defer-in-go-1-8d070894cb01" target="_blank" rel="external">defer in go</a>: 还有第二部分 <a href="https://blog.learngoprogramming.com/5-gotchas-of-defer-in-go-golang-part-ii-cc550f6ad9aa" target="_blank" rel="external">part2</a></li>
<li><a href="https://www.calhoun.io/using-named-return-variables-to-capture-panics-in-go/" target="_blank" rel="external">Using named return variables to capture panics in Go</a>: 返回panic的错误</li>
<li><a href="https://medium.com/kokster/go-reflection-creating-objects-from-types-part-i-primitive-types-6119e3737f5d" target="_blank" rel="external">Go Reflection: Creating Objects from Types</a>:基本类型， <a href="https://medium.com/kokster/go-reflection-creating-objects-from-types-part-ii-composite-types-69a0e8134f20" target="_blank" rel="external">part2</a>其它类型</li>
</ul>
<h2 id="测试">测试</h2>
<ul>
<li><a href="https://medium.com/@povilasve/go-advanced-tips-tricks-a872503ac859" target="_blank" rel="external">Go advanced testing tips &amp; tricks</a>: Go测试提示和技巧</li>
<li><a href="https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742" target="_blank" rel="external">5 simple tips and tricks for writing unit tests in #golang</a>:写测试的5个技巧</li>
<li><a href="https://segment.com/blog/5-advanced-testing-techniques-in-go/" target="_blank" rel="external">5 Advanced Testing Techniques in Go</a>: 5个测试的高级技术</li>
</ul>
<h2 id="调试和性能调优">调试和性能调优</h2>
<ul>
<li><a href="http://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/" target="_blank" rel="external">Profiling and optimizing Go web applications</a>: 优化web程序，使用profiler</li>
<li><a href="https://making.pusher.com/go-tool-trace/" target="_blank" rel="external">go tool trace</a>: trace工具介绍的很少，这是其中一篇</li>
<li><a href="https://rakyll.org/coredumps/" target="_blank" rel="external">Debugging Go core dumps</a>:使用core dump调试</li>
<li><a href="https://scene-si.org/2017/06/06/benchmarking-go-programs/" target="_blank" rel="external">Benchmarking Go programs</a>: 测试和pprof, <a href="https://scene-si.org/2017/07/07/benchmarking-go-programs-part-2/" target="_blank" rel="external">第二部分</a></li>
<li><a href="https://www.opsdash.com/blog/golang-app-monitoring-statsd-expvar-prometheus.html" target="_blank" rel="external">GO APP MONITORING: EXPVAR, PROMETHEUS AND STATSD</a>: 监控实践</li>
<li><a href="https://zhuanlan.zhihu.com/p/27211445" target="_blank" rel="external">一个内部API系统的性能优化</a>: 国内用户的优化实践</li>
<li><a href="https://rakyll.org/profiler-labels/" target="_blank" rel="external">Profiler labels in Go</a>:不常用但是有用的技巧</li>
<li><a href="https://tip.golang.org/doc/diagnostics.html" target="_blank" rel="external">diagnostics</a>: 官方的介绍更准确，诊断。</li>
<li><a href="https://rakyll.org/scheduler/" target="_blank" rel="external">Go&#39;s work-stealing scheduler</a>:rakyll的介绍</li>
<li><a href="https://mp.weixin.qq.com/s/9IKaXeWTiiQTFlvZzxgsEA" target="_blank" rel="external">3倍性能的go程序优化实践</a>: 国内的优化实践</li>
<li><a href="https://syslog.ravelin.com/making-something-faster-56dd6b772b83" target="_blank" rel="external">Seven steps to 100x faster</a>: 100倍的性能提升</li>
<li><a href="https://medium.freecodecamp.org/million-websockets-and-go-cc58418460bb" target="_blank" rel="external">A Million WebSockets and Go</a>: 百万websocket连接和性能提升经验</li>
<li><a href="https://segmentfault.com/a/1190000010630859" target="_blank" rel="external">Golang 与系统调用</a>: 根据演讲整理</li>
<li><a href="https://nasciiboy.github.io/raptorVSworld/" target="_blank" rel="external">Performance comparison of regular expression engines</a>:正则表达式库的性能比较</li>
<li><a href="https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/" target="_blank" rel="external">Allocation Efficiency in High-Performance Go Services</a>:有效的内存分配</li>
<li><a href="http://colobu.com/2017/09/22/golang-bcc-bpf-function-tracing/" target="_blank" rel="external">使用 bcc/BPF 分析 go 程序</a>: Brendan Gregg的文章</li>
<li><a href="http://mmcloughlin.com/posts/your-pprof-is-showing" target="_blank" rel="external">Your pprof is showing</a>: pprof,不想多说了</li>
<li><a href="https://campoy.cat/blog/using-the-go-tracer-to-speed-up-fractal-making/" target="_blank" rel="external">Using the Go tracer to speed up fractal making</a>：go tracer</li>
<li><a href="http://www.integralist.co.uk/posts/profiling-go/" target="_blank" rel="external">Profiling Go</a>: 很好profile总结</li>
<li><a href="https://rakyll.org/pprof-ui/" target="_blank" rel="external">The new pprof user interface</a>: go 1.10中已包含新界面</li>
<li><a href="http://talks.godoc.org/github.com/davecheney/qconsf-2017/high-performance-go.slide#1" target="_blank" rel="external">High Performance Go</a>:Dave Cheney在QComSF 2017上的演讲</li>
<li><a href="https://stackimpact.com/blog/go-profiler-internals/" target="_blank" rel="external">Go Profiler Internals</a>:所谓的profile内幕</li>
<li><a href="https://www.slideshare.net/linaroorg/optimizing-golang-for-high-performance-with-arm64-assembly-sfo17314?qid=bfcec716-6947-47e5-b9c1-2bb1c4e5bfdf&amp;v=&amp;b=&amp;from_search=16" target="_blank" rel="external">Optimizing GoLang for High Performance with ARM64 Assembly</a>: 针对ARM64的优化</li>
</ul>
<h2 id="标准库">标准库</h2>
<ul>
<li><a href="https://nick.groenen.me/posts/2017/01/09/plugins-in-go-18/" target="_blank" rel="external">Plugins in Go 1.8</a>: 对Go 1.8增加的plugin包的速览</li>
<li><a href="https://appliedgo.net/networking/" target="_blank" rel="external">TCP/IP Networking</a>: 网络编程入门</li>
<li><a href="https://medium.com/@mdlayher/linux-netlink-and-go-part-1-netlink-4781aaeeaca8" target="_blank" rel="external">Linux, Netlink, and Go — Part 1: netlink</a>:访问linux netlink,还有第二篇和第三篇</li>
<li><a href="https://zupzup.org/go-port-forwarding/" target="_blank" rel="external">Port Forwarding with Go</a>: 端口转发</li>
<li><a href="https://medium.com/learning-the-go-programming-language/writing-modular-go-programs-with-plugins-ec46381ee1a9" target="_blank" rel="external">Writing Modular Go Programs with Plugins</a>: 插件</li>
<li><a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="external">Advanced command execution in Go with os/exec</a>:学习os/exec</li>
<li><a href="https://orangetux.nl/post/expvar_in_action/" target="_blank" rel="external">expvar in action</a>:知道这个标准包吗，用过吗？</li>
<li><a href="https://zhuanlan.zhihu.com/p/27608263" target="_blank" rel="external">Golang 互斥锁内部实现</a>: Go的锁实现</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;mid=2247483805&amp;idx=1&amp;sn=f365ae1beb222cb3c271fcc4ee3a1aae&amp;chksm=eb310012dc4689042a9c90faa073996133fb6d98f7b9e222c1828c07a9daf7ab387c3c5b861e&amp;scene=0&amp;key=845f133eeabfe179ef76ee7968a400ec4974d784b308d18080a26e74f43c37788cd79ca4e76fd8ae7fe9b79022de525cc5f59e101f819b00b6f4eee846bcf83df332de87b5773356522d959499f4de94&amp;ascene=0&amp;uin=MjQ2NTU1&amp;devicetype=iMac+MacBookPro11%2C3+OSX+OSX+10.12.5+build(16F73" target="_blank" rel="external">Go unsafe 包之内存布局</a>&amp;version=12020810&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=Dip3QhAoFuCXmvNUJBCqwg2%2FTrorNO8SzZpbc%2FtgnD4%3D): unsafe的一些函数</li>
<li><a href="http://colobu.com/2017/07/11/dive-into-sync-Map/" target="_blank" rel="external">Go 1.9 sync.Map揭秘</a>: sync.Map的实现揭秘</li>
<li><a href="https://zupzup.org/go-ast-traversal/" target="_blank" rel="external">Basic AST Traversal in Go</a>: ast,做工具和代码分析的都需要</li>
<li><a href="https://www.youtube.com/watch?v=01w7viEZzXQ&amp;index=20&amp;list=PL2ntRZ1ySWBdD9bru6IR-_WXUgJqvrtx9&amp;utm_source=golangweekly&amp;utm_medium=email" target="_blank" rel="external">A Go Programmer&#39;s Guide to Syscalls</a>:Liz Rice的演讲</li>
<li><a href="https://www.calhoun.io/pitfalls-of-context-values-and-how-to-avoid-or-mitigate-them/" target="_blank" rel="external">Pitfalls of context values and how to avoid or mitigate them in Go</a>: Context的陷阱以及如何避免它</li>
<li><a href="http://www.golangprograms.com/golang/string-functions/" target="_blank" rel="external">The 30 Most Popular Go String Functions</a>: 最常用的strings的30个方法</li>
<li><a href="https://pocketgophers.com/serving-https/" target="_blank" rel="external">Serving HTTPS</a>: 应用https</li>
<li><a href="https://forfuncsake.github.io/post/2017/08/trust-extra-ca-cert-in-go-app/" target="_blank" rel="external">How To Trust Extra CA Certs In Your Go App</a>: 使用外部的CA</li>
<li><a href="https://gocn.io/article/403" target="_blank" rel="external">GOLANG中time.After释放的问题</a>: time.After使用的时候注意事项</li>
<li><a href="https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c" target="_blank" rel="external">The new kid in town — Go’s sync.Map</a>:sync.Map的性能</li>
<li><a href="https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/" target="_blank" rel="external">The ultimate guide to writing a Go tool</a>: Go工具开发终极手册，gomodifytags的作者</li>
<li><a href="https://medium.com/learning-the-go-programming-language/streaming-io-in-go-d93507931185" target="_blank" rel="external">Streaming IO in Go</a>: io</li>
<li><a href="https://scene-si.org/2017/09/27/things-to-know-about-http-in-go/" target="_blank" rel="external">Things to know about HTTP in Go</a>: Go HTTP</li>
<li><a href="https://spino.tech/blog/important-go-interfaces/#golang" target="_blank" rel="external">Important interfaces that every Go developer should know</a>: 重要接口</li>
<li><a href="https://medium.com/go-walkthrough/go-walkthrough-fmt-55a14bbbfc53" target="_blank" rel="external">Go Walkthrough: fmt</a>: fmt详解</li>
<li><a href="https://siadat.github.io/post/context" target="_blank" rel="external">Context API explained</a>:context详解</li>
<li><a href="https://zupzup.org/ast-manipulation-go/" target="_blank" rel="external">Basic AST Manipulation in Go</a>:还是ast</li>
<li><a href="https://medium.com/golangspec/in-depth-introduction-to-bufio-scanner-in-golang-55483bb689b4" target="_blank" rel="external">In-depth introduction to bufio.Scanner in Golang</a>:深入介绍bufio.Scanner</li>
<li><a href="https://boltandnuts.wordpress.com/2017/11/20/go-slice-vs-maps/" target="_blank" rel="external">Go Slice vs Maps</a>:性能比较</li>
<li><a href="https://medium.com/golangspec/introduction-to-bufio-package-in-golang-ad7d1877f762" target="_blank" rel="external">Introduction to bufio package in Golang</a>: bufio介绍</li>
<li><a href="https://medium.com/@ggiovani/tcp-socket-implementation-on-golang-c38b67c5d8b" target="_blank" rel="external">TCP Socket Implementation On Golang</a>: 从外部推断内部实现</li>
<li><a href="https://medium.com/@francesc/understanding-go-programs-with-go-parser-c4e88a6edb87" target="_blank" rel="external">Understanding Go programs with go/parser</a>: 带你学习go/parser</li>
<li><a href="https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/" target="_blank" rel="external">unsafe.Pointer and system calls</a>:理解 unsafe.Pointer和系统调用</li>
<li><a href="https://blog.gopheracademy.com/advent-2017/using-go-templates/" target="_blank" rel="external">Using Go Templates</a>:使用模板</li>
</ul>
<h2 id="编程模式">编程模式</h2>
<ul>
<li><a href="https://halls-of-valhalla.org/beta/articles/functional-options-pattern-in-go,54/" target="_blank" rel="external">Functional Options Pattern in Go</a>: 介绍了参数以函数子的方式实现，更出名的是<a href="https://commandcenter.blogspot.de/2014/01/self-referential-functions-and-design.html" target="_blank" rel="external"> Rob Pike</a>提出的这种模式，以及<a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="external">Dave Cheney</a>的进一步介绍。</li>
<li><a href="https://hackernoon.com/a-story-of-a-fat-go-binary-20edc6549b97" target="_blank" rel="external">A Story of a Fat Go Binary</a>: 使用gofat给Go程序瘦身</li>
<li><a href="https://github.com/google/bloaty" target="_blank" rel="external">a size profiler for binaries </a>:瘦身瘦身，google出品</li>
<li><a href="https://www.oreilly.com/ideas/how-to-ship-production-grade-go" target="_blank" rel="external">How to ship production-grade Go</a>:开发产品级的程序</li>
<li><a href="https://github.com/Checkmarx/Go-SCP" target="_blank" rel="external">Go programming language secure coding practices guide</a>:安全代码指南</li>
<li><a href="https://mijailovic.net/2017/05/09/error-handling-patterns-in-go/" target="_blank" rel="external">Error handling patterns in Go</a>: Go的错误处理总是让人困惑</li>
<li><a href="https://mymemorysucks.wordpress.com/2017/05/16/alternative-patterns-for-method-overloading-in-go/" target="_blank" rel="external">Alternative Patterns for Method Overloading in Go</a>: Go的方法重载的可选实现</li>
<li><a href="https://dave.cheney.net/2017/06/11/go-without-package-scoped-variables" target="_blank" rel="external">Go, without package scoped variables</a>: 不推荐包级别的变量，但是怎么做呢</li>
<li><a href="https://joeshaw.org/dont-defer-close-on-writable-files/" target="_blank" rel="external">Don’t defer Close() on writable files</a>: defer会忽略错误</li>
<li><a href="http://tmrts.com/go-patterns/" target="_blank" rel="external">Go Patterns</a>: Go设计模式</li>
<li><a href="http://udhos.github.io/golang-concurrency-tricks/" target="_blank" rel="external">Golang Concurrency Tricks</a>:channel和goroutine技巧</li>
<li><a href="http://sanyuesha.com/2017/07/26/go-make-and-new/" target="_blank" rel="external">go make 和 new 的区别</a>: 区别</li>
<li><a href="https://dave.cheney.net/2017/08/20/context-isnt-for-cancellation" target="_blank" rel="external">Context isn’t for cancellation</a>: Context目的不是为了cancel</li>
<li><a href="https://blog.alexellis.io/inject-build-time-vars-golang/" target="_blank" rel="external">Inject build-time variables with Golang</a>:</li>
<li><a href="https://github.com/cristaloleg/go-advices" target="_blank" rel="external">go advices</a>: Go建议清单</li>
<li><a href="https://commandcenter.blogspot.com.au/2017/12/error-handling-in-upspin.html" target="_blank" rel="external">Error handling in Upspin</a>: Rob Pike的实践</li>
<li><a href="http://eagain.net/articles/go-dynamic-json/" target="_blank" rel="external">Dynamic JSON in Go</a>: 使用<code>*json.RawMessage</code> 和 <code>interface{}</code></li>
</ul>
<h2 id="开发技巧">开发技巧</h2>
<ul>
<li><a href="https://goenning.net/2017/01/25/adding-custom-data-go-binaries-compile-time/" target="_blank" rel="external">Adding custom data to Go binaries at compile time</a>: 编译时给二进制文件加点料</li>
<li><a href="https://stablekernel.com/go-quickstart-helpful-tips-for-experienced-programmers/" target="_blank" rel="external">Go Quickstart Tips for Experienced Programmers</a>: 给经验丰富的程序员的一些Go的小贴士</li>
<li><a href="http://guzalexander.com/2017/05/31/gracefully-exit-server-in-go.html" target="_blank" rel="external">Gracefully terminate a program in Go</a>:优雅滴关闭程序</li>
<li><a href="https://gocn.io/article/363" target="_blank" rel="external">Golang 中使用 JSON 的小技巧</a>: JSON使用的小技巧</li>
<li><a href="https://dave.cheney.net/2017/06/20/how-to-find-out-which-go-version-built-your-binary" target="_blank" rel="external">How to find out which Go version built your binary</a>: debug发现Go版本</li>
<li><a href="https://blog.kowalczyk.info/article/JyRZ/generating-good-random-and-unique-ids-in-go.html" target="_blank" rel="external">Generating good unique ids in Go</a>:产生唯一的ID</li>
<li><a href="https://emil.hessman.se/articles/fencing-off-go" target="_blank" rel="external">Fencing off Go Applied - A Practical Look at a Go Research Paper</a>: 使用 dingo-hunter 和 Gong 编译时检查死锁和channel</li>
<li><a href="https://github.com/campoy/go-tooling-workshop" target="_blank" rel="external">Go Tooling in Action</a>: Go开发时的一些工具介绍</li>
<li><a href="https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool" target="_blank" rel="external">How to use conditional compilation with the go build tool</a>:条件编译</li>
<li><a href="https://hackernoon.com/strace-in-60-lines-of-go-b4b76e3ecd64" target="_blank" rel="external">Strace in 60 lines of Go</a>: 实现strace</li>
<li><a href="https://blog.kowalczyk.info/article/1Bkr/3-ways-to-iterate-in-go.html" target="_blank" rel="external">3 ways to iterate in Go</a>:三种方式遍历</li>
<li><a href="https://golangweekly.com/issues/173" target="_blank" rel="external">RustGo: Calling Rust From Go with Little Overhead</a>:高效的从Go调用Rust</li>
<li><a href="https://medium.com/@theckman/version-constraints-and-go-c9309be15773" target="_blank" rel="external">Version Constraints and Go</a>:指定的Go版本才能编译</li>
<li><a href="https://medium.com/@Raedwulf/6-go-tips-you-should-probably-not-use-b252dfd0a3c4" target="_blank" rel="external">6 Go Tips You Should (probably not) Use</a>: 6个Go小技巧，但是你不应该在代码中使用， :)</li>
<li><a href="https://blog.thesparktree.com/15-lessons-in-golang" target="_blank" rel="external">15 Lessons in Golang</a>:15个经验教训</li>
<li><a href="https://www.calhoun.io/using-functional-options-instead-of-method-chaining-in-go/" target="_blank" rel="external">Using functional options instead of method chaining in Go</a>: 使用函数式参数，而不是链式操作</li>
<li><a href="https://my.oschina.net/linker/blog/1504199" target="_blank" rel="external">合理配置GOMAXPROCS提升一倍以上的性能</a>: 对于I/O密集型的程序，建议设置GOMAXPROCS大一些</li>
<li><a href="http://colobu.com/2017/06/27/Lint-your-golang-code-like-a-mad-man/" target="_blank" rel="external">Lint your #golang code like a mad man!</a>: 像牛人一样编写代码</li>
<li><a href="https://medium.com/@KevinHoffman/rate-limiting-service-calls-in-go-3771c6b7c146" target="_blank" rel="external">Rate Limiting Service Calls in Go</a>:限流</li>
<li><a href="http://www.blog.labouardy.com/sending-html-email-using-go/" target="_blank" rel="external">Sending HTML email using Go</a>:发送html邮件</li>
<li><a href="http://colobu.com/goasm/" target="_blank" rel="external">Go Assembly 示例</a>: Go使用汇编的例子</li>
<li><a href="https://gowebexamples.com" target="_blank" rel="external">go web examples</a>:web开发例子</li>
<li><a href="https://www.thepolyglotdeveloper.com/2017/10/handling-cors-golang-web-application/" target="_blank" rel="external">Handling CORS In A Golang Web Application</a>:CORS处理</li>
<li><a href="https://joeshaw.org/understanding-go-panic-output/" target="_blank" rel="external">Understanding Go panic output</a>: 理解Go的panic输出</li>
<li><a href="http://colobu.com/2017/11/29/event-loop-networking-in-Go/" target="_blank" rel="external">Go语言中实现基于 event-loop 网络处理</a>:不同的思路</li>
<li><a href="https://pocketgophers.com/go-structs-from-json/" target="_blank" rel="external">Generating Go structs from JSON</a>:5个json to gostruct的工具</li>
<li><a href="http://michaelyou.github.io/2017/12/05/go语言死循环分析%2f" target="_blank" rel="external">go语言死循环分析</a>:当然不是go的bug,看看go的<a href="https://github.com/golang/go/issues/15442" target="_blank" rel="external">讨论</a></li>
<li><a href="https://stackoverflow.com/questions/42664837/access-unexported-fields-in-golang-reflect" target="_blank" rel="external">Access unexported fields in golang/reflect</a>: 访问unexported的字段</li>
<li><a href="https://stackoverflow.com/questions/47992477/why-is-port-a-string-and-not-an-integer" target="_blank" rel="external">Why is port a string and not an integer</a>: <code>URL.Port</code>为什么是字符串而不是整数？</li>
<li><a href="https://stackoverflow.com/questions/47645808/golang-how-the-select-worked-when-multiple-channel-involved" target="_blank" rel="external">golang: How the select worked when multiple channel involved</a>:使用伪随机</li>
<li><a href="https://stackoverflow.com/questions/47625304/how-to-reuse-request-body-of-http-request-between-http-middleware-handlers" target="_blank" rel="external">How to reuse request body of *http.Request</a>: request.Body读完就不能再多了，如何重用？</li>
</ul>
<h2 id="面试题">面试题</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26972862" target="_blank" rel="external">golang 面试题</a>: 诺唯总结的11个面试题， <a href="https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html" target="_blank" rel="external">解答</a></li>
<li><a href="https://www.jianshu.com/p/f690203ff168" target="_blank" rel="external">Golang精编100题</a>:选择题和填空题，试试看</li>
</ul>
<h2 id="第三方库">第三方库</h2>
<ul>
<li><a href="https://blog.haardiek.org/infinite-sets-in-go.html" target="_blank" rel="external">Infinite Sets in Go</a>: 把set实现玩出花</li>
<li><a href="https://github.com/gostor/awesome-go-storage" target="_blank" rel="external">awesome-go-storage</a>: 100多个Go语言实现的存储引擎，强不强大？</li>
<li><a href="https://gowebexamples.com/" target="_blank" rel="external">Learn Web Programming in Go by Examples</a>: 类似gobyexamples,这次奉上的是关于web开发的</li>
<li><a href="https://divan.github.io/posts/go_concurrency_visualize/" target="_blank" rel="external">Visualizing Concurrency in Go</a>:可视化goroutine</li>
<li><a href="https://medium.com/@mdlayher/network-protocol-breakdown-ethernet-and-go-de985d726cc1" target="_blank" rel="external">Network Protocol Breakdown: Ethernet and Go</a>: 学习底层网络协议处理</li>
<li><a href="http://colobu.com/2017/08/04/talk-about-getting-goroutine-id-again/" target="_blank" rel="external">再谈谈获取 goroutine id 的方法</a>: goroutine ID的获得，hacker方式</li>
<li><a href="https://medium.com/@drgarcia1986/listen-grpc-and-http-requests-on-the-same-port-263c40cb45ff" target="_blank" rel="external">Listen gRPC and HTTP requests on the same port</a>: grpc和http共用端口</li>
<li><a href="https://grpc.io/2017/08/22/grpc-go-perf-improvements.html" target="_blank" rel="external">gRPC-Go performance Improvements</a>: gRPC近期的性能优化</li>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-1/" target="_blank" rel="external">Building Blockchain in Go</a>:使用Go编写区块链程序系列</li>
<li><a href="https://blog.gopheracademy.com/advent-2017/mphf/" target="_blank" rel="external">Minimal Perfect Hash Functions</a>:完美的hash函数，极小</li>
</ul>
<h2 id="应用">应用</h2>
<ul>
<li><a href="https://36kr.com/p/5073181.html" target="_blank" rel="external">今日头条Go建千亿级微服务的实践</a>: 今日头条的微服务</li>
</ul>
<h2 id="版本新特性">版本新特性</h2>
<ul>
<li><a href="https://hackernoon.com/5-things-to-watch-in-go-programming-in-2017-39cd7a7e58e3" target="_blank" rel="external">5 things to watch in Go programming in 2017</a>: G0 1.8新的特性介绍</li>
<li><a href="https://blog.gopheracademy.com/advent-2016/go-1.8/" target="_blank" rel="external">Go 1.8</a>: 2016最后一天写的，也算做2017年的文章吧 </li>
<li><a href="https://talks.golang.org/2017/state-of-go.slide" target="_blank" rel="external">The State of Go - February 2017</a>: 2017对Go的综评，来自Go团队</li>
<li><a href="https://www.slideshare.net/huazhihao1/what-is-new-in-go-18-72210978" target="_blank" rel="external">What is new in Go 1.8</a>: what&#39;s new?</li>
<li><a href="http://commaok.xyz/post/interface-allocs/" target="_blank" rel="external">Logging, interfaces, and allocation</a>: Go 1.9中的一点优化</li>
<li><a href="https://blog.golang.org/h2push" target="_blank" rel="external">HTTP/2 Server Push</a>: http2 push功能</li>
<li><a href="https://talks.golang.org/2017/state-of-go-may.slide#1" target="_blank" rel="external">The State of Go - May 2017</a>: The State of Go系列</li>
<li><a href="https://www.infoworld.com/article/3201037/application-development/whats-new-in-googles-go-language.html" target="_blank" rel="external">What’s new in Google’s Go 1.9</a>: what&#39;s new</li>
<li><a href="https://blog.golang.org/toward-go2" target="_blank" rel="external">Toward Go 2</a>: 目标Go2</li>
<li><a href="http://tonybai.com/2017/07/14/some-changes-in-go-1-9/" target="_blank" rel="external">Go 1.9中值得关注的几个变化</a>: what&#39;s new in go 1.9</li>
<li><a href="https://go-review.googlesource.com/c/go/+/34784" target="_blank" rel="external">improve timers scalability on multi-CPU systems</a>: go 1.10提升timer性能</li>
<li><a href="https://tip.golang.org/doc/go1.10" target="_blank" rel="external">Go 1.10 Release Notes</a>: go 1.10先睹为快</li>
<li><a href="https://zhuanlan.zhihu.com/p/31820378" target="_blank" rel="external">Golang 1.10 前瞻</a>: 新特性</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>马上就要进入2018年了，作为年终的盘点，本文列出了一些2017年的关于Go编程的一些文章，并加上简短的介绍。</p>
<p>文章排名不分先后， 文章也不一定完全按照日期来排列。我按照文章的大致内容分了类，便于查找。</p>
<p>文章主要从golangweekly、gocn每日新闻、medium、reddit、twitter、、知名博主的文章搜集而来。如果你发现好的2017年的Go文章没有列出来，欢迎在评论中粘帖出来，我会加入到文章正文中。</p>
<p>本文主要列出的是文章，2017年也涌现出来很多优秀的库和工具，但是不是本文要介绍的内容，所以没有列出来。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转][译]百万级WebSockets和Go语言]]></title>
    <link href="http://colobu.com/2017/12/13/A-Million-WebSockets-and-Go/"/>
    <id>http://colobu.com/2017/12/13/A-Million-WebSockets-and-Go/</id>
    <published>2017-12-13T09:05:07.000Z</published>
    <updated>2017-12-26T13:29:13.627Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://medium.freecodecamp.org/million-websockets-and-go-cc58418460bb" target="_blank" rel="external">A Million WebSockets and Go</a><br>作者: Sergey Kamardin</p>
<p>译文: <a href="http://xiecode.cn/post/cn_06_a_million_websockets_and_go/" target="_blank" rel="external">性能优化实战：百万级WebSockets和Go语言</a><br>译者: 曼托斯</p>
<a id="more"></a>
<p>大家好！我的名字叫Sergey Kamardin。我是来自Mail.Ru的一名工程师。这篇文章将讲述我们是如何用Go语言开发一个高负荷的WebSocket服务。即使你对WebSockets熟悉但对Go语言知之甚少，我还是希望这篇文章里讲到的性能优化的思路和技术对你有所启发。</p>
<h2 id="介绍">介绍</h2>
<p>作为全文的铺垫，我想先讲一下我们为什么要开发这个服务。</p>
<p>Mail.Ru有许多包含状态的系统。用户的电子邮件存储是其中之一。有很多办法来跟踪这些状态的改变。不外乎通过定期的轮询或者系统通知来得到状态的变化。这两种方法都有它们的优缺点。对邮件这个产品来说，让用户尽快收到新的邮件是一个考量指标。邮件的轮询会产生大概每秒5万个HTTP请求，其中60%的请求会返回304状态（表示邮箱没有变化）。因此，为了减少服务器的负荷并加速邮件的接收，我们决定重写一个publisher-subscriber服务（这个服务通常也会称作bus，message broker或者event-channel）。这个服务负责接收状态更新的通知，然后还处理对这些更新的订阅。</p>
<p>重写publisher-subscriber服务之前：</p>
<p><img src="1.png" alt=""></p>
<p>现在：<br><img src="2.png" alt=""></p>
<p>上面第一个图为旧的架构。浏览器（Browser）会定期轮询API服务来获得邮件存储服务（Storage）的更新。</p>
<p>第二张图展示的是新的架构。浏览器（Browser）和通知API服务（notificcation API）建立一个WebSocket连接。通知API服务会发送相关的订阅到Bus服务上。当收到新的电子邮件时，存储服务（Storage）向Bus（1）发送一个通知，Bus又将通知发送给相应的订阅者（2）。API服务为收到的通知找到相应的连接，然后把通知推送到用户的浏览器（3）。</p>
<p>我们今天就来讨论一下这个API服务（也可以叫做WebSocket服务）。在开始之前，我想提一下这个在线服务处理将近<strong>3百万个连接</strong>。</p>
<h2 id="惯用的做法（The_idiomatic_way）">惯用的做法（The idiomatic way）</h2>
<p>首先，我们看一下不做任何优化会如何用Go来实现这个服务的部分功能。在使用<code>net/http</code> 实现具体功能前，让我们先讨论下我们将如何发送和接收数据。这些数据是定义在WebSocket协议之上的（例如JSON对象）。我们在下文中会成他们为packet。</p>
<p>我们先来实现<code>Channel</code> 结构。它包含相应的逻辑来通过WebScoket连接发送和接收packet。</p>
<h3 id="Channel结构">Channel结构</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Packet represents application level data.</span></div><div class="line"><span class="keyword">type</span> Packet <span class="keyword">struct</span> {</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Channel wraps user connection.</span></div><div class="line"><span class="keyword">type</span> Channel <span class="keyword">struct</span> {</div><div class="line">    conn net.Conn    <span class="comment">// WebSocket connection.</span></div><div class="line">    send <span class="keyword">chan</span> Packet <span class="comment">// Outgoing packets queue.</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> NewChannel(conn net.Conn) *Channel {</div><div class="line">    c := &Channel{</div><div class="line">        conn: conn,</div><div class="line">        send: <span class="built_in">make</span>(<span class="keyword">chan</span> Packet, N),</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">go</span> c.reader()</div><div class="line">    <span class="keyword">go</span> c.writer()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> c</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我要强调的是读和写这两个goroutines。每个goroutine都需要各自的内存栈。栈的初始大小由操作系统和Go的版本决定，通常在2KB到8KB之间。我们之前提到有3百万个在线连接，如果每个goroutine栈需要4KB的话，所有连接就需要24GB的内存。这还没算上给<code>Channel</code> 结构，发送packet用的<code>ch.send</code> 和其它一些内部字段分配的内存空间。</p>
<h2 id="I/O_goroutines">I/O goroutines</h2>
<p>接下来看一下“reader”的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *Channel) reader() {</div><div class="line">    <span class="comment">// We make a buffered read to reduce read syscalls.</span></div><div class="line">    buf := bufio.NewReader(c.conn)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        pkt, _ := readPacket(buf)</div><div class="line">        c.handle(pkt)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们使用了bufio.Reader 。每次都会在buf 大小允许的范围内尽量读取多的字节，从而减少read() 系统调用的次数。在无限循环中，我们期望会接收到新的数据。请记住之前这句话：期望接收到新的数据。我们之后会讨论到这一点。</p>
<p>我们把packet的解析和处理逻辑都忽略掉了，因为它们和我们要讨论的优化不相关。不过buf 值得我们的关注：它的缺省大小是4KB。这意味着所有连接将消耗掉额外的12 GB内存。“writer”也是类似的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *Channel) writer() {</div><div class="line">    <span class="comment">// We make buffered write to reduce write syscalls. </span></div><div class="line">    buf := bufio.NewWriter(c.conn)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> pkt := <span class="keyword">range</span> c.send {</div><div class="line">        _ := writePacket(buf, pkt)</div><div class="line">        buf.Flush()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们在待发送packet的<code>c.send</code> channel上循环将packet写到缓存（buffer）里。细心的读者肯定已经发现，这又是额外的4KB内存。3百万个连接会占用<strong>12GB</strong>的内存。</p>
<h3 id="HTTP">HTTP</h3>
<p>我们已经有了一个简单的Channel 实现。现在我们需要一个WebSocket连接。因为还在<strong>通常做法</strong>（Idiomatic Way)的标题下，那么就先来看看通常是如何实现的。</p>
<blockquote>
<p>注：如果你不知道WebSocket是怎么工作的，那么这里值得一提的是客户端是通过一个叫升级（Upgrade）请求的特殊HTTP机制来建立WebSocket的。在成功处理升级请求以后，服务端和客户端使用TCP连接来交换二进制的WebSocket帧（frames）。这里有关于帧结构的描述。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"net/http"</span></div><div class="line">    <span class="string">"some/websocket"</span></div><div class="line">)</div><div class="line"></div><div class="line">http.HandleFunc(<span class="string">"/v1/ws"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    conn, _ := websocket.Upgrade(r, w)</div><div class="line">    ch := NewChannel(conn)</div><div class="line">    <span class="comment">//...</span></div><div class="line">})</div></pre></td></tr></table></figure>

<p>请注意这里的<code>http.ResponseWriter</code> 结构包含<code>bufio.Reader</code> 和<code>bufio.Writer</code> （各自分别包含4KB的缓存）。它们用于<code>*http.Request</code> 初始化和返回结果。</p>
<p>不管是哪个WebSocket，在成功回应一个升级请求之后，服务端在调用<code>responseWriter.Hijack()</code> 之后会接收到一个I/O缓存和对应的TCP连接。</p>
<blockquote>
<p>注：有时候我们可以通过<code>net/http.putBufio{Reader,Writer}</code> 调用把缓存释放回<code>net/http</code> 里的<code>sync.Pool</code> 。</p>
</blockquote>
<p>这样，这3百万个连接又需要额外的<strong>24GB</strong>内存。</p>
<p>所以，为了这个什么都不干的程序，我们已经占用了<strong>72GB</strong>的内存！</p>
<h2 id="优化">优化</h2>
<p>我们来回顾一下前面介绍的用户连接的工作流程。在建立WebSocket之后，客户端会发送请求订阅相关事件（我们这里忽略类似ping/pong 的请求）。接下来，在整个连接的生命周期里，客户端可能就不会发送任何其它数据了。</p>
<p>连接的生命周期可能会持续几秒钟到几天。</p>
<p>所以在大部分时间里，<code>Channel.reader()</code> 和<code>Channel.writer()</code> 都在等待接收和发送数据。与它们一起等待的是各自分配的4 KB的I/O缓存。</p>
<p>现在，我们发现有些地方是可以做进一步优化的，对吧？</p>
<h3 id="Netpoll">Netpoll</h3>
<p>你还记得<code>Channel.reader()</code> 的实现使用了<code>bufio.Reader.Read()</code> 吗？<code>bufio.Reader.Read()</code> 又会调用<code>conn.Read()</code> 。这个调用会被阻塞以等待接收连接上的新数据。如果连接上有新的数据，Go的运行环境（runtime）就会唤醒相应的goroutine让它去读取下一个packet。之后，goroutine会被再次阻塞来等待新的数据。我们来研究下Go的运行环境是怎么知道goroutine需要被唤醒的。</p>
<p>如果我们看一下<code>conn.Read()</code> 的实现，就会看到它调用了<code>net.netFD.Read()</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// net/fd_unix.go</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (fd *netFD) Read(p []<span class="typename">byte</span>) (n <span class="typename">int</span>, err error) {</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        n, err = syscall.Read(fd.sysfd, p)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            n =<span class="number"> 0</span></div><div class="line">            <span class="keyword">if</span> err == syscall.EAGAIN {</div><div class="line">                <span class="keyword">if</span> err = fd.pd.waitRead(); err == <span class="constant">nil</span> {</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">break</span></div><div class="line">    }</div><div class="line">    <span class="comment">//...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>Go使用了sockets的非阻塞模式。EAGAIN表示socket里没有数据了但不会阻塞在空的socket上，OS会把控制权返回给用户进程。</p>
</blockquote>
<p>这里它首先对连接文件描述符进行<code>read()</code> 系统调用。如果<code>read()</code> 返回的是<code>EAGAIN</code> 错误，运行环境就是调用<code>pollDesc.waitRead()</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// net/fd_poll_runtime.go</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> (pd *pollDesc) waitRead() error {</div><div class="line">   <span class="keyword">return</span> pd.wait(<span class="string">'r'</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (pd *pollDesc) wait(mode <span class="typename">int</span>) error {</div><div class="line">   res := runtime_pollWait(pd.runtimeCtx, mode)</div><div class="line">   <span class="comment">//...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果继续深挖，我们可以看到netpoll的实现在Linux里用的是epoll而在BSD里用的是kqueue。我们的这些连接为什么不采用类似的方式呢？只有在socket上有可读数据时，才分配缓存空间并启用读数据的goroutine。</p>
<p>在github.com/golang/go上，有一个关于 暴露(export) netpoll函数的<a href="https://github.com/golang/go/issues/15735#issuecomment-266574151" target="_blank" rel="external">请求</a>。</p>
<h3 id="干掉goroutines">干掉goroutines</h3>
<p>假设我们用Go语言实现了netpoll。我们现在可以避免创建Channel.reader() 的goroutine，取而代之的是从订阅连接里收到新数据的事件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ch := NewChannel(conn)</div><div class="line"></div><div class="line"><span class="comment">// Make conn to be observed by netpoll instance.</span></div><div class="line">poller.Start(conn, netpoll.EventRead, <span class="keyword">func</span>() {</div><div class="line">    <span class="comment">// We spawn goroutine here to prevent poller wait loop</span></div><div class="line">    <span class="comment">// to become locked during receiving packet from ch.</span></div><div class="line">    <span class="keyword">go</span> Receive(ch)</div><div class="line">})</div><div class="line"></div><div class="line"><span class="comment">// Receive reads a packet from conn and handles it somehow.</span></div><div class="line"><span class="keyword">func</span> (ch *Channel) Receive() {</div><div class="line">    buf := bufio.NewReader(ch.conn)</div><div class="line">    pkt := readPacket(buf)</div><div class="line">    c.handle(pkt)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>Channel.writer()</code> 相对容易一点，因为我们只需在发送packet的时候创建goroutine并分配缓存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (ch *Channel) Send(p Packet) {</div><div class="line">    <span class="keyword">if</span> c.noWriterYet() {</div><div class="line">        <span class="keyword">go</span> ch.writer()</div><div class="line">    }</div><div class="line">    ch.send &lt;- p</div><div class="line">}</div></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里我们没有处理<code>write()</code> 系统调用时返回的<code>EAGAIN</code> 。我们依赖Go运行环境去处理它。这种情况很少发生。如果需要的话我们还是可以像之前那样来处理。</p>
</blockquote>
<p>从<code>ch.send</code> 读取待发送的packets之后，<code>ch.writer()</code> 会完成它的操作，最后释放goroutine的栈和用于发送的缓存。</p>
<p>很不错！通过避免这两个连续运行的goroutine所占用的I/O缓存和栈内存，我们已经节省了<strong>48GB</strong>。</p>
<h3 id="控制资源">控制资源</h3>
<p>大量的连接不仅仅会造成大量的内存消耗。在开发服务端的时候，我们还不停地遇到竞争条件（race conditions）和死锁（deadlocks）。随之而来的是所谓的自我分布式阻断攻击（self-DDOS）。在这种情况下，客户端会悍然地尝试重新连接服务端而把情况搞得更加糟糕。</p>
<p>举个例子，如果因为某种原因我们突然无法处理ping/pong 消息，这些空闲连接就会不断地被关闭（它们会以为这些连接已经无效因此不会收到数据）。然后客户端每N秒就会以为失去了连接并尝试重新建立连接，而不是继续等待服务端发来的消息。</p>
<p>在这种情况下，比较好的办法是让负载过重的服务端停止接受新的连接，这样负载均衡器（例如nginx）就可以把请求转到其它的服务端上去。</p>
<p>撇开服务端的负载不说，如果所有的客户端突然（很可能是因为某个bug）向服务端发送一个packet，我们之前节省的48 GB内存又将会被消耗掉。因为这时我们又会和开始一样给每个连接创建goroutine并分配缓存。</p>
<h4 id="Goroutine池">Goroutine池</h4>
<p>可以用一个goroutine池来限制同时处理packets的数目。下面的代码是一个简单的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> gopool</div><div class="line"></div><div class="line"><span class="keyword">func</span> New(size <span class="typename">int</span>) *Pool {</div><div class="line">    <span class="keyword">return</span> &Pool{</div><div class="line">        work: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">func</span>()),</div><div class="line">        sem:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, size),</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Pool) Schedule(task <span class="keyword">func</span>()) error {</div><div class="line">    <span class="keyword">select</span> {</div><div class="line">    <span class="keyword">case</span> p.work &lt;- task:</div><div class="line">    <span class="keyword">case</span> p.sem &lt;- <span class="keyword">struct</span>{}{}:</div><div class="line">        <span class="keyword">go</span> p.worker(task)</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (p *Pool) worker(task <span class="keyword">func</span>()) {</div><div class="line">    <span class="keyword">defer</span> <span class="keyword">func</span>() { &lt;-p.sem }</div><div class="line">    <span class="keyword">for</span> {</div><div class="line">        task()</div><div class="line">        task = &lt;-p.work</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们使用netpoll的代码就变成下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pool := gopool.New<span class="number">(128</span>)</div><div class="line"></div><div class="line">poller.Start(conn, netpoll.EventRead, <span class="keyword">func</span>() {</div><div class="line">    <span class="comment">// We will block poller wait loop when</span></div><div class="line">    <span class="comment">// all pool workers are busy.</span></div><div class="line">    pool.Schedule(<span class="keyword">func</span>() {</div><div class="line">        Receive(ch)</div><div class="line">    })</div><div class="line">})</div></pre></td></tr></table></figure>

<p>现在我们不仅要等可读的数据出现在socket上才能读packet，还必须等到从池里获取到空闲的goroutine。</p>
<p>同样的，我们修改下Send() 的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pool := gopool.New<span class="number">(128</span>)</div><div class="line"></div><div class="line"><span class="keyword">func</span> (ch *Channel) Send(p Packet) {</div><div class="line">    <span class="keyword">if</span> c.noWriterYet() {</div><div class="line">        pool.Schedule(ch.writer)</div><div class="line">    }</div><div class="line">    ch.send &lt;- p</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里我们没有调用<code>go ch.writer()</code> ，而是想重复利用池里goroutine来发送数据。 所以，如果一个池有<code>N</code> 个goroutines的话，我们可以保证有<code>N</code> 个请求被同时处理。而<code>N + 1</code> 个请求不会分配<code>N + 1</code> 个缓存。goroutine池允许我们限制对新连接的<code>Accept()</code> 和<code>Upgrade()</code> ，这样就避免了大部分DDoS的情况。</p>
<h3 id="零拷贝升级（Zero-copy_upgrade）">零拷贝升级（Zero-copy upgrade）</h3>
<p>之前已经提到，客户端通过HTTP升级（Upgrade）请求切换到WebSocket协议。下面显示的是一个升级请求：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /ws HTTP<span class="number">/1.1</span></div><div class="line">Host: mail.ru</div><div class="line">Connection: Upgrade</div><div class="line">Sec-Websocket-Key: A3xNe7sEB9HixkmBhVrYaA==</div><div class="line">Sec-Websocket-Version:<span class="number"> 13</span></div><div class="line">Upgrade: websocket</div><div class="line"></div><div class="line">HTTP<span class="number">/1.1</span><span class="number"> 101</span> Switching Protocols</div><div class="line">Connection: Upgrade</div><div class="line">Sec-Websocket-Accept: ksu0wXWG+YmkVx+KQR2agP0cQn4=</div><div class="line">Upgrade: websocket</div></pre></td></tr></table></figure>

<p>我们接收HTTP请求和它的头部只是为了切换到WebSocket协议，而<code>http.Request</code> 里保存了所有头部的数据。从这里可以得到启发，如果是为了优化，我们可以放弃使用标准的<code>net/http</code> 服务并在处理HTTP请求的时候避免无用的内存分配和拷贝。</p>
<blockquote>
<p>举个例子，<code>http.Request</code> 包含了一个叫做Header的字段。标准<code>net/http</code> 服务会将请求里的所有头部数据全部无条件地拷贝到Header字段里。你可以想象这个字段会保存许多冗余的数据，例如一个包含很长cookie的头部。</p>
</blockquote>
<p>我们如何来优化呢？</p>
<h4 id="WebSocket实现">WebSocket实现</h4>
<p>不幸的是，在我们优化服务端的时候所有能找到的库只支持对标准net/http 服务做升级。而且没有一个库允许我们实现上面提到的读和写的优化。为了使这些优化成为可能，我们必须有一套底层的API来操作WebSocket。为了重用缓存，我们需要类似下面这样的协议函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ReadFrame(io.Reader) (Frame, error)</div><div class="line"><span class="keyword">func</span> WriteFrame(io.Writer, Frame) error</div></pre></td></tr></table></figure>

<p>如果我们有一个包含这样API的库，我们就按照下面的方式从连接上读取packets：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getReadBuf, putReadBuf are intended to</span></div><div class="line"><span class="comment">// reuse *bufio.Reader (with sync.Pool for example).</span></div><div class="line"><span class="keyword">func</span> getReadBuf(io.Reader) *bufio.Reader</div><div class="line"><span class="keyword">func</span> putReadBuf(*bufio.Reader)</div><div class="line"></div><div class="line"><span class="comment">// readPacket must be called when data could be read from conn.</span></div><div class="line"><span class="keyword">func</span> readPacket(conn io.Reader) error {</div><div class="line">    buf := getReadBuf()</div><div class="line">    <span class="keyword">defer</span> putReadBuf(buf)</div><div class="line"></div><div class="line">    buf.Reset(conn)</div><div class="line">    frame, _ := ReadFrame(buf)</div><div class="line">    parsePacket(frame.Payload)</div><div class="line">    <span class="comment">//...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>简而言之，我们需要自己写一个库。</p>
<h4 id="github-com/gobwas/ws">github.com/gobwas/ws</h4>
<p>ws 库的主要设计思想是不将协议的操作逻辑暴露给用户。所有读写函数都接受通用的<code>io.Reader</code> 和<code>io.Writer</code> 接口。因此它可以随意搭配是否使用缓存以及其它I/O的库。</p>
<p>除了标准库<code>net/http</code> 里的升级请求，<code>ws</code> 还支持零拷贝升级。它能够处理升级请求并切换到WebSocket模式而不产生任何内存分配或者拷贝。<code>ws.Upgrade()</code> 接受<code>io.ReadWriter</code> （<code>net.Conn</code> 实现了这个接口）。换句话说，我们可以使用标准的<code>net.Listen()</code> 函数然后把从<code>ln.Accept()</code> 收到的连接马上交给<code>ws.Upgrade()</code> 去处理。库也允许拷贝任何请求数据来满足将来应用的需求（举个例子，拷贝Cookie 来验证一个session）。</p>
<p>下面是处理升级请求的性能测试：标准<code>net/http</code> 库的实现和使用零拷贝升级的<code>net.Listen()</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BenchmarkUpgradeHTTP   <span class="number"> 5156</span> ns/op   <span class="number"> 8576</span> B/op   <span class="number"> 9</span> allocs/op</div><div class="line">BenchmarkUpgradeTCP    <span class="number"> 973</span> ns/op    <span class="number"> 0</span> B/op      <span class="number"> 0</span> allocs/op</div></pre></td></tr></table></figure>

<p>使用ws 以及零拷贝升级为我们节省了24 GB的空间。这些空间原本被用做net/http 里处理请求的I/O缓存。</p>
<h3 id="回顾">回顾</h3>
<p>让我们来回顾一下之前提到过的优化：</p>
<ul>
<li>一个包含缓存的读goroutine会占用很多内存。方案： netpoll（epoll, kqueue）；重用缓存。</li>
<li>一个包含缓存的写goroutine会占用很多内存。方案： 在需要的时候创建goroutine；重用缓存。</li>
<li>存在大量连接请求的时候，netpoll不能很好工作。方案： 重用goroutines并且限制它们的数目。</li>
<li>net/http 对升级到WebSocket请求的处理不是最高效的。方案： 在TCP连接上实现零拷贝升级。</li>
</ul>
<p>下面是服务端的大致实现代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"net"</span></div><div class="line">    <span class="string">"github.com/gobwas/ws"</span></div><div class="line">)</div><div class="line"></div><div class="line">ln, _ := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8080"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> {</div><div class="line">    <span class="comment">// Try to accept incoming connection inside free pool worker.</span></div><div class="line">    <span class="comment">// If there no free workers for 1ms, do not accept anything and try later.</span></div><div class="line">    <span class="comment">// This will help us to prevent many self-ddos or out of resource limit cases.</span></div><div class="line">    err := pool.ScheduleTimeout(time.Millisecond, <span class="keyword">func</span>() {</div><div class="line">        conn := ln.Accept()</div><div class="line">        _ = ws.Upgrade(conn)</div><div class="line"></div><div class="line">        <span class="comment">// Wrap WebSocket connection with our Channel struct.</span></div><div class="line">        <span class="comment">// This will help us to handle/send our app's packets.</span></div><div class="line">        ch := NewChannel(conn)</div><div class="line"></div><div class="line">        <span class="comment">// Wait for incoming bytes from connection.</span></div><div class="line">        poller.Start(conn, netpoll.EventRead, <span class="keyword">func</span>() {</div><div class="line">            <span class="comment">// Do not cross the resource limits.</span></div><div class="line">            pool.Schedule(<span class="keyword">func</span>() {</div><div class="line">                <span class="comment">// Read and handle incoming packet(s).</span></div><div class="line">                ch.Recevie()</div><div class="line">            })</div><div class="line">        })</div><div class="line">    })</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {   </div><div class="line">        time.Sleep(time.Millisecond)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="结论">结论</h2>
<blockquote>
<p>在程序设计时，过早优化是万恶之源。Donald Knuth</p>
</blockquote>
<p>上面的优化是有意义的，但不是所有情况都适用。举个例子，如果空闲资源（内存，CPU）与在线连接数之间的比例很高的话，优化就没有太多意义。当然，知道什么地方可以优化以及如何优化总是有帮助的。</p>
<p>谢谢你的关注！</p>
<h2 id="引用">引用</h2>
<ul>
<li><a href="https://github.com/mailru/easygo" target="_blank" rel="external">https://github.com/mailru/easygo</a></li>
<li><a href="https://github.com/gobwas/ws" target="_blank" rel="external">https://github.com/gobwas/ws</a></li>
<li><a href="https://github.com/gobwas/ws-examples" target="_blank" rel="external">https://github.com/gobwas/ws-examples</a></li>
<li><a href="https://github.com/gobwas/httphead" target="_blank" rel="external">https://github.com/gobwas/httphead</a></li>
</ul>
<p><hr><br>以下非译文中的内容，我也是看到优化的数字而感到疑惑：</p>
<blockquote>
<p>作者最后计算优化一共节省了 <code>48GB + 24GB</code>内存， 可以原先作者总共的内存占用为<code>24GB+12GB+12GB_24GB</code>,如果按照这个数计算，作者最后只需要零内存，这是不可能的，因为每个连接的协议栈会占用一部分内存， 每个goroutine的栈也会占用一部分内存，还有buffer需要一定量的内存。</p>
</blockquote>
<p>实际作者在评论中说， 原先每个连接平均占用 <strong>65KB</strong>的内存， 优化后只占<strong>10KB</strong>的内存，优化效果明显。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://medium.freecodecamp.org/million-websockets-and-go-cc58418460bb" target="_blank" rel="external">A Million WebSockets and Go</a><br>作者: Sergey Kamardin</p>
<p>译文: <a href="http://xiecode.cn/post/cn_06_a_million_websockets_and_go/" target="_blank" rel="external">性能优化实战：百万级WebSockets和Go语言</a><br>译者: 曼托斯</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转][译]Go 终极指南：编写一个 Go 工具]]></title>
    <link href="http://colobu.com/2017/12/12/The-ultimate-guide-to-writing-a-Go-tool/"/>
    <id>http://colobu.com/2017/12/12/The-ultimate-guide-to-writing-a-Go-tool/</id>
    <published>2017-12-12T06:52:23.000Z</published>
    <updated>2017-12-14T14:34:36.895Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/" target="_blank" rel="external">https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/</a><br>作者：Fatih Arslan<br>译文：<a href="http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/" target="_blank" rel="external">http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/</a><br>译者：oopsguy.com</p>
<a id="more"></a>
<p>我之前编写过一个叫 gomodifytags 的工具，它使我的生活变得很轻松。它会根据字段名称自动填充结构体标签字段。让我来展示一下它的功能：</p>
<p><img src="gomodifytags.gif" alt="An example usage of gomodifytags used within vim-go"></p>
<p>使用这样的工具可以<strong>很容易管理</strong>结构体的多个字段。该工具还可以添加和删除标签、管理标签选项（如 omitempty）、定义转换规则（snake_case、camelCase 等）等。但该工具是怎样工作的呢？它内部使用了什么 Go 包？有很多问题需要回答。</p>
<p>这是一篇非常长的博文，其解释了如何编写这样的工具以及每个构建细节。它包含许多独特的细节、技巧和未知的 Go 知识。</p>
<p>拿起一杯咖啡☕️，让我们深入一下吧！</p>
<hr>

<p>首先，让我列出这个工具需要做的事情：</p>
<ul>
<li>它需要读取源文件、理解并能够解析 Go 文件</li>
<li>它需要找到相关的结构体</li>
<li>找到结构体后，它需要获取字段名称</li>
<li>它需要根据字段名来更新结构体标签（根据转换规则，如 _snake<em>case</em>）</li>
<li>它需要能够把这些更改更新到文件中，或者能够以可消费的方式输出更改后的结果</li>
</ul>
<p>我们首先来了解什么是 <strong>结构体（struct）标签（tag）</strong>，从这里我们可以学习到所有东西以及如何把它们组合在一起使用，在此基础上您可以构建出这样的工具。</p>
<p><img src="gomodifytags-009.jpg" alt=""></p>
<p>结构体的标签值（内容，如 <code>json: &quot;foo&quot;</code>）<strong>不是官方规范的一部分</strong>，但是 <code>reflect</code> 包定义了一个非官方规范的格式标准，这个格式同样被 <code>stdlib</code> 包（如 <code>encoding/json</code>）所使用。它通过 <code>reflect.StructTag</code> 类型定义：</p>
<p><img src="gomodifytags-014.jpg" alt=""></p>
<p>这个定义有点长，不是很容易让人理解。我们尝试分解一下它：</p>
<ul>
<li>一个结构体标签是一个字符串文字（因为它有字符串类型）</li>
<li>键（key）部分是一个<strong>无引号</strong>的字符串文字</li>
<li>值（value）部分是<strong>带引号</strong>的字符串文字</li>
<li>键和值由冒号（:)分隔。键与值且由冒号分隔组成的值称为<strong>键值对</strong></li>
<li>结构体标签可以包含多个键值对（可选）。键值对由<strong>空格分隔</strong>。</li>
<li>不是定义的部分是选项设置。像 <code>encoding/json</code> 这样的包在读取值时当作一个由逗号分隔列表。 第一个逗号后的内容都是选项部分，比如 <code>foo,omitempty,string</code>。其有一个名为 <code>foo</code> 的值和 <code>[omitempty, string]</code> 选项</li>
<li>因为结构体标签是字符串文字，所以需要使用双引号或反引号包围。因为值必须使用引号，因此我们总是使用反引号对整个标签做处理。</li>
</ul>
<p>总结一下：<br><img src="gomodifytags-027.jpg" alt="结构体标签定义有许多隐藏的细节"></p>
<p>我们已经了解了什么是结构体标签，我们可以根据需要轻松地修改它。 现在的问题是，我们如何解析它才能使我们能够轻松进行修改？幸运的是，<code>reflect.StructTag</code> 包含一个<code>方法</code>，它允许我们进行解析并返回指定键的值。以下是一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"reflect"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    tag := reflect.StructTag(<span class="string">`species:"gopher" color:"blue"`</span>)</div><div class="line">    fmt.Println(tag.Get(<span class="string">"color"</span>), tag.Get(<span class="string">"species"</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blue gopher</div></pre></td></tr></table></figure>

<p>如果键不存在，则返回一个空字符串。</p>
<p>这是非常有用，<strong>但是</strong>也有一些不足使得它并不适合我们，因为我们需要更多的灵活性：</p>
<ul>
<li>它无法检测到标签是否<strong>格式错误</strong>（如：键部分用引号包裹，值部分没有使用引号等）。</li>
<li>它无法得知选项的<strong>语义</strong>。</li>
<li>它<strong>没有办法迭代现有的标签</strong>或返回它们。我们必须要知道要修改哪些标签。如果不知道名字怎么办？</li>
<li>修改现有标签是不可能的。</li>
<li>我们<strong>不能从头开始构建新的结构体标签</strong>。</li>
</ul>
<p>为了改进这一点，我写了一个自定义的 Go 包，它解决了上面提到的所有问题，并提供了一个 API，可以轻松地改变结构体标签的各个方面。</p>
<p><img src="gomodifytags-091.jpg" alt=""></p>
<p>该包名为 <strong>structtag</strong>，可以从 github.com/fatih/structtag 获取。 这个包允许我们以简洁的方式解析和修改标签。以下是一个完整的示例，您可以复制/粘贴并自行尝试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line"></div><div class="line">    <span class="string">"github.com/fatih/structtag"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    tag := <span class="string">`json:"foo,omitempty,string" xml:"foo"`</span></div><div class="line"></div><div class="line">    <span class="comment">// parse the tag</span></div><div class="line">    tags, err := structtag.Parse(<span class="typename">string</span>(tag))</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// iterate over all tags</span></div><div class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tags.Tags() {</div><div class="line">        fmt.Printf(<span class="string">"tag: %+v\n"</span>, t)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// get a single tag</span></div><div class="line">    jsonTag, err := tags.Get(<span class="string">"json"</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// change existing tag</span></div><div class="line">    jsonTag.Name = <span class="string">"foo_bar"</span></div><div class="line">    jsonTag.Options = <span class="constant">nil</span></div><div class="line">    tags.Set(jsonTag)</div><div class="line"></div><div class="line">    <span class="comment">// add new tag</span></div><div class="line">    tags.Set(&structtag.Tag{</div><div class="line">        Key:     <span class="string">"hcl"</span>,</div><div class="line">        Name:    <span class="string">"foo"</span>,</div><div class="line">        Options: []<span class="typename">string</span>{<span class="string">"squash"</span>},</div><div class="line">    })</div><div class="line"></div><div class="line">    <span class="comment">// print the tags</span></div><div class="line">    fmt.Println(tags) <span class="comment">// Output: json:"foo_bar" xml:"foo" hcl:"foo,squash"</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在我们了解了如何解析、修改或创建结构体标签，是时候尝试修改一个 Go 源文件了。在上面的示例中，标签已经存在，但是如何从现有的 Go 结构体中获取标签呢？</p>
<p>答案是通过 <strong>AST</strong>。AST（Abstract Syntax Tree，抽象语法树）允许我们从源代码中检索每个标识符（节点）。 下面你可以看到一个结构体类型的 AST（简化版）：</p>
<p><img src="gomodifytags-0721.jpg" alt=""></p>
<p>在这棵树中，我们可以检索和操作每个标识符、每个字符串、每个括号等。这些都由 <a href="https://golang.org/pkg/go/ast/#Node" target="_blank" rel="external">AST 节点</a>表示。例如，我们可以通过替换表示它的节点将字段名称从 <code>Foo</code> 更改为 <code>Bar</code>。 该逻辑同样适用于结构体标签。</p>
<p>要获得一个 <strong>Go AST</strong>，我们需要解析源文件并将其转换成一个 <strong>AST</strong>。实际上，这两者都是通过同一个步骤来处理的。</p>
<p>要实现这一点，我们将使用 <code>go/parser</code> 包来解析文件以获取 AST（整个文件），然后使用 <code>go/ast</code> 包来处理整个树（我们可以手动做这个工作，但这是另一篇博文的主题）。 您在下面可以看到一个完整的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"go/ast"</span></div><div class="line">    <span class="string">"go/parser"</span></div><div class="line">    <span class="string">"go/token"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    src := <span class="string">`package main</span></div><div class="line">        type Example struct {</div><div class="line">    Foo string` + <span class="string">" `json:\"foo\"` }"</span></div><div class="line"></div><div class="line">    fset := token.NewFileSet()</div><div class="line">    file, err := parser.ParseFile(fset, <span class="string">"demo"</span>, src, parser.ParseComments)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="built_in">panic</span>(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    ast.Inspect(file, <span class="keyword">func</span>(x ast.Node) <span class="typename">bool</span> {</div><div class="line">        s, ok := x.(*ast.StructType)</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">for</span> _, field := <span class="keyword">range</span> s.Fields.List {</div><div class="line">            fmt.Printf(<span class="string">"Field: %s\n"</span>, field.Names<span class="number">[0</span>].Name)</div><div class="line">            fmt.Printf(<span class="string">"Tag:   %s\n"</span>, field.Tag.Value)</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="constant">false</span></div><div class="line">    })</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Field</span>: <span class="string">Foo</span></div><div class="line"><span class="attribute">Tag</span>: <span class="string">  `json:"foo"`</span></div></pre></td></tr></table></figure>

<p>代码执行以下操作：</p>
<ul>
<li>我们使用一个单独的结构体定义了一个 Go 包示例</li>
<li>我们使用 <code>go/parser</code> 包来解析这个字符串。<code>parser</code> 包也可以从磁盘读取文件（或整个包）。</li>
<li>在解析后，我们处理了节点（分配给变量文件）并查找由 <a href="https://golang.org/pkg/go/ast/#StructType" target="_blank" rel="external">*ast.StructType</a> 定义的 AST 节点（参考 AST 图）。通过 <code>ast.Inspect()</code> 函数完成树的处理。它会遍历所有节点，直到它收到 false 值。 这是非常方便的，因为它不需要知道每个节点。</li>
<li>我们打印了结构体的字段名称和结构体标签。</li>
</ul>
<hr>

<p>我们现在可以做两件重要的事，首先，我们知道了如何解析一个 Go 源文件并检索结构体标签（通过 <code>go/parser</code>）。其次，我们知道了如何解析 Go 结构体标签，并根据需要进行修改（通过 <code>github.com/fatih/structtag</code>）。</p>
<p>我们有了这些，现在可以通过使用这两个知识点开始构建我们的工具（命名为 gomodifytags）。该工具应按顺序执行以下操作</p>
<ul>
<li>获取配置，用于告诉我们要修改哪个结构体</li>
<li>根据配置查找和修改结构体</li>
<li>输出结果</li>
</ul>
<p>由于 gomodifytags 将主要应用于编辑器，我们将通过 CLI 标志传入配置。第二步包含多个步骤，如解析文件，找到正确的结构体，然后修改结构体（通过修改 AST）。最后，我们将结果输出，无论结果的格式是原始的 Go 源文件还是某种自定义协议（如 JSON，稍后再说）。</p>
<p>以下是简化版 gomodifytags 的主要功能：</p>
<p><img src="gomodifytags-101-e1503693113141.jpg" alt=""></p>
<p>让我们更详细地解释每一个步骤。为了简单起见，我将尝试以概括的形式来解释重要部分。 原理都一样，一旦你读完这篇博文，你将能够在没有任何指导情况下阅整个源码（指南末尾附带了所有资源）</p>
<p>让我们从第一步开始，了解如何<strong>获取配置</strong>。以下是我们的配置，包含所有必要的信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> config <span class="keyword">struct</span> {</div><div class="line">    <span class="comment">// first section - input & output</span></div><div class="line">    file     <span class="typename">string</span></div><div class="line">    modified io.Reader</div><div class="line">    output   <span class="typename">string</span></div><div class="line">    write    <span class="typename">bool</span></div><div class="line"></div><div class="line">    <span class="comment">// second section - struct selection</span></div><div class="line">    offset     <span class="typename">int</span></div><div class="line">    structName <span class="typename">string</span></div><div class="line">    line       <span class="typename">string</span></div><div class="line">    start, end <span class="typename">int</span></div><div class="line"></div><div class="line">    <span class="comment">// third section - struct modification</span></div><div class="line">    remove    []<span class="typename">string</span></div><div class="line">    add       []<span class="typename">string</span></div><div class="line">    override  <span class="typename">bool</span></div><div class="line">    transform <span class="typename">string</span></div><div class="line">    sort      <span class="typename">bool</span></div><div class="line">    clear     <span class="typename">bool</span></div><div class="line">    addOpts    []<span class="typename">string</span></div><div class="line">    removeOpts []<span class="typename">string</span></div><div class="line">    clearOpt   <span class="typename">bool</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它分为三个主要部分：</p>
<p><strong>第一部分</strong>包含有关如何读取和读取哪个文件的设置。这可以是本地文件系统的文件名，也可以直接来自 stdin（主要用在编辑器中）。 它还设置如何输出结果（go 源文件或 JSON），以及是否应该覆盖文件而不是输出到 stdout。</p>
<p><strong>第二部分</strong>定义了如何选择一个结构体及其字段。有多种方法可以做到这一点。 我们可以通过它的偏移（光标位置）、结构体名称、一行单行（仅选择字段）或一系列行来定义它。最后，我们无论如何都得到开始行/结束行。例如在下面的例子中，您可以看到，我们使用它的名字来选择结构体，然后提取开始行和结束行以选择正确的字段：<br><img src="gomodifytags-128.jpg" alt=""></p>
<p>如果是用于编辑器，则最好使用<strong>字节偏移量</strong>。例如下面你可以发现我们的光标刚好在 <code>port</code> 字段名称后面，从那里我们可以很容易地得到开始行/结束行：</p>
<p><img src="gomodifytags-130.jpg" alt=""></p>
<p>配置中的第三个部分实际上是一个映射到 <code>structtag</code> 包的一对一映射。它基本上允许我们在读取字段后将配置传给 <code>structtag</code> 包。 如你所知，<code>structtag</code> 包允许我们解析一个结构体标签并对各个部分进行修改。但它不会覆盖或更新结构体字段。</p>
<p>我们如何获得配置？我们只需使用 <code>flag</code> 包，然后为配置中的每个字段创建一个标志，然后分配它们。举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">flagFile := flag.String(<span class="string">"file"</span>, <span class="string">""</span>, <span class="string">"Filename to be parsed"</span>)</div><div class="line">cfg := &config{</div><div class="line">	file: *flagFile,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们对<strong>配置中的每个字段</strong>执行相同操作。有关完整内容，请查看 <code>gomodifytag</code> 当前 master 分支的标志定义</p>
<p>一旦我们有了配置，就可以做些基本的验证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    cfg := config{ ... }</div><div class="line"></div><div class="line">    err := cfg.validate()</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        log.Fatalln(err)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// continue parsing</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// validate validates whether the config is valid or not</span></div><div class="line"><span class="keyword">func</span> (c *config) validate() error {</div><div class="line">    <span class="keyword">if</span> c.file == <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"no file is passed"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> c.line == <span class="string">""</span> && c.offset ==<span class="number"> 0</span> && c.structName == <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"-line, -offset or -struct is not passed"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> c.line != <span class="string">""</span> && c.offset !=<span class="number"> 0</span> ||</div><div class="line">        c.line != <span class="string">""</span> && c.structName != <span class="string">""</span> ||</div><div class="line">        c.offset !=<span class="number"> 0</span> && c.structName != <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"-line, -offset or -struct cannot be used together. pick one"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (c.add == <span class="constant">nil</span> || <span class="built_in">len</span>(c.add) ==<span class="number"> 0</span>) &&</div><div class="line">        (c.addOptions == <span class="constant">nil</span> || <span class="built_in">len</span>(c.addOptions) ==<span class="number"> 0</span>) &&</div><div class="line">        !c.clear &&</div><div class="line">        !c.clearOption &&</div><div class="line">        (c.removeOptions == <span class="constant">nil</span> || <span class="built_in">len</span>(c.removeOptions) ==<span class="number"> 0</span>) &&</div><div class="line">        (c.remove == <span class="constant">nil</span> || <span class="built_in">len</span>(c.remove) ==<span class="number"> 0</span>) {</div><div class="line">        <span class="keyword">return</span> errors.New(<span class="string">"one of "</span> +</div><div class="line">            <span class="string">"[-add-tags, -add-options, -remove-tags, -remove-options, -clear-tags, -clear-options]"</span> +</div><div class="line">            <span class="string">" should be defined"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>将验证部分放置在一个单独的函数中，以便测试。<br>现在我们了解了如何获取配置并进行验证，我们继续解析文件：<br><img src="gomodifytags-111.jpg" alt=""></p>
<p>我们已经开始讨论如何解析文件了。这里的解析是 <code>config</code> 结构体的一个方法。实际上，所有的方法都是 <code>config</code> 结构体的一部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    cfg := config{}</div><div class="line"></div><div class="line">    node, err := cfg.parse()</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// continue find struct selection ...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (c *config) parse() (ast.Node, error) {</div><div class="line">    c.fset = token.NewFileSet()</div><div class="line">    <span class="keyword">var</span> contents <span class="keyword">interface</span>{}</div><div class="line">    <span class="keyword">if</span> c.modified != <span class="constant">nil</span> {</div><div class="line">        archive, err := buildutil.ParseOverlayArchive(c.modified)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"failed to parse -modified archive: %v"</span>, err)</div><div class="line">        }</div><div class="line">        fc, ok := archive[c.file]</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">nil</span>, fmt.Errorf(<span class="string">"couldn't find %s in archive"</span>, c.file)</div><div class="line">        }</div><div class="line">        contents = fc</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> parser.ParseFile(c.fset, c.file, contents, parser.ParseComments)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>parse</strong> 函数只做一件事：解析源代码并返回一个 <code>ast.Node</code>。如果我们传入的是文件，那就非常简单了，在这种情况下，我们使用 <code>parser.ParseFile()</code> 函数。需要注意的是 <code>token.NewFileSet()</code>，它创建一个 <code>*token.FileSet</code> 类型。我们将它存储在 <code>c.fset</code> 中，同时也传给了 <code>parser.ParseFile()</code> 函数。为什么呢？</p>
<p>因为 <code>fileset</code> 用于为每个文件<strong>单独</strong>存储每个节点的位置信息。这在以后非常有用，可以用于获得 <code>ast.Node</code> 的确切位置（请注意，<code>ast.Node</code> 使用了一个压缩了的位置信息 <code>token.Pos</code>。要获取更多的信息，它需要通过 <code>token.FileSet.Position()</code> 函数来获取一个 <code>token.Position</code>，其包含更多的信息）</p>
<p>让我们继续。如果通过 <code>stdin</code> 传递源文件，那么这更加有趣。<code>config.modified</code> 字段是一个易于测试的 <code>io.Reader</code>，但实际上我们传递的是 <code>stdin</code>。我们如何检测是否需要从 <code>stdin</code> 读取呢？</p>
<p>我们询问用户是否想通过 <code>stdin</code> 传递内容。这种情况下，工具用户需要传递 <code>--modified</code> 标志（这是一个<strong>布尔</strong>标志）。如果用户了传递它，我们只需将 <code>stdin</code> 分配给 <code>c.modified</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">flagModified = flag.Bool(<span class="string">"modified"</span>, <span class="constant">false</span>,</div><div class="line">    <span class="string">"read an archive of modified files from standard input"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> *flagModified {</div><div class="line">    cfg.modified = os.Stdin</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果再次检查上面的 <code>config.parse()</code> 函数，您将发现我们检查是否已分配了 <code>.modified</code> 字段。因为 <code>stdin</code> 是一个任意的数据流，我们需要能够根据给定的协议进行解析。在这种情况下，我们假定存档包含以下内容：</p>
<ul>
<li>文件名，后接一行新行</li>
<li>文件大小（十进制），后接一行新行</li>
<li>文件的内容</li>
<li>因为我们知道文件大小，可以无障碍地解析文件内容。任何超出给定文件大小的部分，我们仅仅停止解析。</li>
</ul>
<p>此方法也被其他几个工具所使用（如 <code>guru</code>、<code>gogetdoc</code> 等），对编辑器来说非常有用。 因为这样可以让编辑器传递修改后的文件内容，而不会保存到文件系统中。因此命名为 <code>modified</code>。</p>
<p>现在我们有了自己的节点，让我们继续 “搜索结构体” 这一步：</p>
<p><img src="gomodifytags-118.jpg" alt=""></p>
<p>在 <code>main</code> 函数中，我们将使用从上一步解析得到的 <code>ast.Node</code> 调用 <code>findSelection()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// ... parse file and get ast.Node</span></div><div class="line"></div><div class="line">    start, end, err := cfg.findSelection(node)</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// continue rewriting the node with the start&end position</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>cfg.findSelection()</code> 函数根据配置返回结构体的开始位置和结束位置以告知我们如何选择一个结构体。它迭代给定节点，然后返回开始位置/结束位置（如上配置部分中所述）：</p>
<p><img src="gomodifytags-001.jpg" alt="查找步骤遍历所有节点，直到找到一个 *ast.StructType，并返回该文件的开始位置和结束位置"></p>
<p>但是怎么做呢？记住有三种模式。分别是<strong>行选择</strong>、<strong>偏移量</strong>和<strong>结构体名称</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// findSelection returns the start and end position of the fields that are</span></div><div class="line"><span class="comment">// suspect to change. It depends on the line, struct or offset selection.</span></div><div class="line"><span class="keyword">func</span> (c *config) findSelection(node ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    <span class="keyword">if</span> c.line != <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> c.lineSelection(node)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> c.offset !=<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> c.offsetSelection(node)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> c.structName != <span class="string">""</span> {</div><div class="line">        <span class="keyword">return</span> c.structSelection(node)</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, errors.New(<span class="string">"-line, -offset or -struct is not passed"</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>行选择</strong>是最简单的部分。这里我们只返回标志值本身。因此如果用户传入 <code>--line 3,50</code> 标志，函数将返回<code>(3, 50, nil)</code>。 它所做的就是拆分标志值并将其转换为整数（同样执行验证）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) lineSelection(file ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    <span class="keyword">var</span> err error</div><div class="line">    splitted := strings.Split(c.line, <span class="string">","</span>)</div><div class="line"></div><div class="line">    start, err := strconv.Atoi(splitted<span class="number">[0</span>])</div><div class="line">    <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, err</div><div class="line">    }</div><div class="line"></div><div class="line">    end := start</div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(splitted) ==<span class="number"> 2</span> {</div><div class="line">        end, err = strconv.Atoi(splitted<span class="number">[1</span>])</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, err</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> start &gt; end {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, errors.New(<span class="string">"wrong range. start line cannot be larger than end line"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> start, end, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>当您选中一组行并高亮它们时，编辑器将使用此模式。</p>
<p><strong>偏移量</strong>和<strong>结构体名称</strong>选择需要做更多的工作。 对于这些，我们首先需要收集所有给定的结构体，以便可以计算偏移位置或搜索结构体名称。为此，我们首先要有一个收集所有结构体的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// collectStructs collects and maps structType nodes to their positions</span></div><div class="line"><span class="keyword">func</span> collectStructs(node ast.Node) <span class="keyword">map</span>[token.Pos]*structType {</div><div class="line">    structs := <span class="built_in">make</span>(<span class="keyword">map</span>[token.Pos]*structType,<span class="number"> 0</span>)</div><div class="line">    collectStructs := <span class="keyword">func</span>(n ast.Node) <span class="typename">bool</span> {</div><div class="line">        t, ok := n.(*ast.TypeSpec)</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> t.Type == <span class="constant">nil</span> {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        structName := t.Name.Name</div><div class="line"></div><div class="line">        x, ok := t.Type.(*ast.StructType)</div><div class="line">        <span class="keyword">if</span> !ok {</div><div class="line">            <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">        }</div><div class="line"></div><div class="line">        structs[x.Pos()] = &structType{</div><div class="line">            name: structName,</div><div class="line">            node: x,</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    }</div><div class="line">    ast.Inspect(node, collectStructs)</div><div class="line">    <span class="keyword">return</span> structs</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们使用 <code>ast.Inspect()</code> 函数逐步遍历 AST 并搜索结构体。<br>我们首先搜索 <code>*ast.TypeSpec</code>，以便我们可以获得结构体名称。搜索 <code>*ast.StructType</code> 时给定的是结构体本身，而不是它的名字。 这就是为什么我们有一个自定义的 structType 类型，它保存了名称和结构体节点本身。这样在各个地方都很方便。 因为每个结构体的位置都是唯一的，并且在同一位置上不可能存在两个不同的结构体，因此我们使用位置作为 map 的键。</p>
<p>现在我们拥有了所有结构体，在最后可以返回一个结构体的起始位置和结束位置的偏移量和结构体名称模式。 对于偏移位置，我们检查偏移是否在给定的结构体之间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) offsetSelection(file ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    structs := collectStructs(file)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> encStruct *ast.StructType</div><div class="line">    <span class="keyword">for</span> _, st := <span class="keyword">range</span> structs {</div><div class="line">        structBegin := c.fset.Position(st.node.Pos()).Offset</div><div class="line">        structEnd := c.fset.Position(st.node.End()).Offset</div><div class="line"></div><div class="line">        <span class="keyword">if</span> structBegin &lt;= c.offset && c.offset &lt;= structEnd {</div><div class="line">            encStruct = st.node</div><div class="line">            <span class="keyword">break</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> encStruct == <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">return</span><span class="number"> 0</span>,<span class="number"> 0</span>, errors.New(<span class="string">"offset is not inside a struct"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// offset mode selects all fields</span></div><div class="line">    start := c.fset.Position(encStruct.Pos()).Line</div><div class="line">    end := c.fset.Position(encStruct.End()).Line</div><div class="line"></div><div class="line">    <span class="keyword">return</span> start, end, <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们使用 <code>collectStructs()</code> 来收集所有结构体，之后在这里迭代。还得记得我们存储了用于解析文件的初始 <code>token.FileSet</code> 么？</p>
<p>现在可以用它来获取每个结构体节点的偏移信息（我们将其解码为一个 <code>token.Position</code>，它为我们提供了 <code>.Offset</code> 字段）。 我们所做的只是一个简单的检查和迭代，直到我们找到结构体（这里命名为 <code>encStruct</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> _, st := <span class="keyword">range</span> structs {</div><div class="line">    structBegin := c.fset.Position(st.node.Pos()).Offset</div><div class="line">    structEnd := c.fset.Position(st.node.End()).Offset</div><div class="line"></div><div class="line">    <span class="keyword">if</span> structBegin &lt;= c.offset && c.offset &lt;= structEnd {</div><div class="line">        encStruct = st.node</div><div class="line">        <span class="keyword">break</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有了这些信息，我们可以提取找到的结构体的开始位置和结束位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start := c.fset.Position(encStruct.Pos()).Line</div><div class="line">end := c.fset.Position(encStruct.End()).Line</div></pre></td></tr></table></figure>

<p>该逻辑同样适用于结构体名称选择。 我们所做的只是尝试<strong>检查结构体名称</strong>，直到找到与给定名称一致的结构体，而不是检查偏移量是否在给定的结构体范围内：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) structSelection(file ast.Node) (<span class="typename">int</span>, <span class="typename">int</span>, error) {</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, st := <span class="keyword">range</span> structs {</div><div class="line">        <span class="keyword">if</span> st.name == c.structName {</div><div class="line">            encStruct = st.node</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在我们有了开始位置和结束位置，我们终于可以进行第三步了：修改结构体字段。</p>
<p><img src="gomodifytags-136.jpg" alt=""></p>
<p>在 <code>main</code> 函数中，我们将使用从上一步解析的节点来调用 <code>cfg.rewrite()</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    <span class="comment">// ... find start and end position of the struct to be modified</span></div><div class="line"></div><div class="line"></div><div class="line">    rewrittenNode, errs := cfg.rewrite(node, start, end)</div><div class="line">    <span class="keyword">if</span> errs != <span class="constant">nil</span> {</div><div class="line">        <span class="keyword">if</span> _, ok := errs.(*rewriteErrors); !ok {</div><div class="line">            <span class="keyword">return</span> errs</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// continue outputting the rewritten node</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是该工具的核心。在 <code>rewrite</code> 函数中，我们将重写开始位置和结束位置之间的所有结构体字段。 在深入了解之前，我们可以看一下该函数的大概内容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// rewrite rewrites the node for structs between the start and end</span></div><div class="line"><span class="comment">// positions and returns the rewritten node</span></div><div class="line"><span class="keyword">func</span> (c *config) rewrite(node ast.Node, start, end <span class="typename">int</span>) (ast.Node, error) {</div><div class="line">    errs := &rewriteErrors{errs: <span class="built_in">make</span>([]error,<span class="number"> 0</span>)}</div><div class="line"></div><div class="line">    rewriteFunc := <span class="keyword">func</span>(n ast.Node) <span class="typename">bool</span> {</div><div class="line">        <span class="comment">// rewrite the node ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(errs.errs) ==<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> node, <span class="constant">nil</span></div><div class="line">    }</div><div class="line"></div><div class="line">    ast.Inspect(node, rewriteFunc)</div><div class="line">    <span class="keyword">return</span> node, errs</div><div class="line">}</div></pre></td></tr></table></figure>

<p>正如你所看到的，我们再次使用 <code>ast.Inspect()</code> 来逐步处理给定节点的树。我们重写 <code>rewriteFunc</code> 函数中的每个字段的标签（更多内容在后面）。</p>
<p>因为传递给 <code>ast.Inspect()</code> 的函数不会返回错误，因此我们将创建一个错误映射（使用 errs 变量定义），之后在我们逐步遍历树并处理每个单独的字段时收集错误。现在让我们来谈谈 <code>rewriteFunc</code> 的内部原理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">rewriteFunc := <span class="keyword">func</span>(n ast.Node) <span class="typename">bool</span> {</div><div class="line">    x, ok := n.(*ast.StructType)</div><div class="line">    <span class="keyword">if</span> !ok {</div><div class="line">        <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> x.Fields.List {</div><div class="line">        line := c.fset.Position(f.Pos()).Line</div><div class="line"></div><div class="line">        <span class="keyword">if</span> !(start &lt;= line && line &lt;= end) {</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> f.Tag == <span class="constant">nil</span> {</div><div class="line">            f.Tag = &ast.BasicLit{}</div><div class="line">        }</div><div class="line"></div><div class="line">        fieldName := <span class="string">""</span></div><div class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f.Names) !=<span class="number"> 0</span> {</div><div class="line">            fieldName = f.Names<span class="number">[0</span>].Name</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// anonymous field</span></div><div class="line">        <span class="keyword">if</span> f.Names == <span class="constant">nil</span> {</div><div class="line">            ident, ok := f.Type.(*ast.Ident)</div><div class="line">            <span class="keyword">if</span> !ok {</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            }</div><div class="line"></div><div class="line">            fieldName = ident.Name</div><div class="line">        }</div><div class="line"></div><div class="line">        res, err := c.process(fieldName, f.Tag.Value)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">            errs.Append(fmt.Errorf(<span class="string">"%s:%d:%d:%s"</span>,</div><div class="line">                c.fset.Position(f.Pos()).Filename,</div><div class="line">                c.fset.Position(f.Pos()).Line,</div><div class="line">                c.fset.Position(f.Pos()).Column,</div><div class="line">                err))</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        }</div><div class="line"></div><div class="line">        f.Tag.Value = res</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="constant">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>记住，AST 树中的<strong>每一个节点</strong>都会调用这个函数。因此，我们只寻找类型为 <code>*ast.StructType</code> 的节点。一旦我们拥有，就可以开始迭代结构体字段。</p>
<p>这里我们使用 <code>start</code> 和 <code>end</code> 变量。这定义了我们是否要修改该字段。如果字段位置位于 start-end 之间，我们将继续，否则我们将忽略：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> !(start &lt;= line && line &lt;= end) {</div><div class="line">    <span class="keyword">continue</span> <span class="comment">// skip processing the field</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>接下来，我们检查是否存在标签。如果标签字段为空（也就是 nil），则初始化标签字段。这在有助于后面的 <code>cfg.process()</code> 函数避免 <code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> f.Tag == <span class="constant">nil</span> {</div><div class="line">    f.Tag = &ast.BasicLit{}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>现在让我先解释一下一个<strong>有趣</strong>的地方，然后再继续。<code>gomodifytags</code> 尝试获取字段的字段名称并处理它。然而，当它是一个匿名字段呢？：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Bar <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> {</div><div class="line">    Bar <span class="comment">//this is an anonymous field</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这种情况下，因为没有字段名称，我们尝试从类型名称中获取<strong>字段名称</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if there is a field name use it</span></div><div class="line">fieldName := <span class="string">""</span></div><div class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f.Names) !=<span class="number"> 0</span> {</div><div class="line">    fieldName = f.Names<span class="number">[0</span>].Name</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// if there is no field name, get it from type's name</span></div><div class="line"><span class="keyword">if</span> f.Names == <span class="constant">nil</span> {</div><div class="line">    ident, ok := f.Type.(*ast.Ident)</div><div class="line">    <span class="keyword">if</span> !ok {</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    }</div><div class="line"></div><div class="line">    fieldName = ident.Name</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦我们获得了字段名称和标签值，就可以开始处理该字段。<code>cfg.process()</code> 函数负责处理有字段名称和标签值（如果有的话）的字段。在它返回处理结果后（在我们的例子中是 struct tag 格式），我们使用它来覆盖现有的标签值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">res, err := c.process(fieldName, f.Tag.Value)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    errs.Append(fmt.Errorf(<span class="string">"%s:%d:%d:%s"</span>,</div><div class="line">        c.fset.Position(f.Pos()).Filename,</div><div class="line">        c.fset.Position(f.Pos()).Line,</div><div class="line">        c.fset.Position(f.Pos()).Column,</div><div class="line">        err))</div><div class="line">    <span class="keyword">continue</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// rewrite the field with the new result,i.e:​​​ js​on:"foo"</span></div><div class="line">f.Tag.Value = res</div></pre></td></tr></table></figure>

<p>实际上，如果你记得 <code>structtag</code>，它返回标签实例的 <code>String()</code> 表述。在我们返回标签的最终表述之前，我们根据需要使用 <code>structtag</code> 包的各种方法修改结构体。以下是一个简单的说明图示：</p>
<p><img src="gomodifytags-0013.jpg" alt="用 structtag 包修改每个字段"></p>
<p>例如，我们要扩展 <strong>process()</strong> 中的 <strong>removeTags()</strong> 函数。此功能使用以下配置来创建要删除的标签数组（键名称）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">flagRemoveTags = flag.String(<span class="string">"remove-tags"</span>, <span class="string">""</span>, <span class="string">"Remove tags for the comma separated list of keys"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> *flagRemoveTags != <span class="string">""</span> {</div><div class="line">    cfg.remove = strings.Split(*flagRemoveTags, <span class="string">","</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在 <code>removeTags()</code> 中，我们检查是否使用了 <code>--remove-tags</code>。如果有，我们将使用 <code>structtag</code> 的 <code>tags.Delete()</code> 方法来删除标签：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (c *config) removeTags(tags *structtag.Tags) *structtag.Tags {</div><div class="line">    <span class="keyword">if</span> c.remove == <span class="constant">nil</span> || <span class="built_in">len</span>(c.remove) ==<span class="number"> 0</span> {</div><div class="line">        <span class="keyword">return</span> tags</div><div class="line">    }</div><div class="line"></div><div class="line">    tags.Delete(c.remove...)</div><div class="line">    <span class="keyword">return</span> tags</div><div class="line">}</div><div class="line"></div><div class="line">此逻辑同样适用于 <span class="string">`cfg.Process()`</span> 中的所有函数。</div><div class="line"></div><div class="line"></div><div class="line">&lt;hr/&gt;</div><div class="line"></div><div class="line">我们已经有了一个重写的节点，让我们来讨论最后一个话题。输出和格式化结果：</div><div class="line"></div><div class="line">![](gomodifytags<span class="number">-158</span>.jpg)</div><div class="line"></div><div class="line">在 main 函数中，我们将使用上一步重写的节点来调用 <span class="string">`cfg.format()`</span> 函数：</div></pre></td></tr></table></figure>

<p>go<br>func main() {<br>    // ... rewrite the node</p>
<pre><code><span class="keyword">out</span>, err := cfg<span class="variable">.format</span>(rewrittenNode, errs)
<span class="keyword">if</span> err != <span class="literal">nil</span> {
    <span class="keyword">return</span> err
}

fmt<span class="variable">.Println</span>(<span class="keyword">out</span>)
</code></pre><p>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">您需要注意的一件事是，我们输出到 <span class="keyword">*</span><span class="keyword">*</span>stdout<span class="keyword">*</span><span class="keyword">*</span>。这佯做有许多优点。首先，您只需运行工具就能查看到结果， 它不会改变任何东西，只是为了让工具用户立即看到结果。其次，<span class="keyword">*</span><span class="keyword">*</span>stdout<span class="keyword">*</span><span class="keyword">*</span> 是可组合的，可以重定向到任何地方，甚至可以用来覆盖原来的工具。</div><div class="line"></div><div class="line">现在我们来看看 `format()` 函数：</div></pre></td></tr></table></figure>

<p>go<br>func (c *config) format(file ast.Node, rwErrs error) (string, error) {<br>    switch c.output {<br>    case &quot;source&quot;:<br>        // return Go source code<br>    case &quot;json&quot;:<br>        // return a custom JSON output<br>    default:<br>        return &quot;&quot;, fmt.Errorf(&quot;unknown output mode: %s&quot;, c.output)<br>    }<br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们有<span class="keyword">*</span><span class="keyword">*</span>两种输出模式<span class="keyword">*</span><span class="keyword">*</span>。</div><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>第一个<span class="keyword">*</span><span class="keyword">*</span>（source）以 Go 格式打印 ast.Node。这是默认选项，如果您在命令行使用它或只想看到文件中的更改，那么这非常适合您。</div><div class="line"></div><div class="line"><span class="keyword">*</span><span class="keyword">*</span>第二个选项<span class="keyword">*</span><span class="keyword">*</span>（json）更为先进，其专为其他环境而设计（特别是编辑器）。它根据以下结构体对输出进行编码：</div></pre></td></tr></table></figure>

<p>go<br>type output struct {<br>    Start  int      <code>json:&quot;start&quot;</code><br>    End    int      <code>json:&quot;end&quot;</code><br>    Lines  []string <code>json:&quot;lines&quot;</code><br>    Errors []string <code>json:&quot;errors,omitempty&quot;</code><br>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">对工具进行输入和最终结果输出（没有任何错误）大概示意图如下：</div><div class="line"></div><div class="line">![](gomodifytags-<span class="number">0014</span>.jpg)</div><div class="line"></div><div class="line">回到 <span class="escape">`f</span>ormat()<span class="escape">` </span>函数。如之前所述，有两种模式。<span class="escape">`s</span>ource<span class="escape">` </span>模式使用 <span class="escape">`g</span>o/format<span class="escape">` </span>包将 AST 格式化为 Go 源码。该软件包也被许多其他官方工具（如 gofmt）使用。以下是 source 模式的实现方式：</div></pre></td></tr></table></figure>

<p>go<br>var buf bytes.Buffer<br>err := format.Node(&amp;buf, c.fset, file)<br>if err != nil {<br>    return &quot;&quot;, err<br>}</p>
<p>if c.write {<br>    err = ioutil.WriteFile(c.file, buf.Bytes(), 0)<br>    if err != nil {<br>        return &quot;&quot;, err<br>    }<br>}</p>
<p>return buf.String(), nil</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">格式包接受 <span class="escape">`i</span>o.Writer<span class="escape">` </span>并对其进行格式化。这就是为什么我们创建一个中间缓冲区（<span class="escape">`v</span>ar buf bytes.Buffer<span class="escape">`）</span>的原因，当用户传入一个 <span class="escape">`-</span>write<span class="escape">` </span>标志时，我们可以使用它来覆盖文件。格式化后，我们返回缓冲区的字符串表示形式，其中包含格式化后的 Go 源代码。</div><div class="line"></div><div class="line"><span class="escape">`j</span>son<span class="escape">` </span>模式更有趣。因为我们返回的是一段源代码，因此我们需要准确地呈现它原本的格式，这也意味着要把注释包含进去。问题在于，当使用 <span class="escape">`f</span>ormat.Node()<span class="escape">` </span>打印单个结构体时，如果它们是有损的，则无法打印出 Go 注释。</div><div class="line"></div><div class="line">什么是有损注释（lossy comment）？看看这个例子：</div></pre></td></tr></table></figure>

<p>go<br>type example struct {<br>    foo int </p>
<pre><code><span class="comment">// this is a lossy comment</span>

bar <span class="keyword">int</span> 
</code></pre><p>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">每个字段都是 <span class="escape">`*</span>ast.Field<span class="escape">` </span>类型。此结构体有一个 <span class="escape">`*</span>ast.Field.Comment<span class="escape">` </span>字段，其包含某字段的注释。</div><div class="line"></div><div class="line">但是，在上面的例子中，它属于谁？属于 <span class="escape">`f</span>oo<span class="escape">` </span>还是 <span class="escape">`b</span>ar<span class="escape">`？</span></div><div class="line"></div><div class="line"><span class="label">因为不可能确定，这些注释被称为有损注释。如果现在使用 `format.Node()` 函数打印上面的结构体，就会出现问题。 当你打印它时，你可能会得到（https:</span>//play.golang.org/p/peHsswF4JQ）：</div></pre></td></tr></table></figure>

<p>go<br>type example struct {<br>    foo int</p>
<pre><code>bar <span class="keyword">int</span>
</code></pre><p>}</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">问题在于有损注释是 `<span class="keyword">*</span>ast.File` 的<span class="keyword">*</span><span class="keyword">*</span>一部分<span class="keyword">*</span><span class="keyword">*</span>，<span class="keyword">*</span><span class="keyword">*</span>它与树分开<span class="keyword">*</span><span class="keyword">*</span>。只有打印整个文件时才能打印出来。 所以解决方法是打印整个文件，然后删除掉我们要在 JSON 输出中返回的指定行：</div></pre></td></tr></table></figure>

<p>go<br>var buf bytes.Buffer<br>err := format.Node(&amp;buf, c.fset, file)<br>if err != nil {<br>    return &quot;&quot;, err<br>}</p>
<p>var lines []string<br>scanner := bufio.NewScanner(bytes.NewBufferString(buf.String()))<br>for scanner.Scan() {<br>    lines = append(lines, scanner.Text())<br>}</p>
<p>if c.start &gt; len(lines) {<br>    return &quot;&quot;, errors.New(&quot;line selection is invalid&quot;)<br>}</p>
<p>out := &amp;output{<br>    Start: c.start,<br>    End:   c.end,<br>    Lines: lines[c.start-1 : c.end], // cut out lines<br>}</p>
<p>o, err := json.MarshalIndent(out, &quot;&quot;, &quot;  &quot;)<br>if err != nil {<br>    return &quot;&quot;, err<br>}</p>
<p>return string(o), nil<br>```</p>
<p>这样做确保我们可以打印所有注释。</p>
<hr>

<p>这就是全部内容！</p>
<p>我们成功完成了我们的工具，以下是我们在整个指南中实施的完整步骤图：</p>
<p><img src="gomodifytags-175.jpg" alt=""></p>
<p>回顾一下我们做了什么：</p>
<ul>
<li>我们通过 CLI 标志检索配置</li>
<li>我们通过 <code>go/parser</code> 包解析文件来获取一个 <code>ast.Node</code>。</li>
<li>在解析文件之后，我们搜索 获取相应的结构体来获取开始位置和结束位置，这样我们可以知道需要修改哪些字段</li>
<li>一旦我们有了开始位置和结束位置，我们再次遍历 <code>ast.Node</code>，重写开始位置和结束位置之间的每个字段（通过使用 structtag 包）</li>
<li>之后，我们将格式化重写的节点，为编辑器输出 Go 源代码或自定义的 JSON</li>
</ul>
<p>在创建此工具后，我收到了很多友好的评论，评论者们提到了这个工具如何简化他们的日常工作。正如您所看到，尽管看起来它很容易制作，但在整个指南中，我们已经针对许多特殊的情况做了特别处理。</p>
<p>gomodifytags 成功应用于以下编辑器和插件已经有几个月了，使得数以千计的开发人员提升了工作效率：</p>
<ul>
<li>vim-go</li>
<li>atom</li>
<li>vscode</li>
<li>acme</li>
</ul>
<p>如果您对原始源代码感兴趣，可以在这里找到：</p>
<p><a href="https://github.com/fatih/gomodifytags" target="_blank" rel="external">https://github.com/fatih/gomodifytags</a><br>我还在 Gophercon 2017 上发表了一个演讲，如果您感兴趣，可点击下面的 youtube 链接观看：</p>
<p><a href="https://www.youtube.com/embed/T4AIQ4RHp-c?version=3&amp;rel=1&amp;fs=1&amp;autohide=2&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;wmode=transparent" target="_blank" rel="external">https://www.youtube.com/embed/T4AIQ4RHp-c?version=3&amp;rel=1&amp;fs=1&amp;autohide=2&amp;showsearch=0&amp;showinfo=1&amp;iv_load_policy=1&amp;wmode=transparent</a></p>
<p>谢谢您阅读此文。希望这个指南能启发您从头创建一个新的 Go 工具。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/" target="_blank" rel="external">https://arslan.io/2017/09/14/the-ultimate-guide-to-writing-a-go-tool/</a><br>作者：Fatih Arslan<br>译文：<a href="http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/" target="_blank" rel="external">http://oopsguy.com/2017/10/27/the-ultimate-guide-to-writing-a-go-tool/</a><br>译者：oopsguy.com</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go 机器学习库来进行数据分析 3 (平均感知器)]]></title>
    <link href="http://colobu.com/2017/12/07/Three-Machine-Learning-for-Go/"/>
    <id>http://colobu.com/2017/12/07/Three-Machine-Learning-for-Go/</id>
    <published>2017-12-07T11:21:56.000Z</published>
    <updated>2017-12-09T15:22:06.126Z</updated>
    <content type="html"><![CDATA[<p>这一次，我们使用平均感知器(Average Perceptron)算法来预测美国国会的投票。</p>
<a id="more"></a>
<h2 id="1984美国国会投票记录数据集">1984美国国会投票记录数据集</h2>
<p>这一次，我们使用1984美国国会的<a href="https://archive.ics.uci.edu/ml/datasets/congressional+voting+records" target="_blank" rel="external">投票记录</a>来预测一下投票结果。</p>
<p>数据集针对不同的投票议题分为了16类， 记录了民主党和共和党议员们得投票结果。</p>
<p>格式如下</p>
<figure class="highlight csv"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">v16,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,party</div><div class="line">1,-1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,republican</div><div class="line">-<span class="ruby"><span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,republican</span></div><div class="line">-<span class="ruby"><span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,democrat</span></div><div class="line">1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,democrat</div><div class="line">1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,democrat</div><div class="line">1,-1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,democrat</div><div class="line">1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,1,democrat</div><div class="line">1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,republican</div><div class="line">1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,republican</div><div class="line">-<span class="ruby"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,democrat</span></div><div class="line">-<span class="ruby"><span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,republican</span></div><div class="line">-<span class="ruby"><span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,republican</span></div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure>

<p>这一次，我们还是将数据集分为训练数据和测试数据，以评估算法的预测结果的准确性。</p>
<h2 id="平均感知器">平均感知器</h2>
<p>感知器算法一个监督学习的二分分类器， 是线性分类器的一种。</p>
<p>感知机算法是非常好的二分类算法，该算法求取一个分离超平面，超平面由w参数化并用来预测，对于一个样本x，感知机算法通过计算y = [w,x]预测样本的标签，最终的预测标签通过计算sign(y)来实现。算法仅在预测错误时修正权值w。<br>平均感知机和感知机算法的训练方法一样，不同的是每次训练样本xi后，保留先前训练的权值，训练结束后平均所有权值。最终用平均权值作为最终判别准则的权值。参数平均化可以克服由于学习速率过大所引起的训练过程中出现的震荡现象。</p>
<h2 id="代码">代码</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	base <span class="string">"github.com/sjwhitworth/golearn/base"</span></div><div class="line">	evaluation <span class="string">"github.com/sjwhitworth/golearn/evaluation"</span></div><div class="line">	perceptron <span class="string">"github.com/sjwhitworth/golearn/perceptron"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">	rand.Seed<span class="number">(4402201</span>)</div><div class="line"></div><div class="line">	rawData, err := base.ParseCSVToInstances(<span class="string">"../datasets/house-votes-84.csv"</span>, <span class="constant">true</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">//Initialises a new AveragePerceptron classifier</span></div><div class="line">	cls := perceptron.NewAveragePerceptron<span class="number">(10</span>,<span class="number"> 1.2</span>,<span class="number"> 0.5</span>,<span class="number"> 0.3</span>)</div><div class="line"></div><div class="line">	<span class="comment">//Do a training-test split</span></div><div class="line">	trainData, testData := base.InstancesTrainTestSplit(rawData,<span class="number"> 0.50</span>)</div><div class="line">	fmt.Println(trainData)</div><div class="line">	fmt.Println(testData)</div><div class="line">	cls.Fit(trainData)</div><div class="line"></div><div class="line">	predictions := cls.Predict(testData)</div><div class="line"></div><div class="line">	<span class="comment">// Prints precision/recall metrics</span></div><div class="line">	confusionMat, _ := evaluation.GetConfusionMatrix(testData, predictions)</div><div class="line">	fmt.Println(evaluation.GetSummary(confusionMat))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先读入国会投票数据集。</p>
<p>然后创建平均感知器算法实例。</p>
<p>之后将数据集分为两份，一份训练数据，一份用来预测和评估。</p>
<p>最后将评估结果打印。</p>
<h2 id="评估结果">评估结果</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">Reference</span> <span class="comment">Class	True</span> <span class="comment">Positives	False</span> <span class="comment">Positives	True</span> <span class="comment">Negatives	Precision	Recall	F1</span> <span class="comment">Score</span></div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div><div class="line"><span class="comment">democrat	98		24		70		0</span><span class="string">.</span><span class="comment">8033		0</span><span class="string">.</span><span class="comment">6806	0</span><span class="string">.</span><span class="comment">7368</span></div><div class="line"><span class="comment">republican	70		46		98		0</span><span class="string">.</span><span class="comment">6034		0</span><span class="string">.</span><span class="comment">7447	0</span><span class="string">.</span><span class="comment">6667</span></div><div class="line"><span class="comment">Overall</span> <span class="comment">accuracy:</span> <span class="comment">0</span><span class="string">.</span><span class="comment">7059</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这一次，我们使用平均感知器(Average Perceptron)算法来预测美国国会的投票。</p>
]]>
    
    </summary>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go 机器学习库来进行数据分析 2 (决策树)]]></title>
    <link href="http://colobu.com/2017/12/07/Two-Machine-Learning-for-Go/"/>
    <id>http://colobu.com/2017/12/07/Two-Machine-Learning-for-Go/</id>
    <published>2017-12-07T10:24:30.000Z</published>
    <updated>2017-12-09T15:22:06.126Z</updated>
    <content type="html"><![CDATA[<p>这篇文章， 继续使用<a href="https://github.com/sjwhitworth/golearn" target="_blank" rel="external">golearn</a>库分析鸢尾花的数据集。 这一次，我们会使用决策树和随机森林来分析。</p>
<a id="more"></a>
<h2 id="决策树和随机森林">决策树和随机森林</h2>
<p>决策树是机器学习中最接近人类思考问题的过程的一种算法，通过若干个节点，对特征进行提问并分类（可以是二分类也可以使多分类），直至最后生成叶节点（也就是只剩下一种属性）。</p>
<p>每个决策树都表述了一种树型结构，它由它的分支来对该类型的对象依靠属性进行分类。每个决策树可以依靠对源数据库的分割进行数据测试。这个过程可以递归式的对树进行修剪。 当不能再进行分割或一个单独的类可以被应用于某一分支时，递归过程就完成了。另外，随机森林分类器将许多决策树结合起来以提升分类的正确率。</p>
<p>golearn支持两种决策树算法。ID3和RandomTree。</p>
<ul>
<li><p><strong>ID3</strong>: 以信息增益为准则选择信息增益最大的属性。</p>
<blockquote>
<p>ID3 is a decision tree induction algorithm which splits on the Attribute which gives the greatest Information Gain (entropy gradient). It performs well on categorical data. Numeric datasets will need to be discretised before using ID3 </p>
</blockquote>
</li>
<li><p><strong>RandomTree</strong>: 与ID3类似，但是选择的属性的时候随机选择。</p>
<blockquote>
<p>Random Trees are structurally identical to those generated by ID3, but the split Attribute is chosen randomly. Golearn&#39;s implementation allows you to choose up to k nodes for consideration at each split.</p>
</blockquote>
</li>
</ul>
<p>可以参考 ChongmingLiu的介绍： <a href="http://www.jianshu.com/p/38aa0daf6841" target="_blank" rel="external">决策树(ID3 &amp; C4.5 &amp; CART)</a>。</p>
<p>维基百科中对随机森林的介绍：</p>
<blockquote>
<p>在机器学习中，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。 Leo Breiman和Adele Cutler发展出推论出随机森林的算法。而&quot;Random Forests&quot;是他们的商标。这个术语是1995年由贝尔实验室的Tin Kam Ho所提出的随机决策森林（random decision forests）而来的。这个方法则是结合Breimans的&quot;Bootstrap aggregating&quot;想法和Ho的&quot;random subspace method&quot; 以建造决策树的集合。</p>
</blockquote>
<p>在机器学习中，随机森林由许多的决策树组成，因为这些决策树的形成采用了随机的方法，因此也叫做随机决策树。随机森林中的树之间是没有关联的。当测试数据进入随机森林时，其实就是让每一颗决策树进行分类，最后取所有决策树中分类结果最多的那类为最终的结果。因此随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。</p>
<h2 id="代码">代码</h2>
<p>下面是使用决策树和随机森林预测鸢尾花分类的代码，来自golearn:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Demonstrates decision tree classification</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/base"</span></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/ensemble"</span></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/evaluation"</span></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/filters"</span></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/trees"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">	<span class="keyword">var</span> tree base.Classifier</div><div class="line"></div><div class="line">	rand.Seed<span class="number">(44111342</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Load in the iris dataset</span></div><div class="line">	iris, err := base.ParseCSVToInstances(<span class="string">"../datasets/iris_headers.csv"</span>, <span class="constant">true</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Discretise the iris dataset with Chi-Merge</span></div><div class="line">	filt := filters.NewChiMergeFilter(iris,<span class="number"> 0.999</span>)</div><div class="line">	<span class="keyword">for</span> _, a := <span class="keyword">range</span> base.NonClassFloatAttributes(iris) {</div><div class="line">		filt.AddAttribute(a)</div><div class="line">	}</div><div class="line">	filt.Train()</div><div class="line">	irisf := base.NewLazilyFilteredInstances(iris, filt)</div><div class="line"></div><div class="line">	<span class="comment">// Create a 60-40 training-test split</span></div><div class="line">	trainData, testData := base.InstancesTrainTestSplit(irisf,<span class="number"> 0.60</span>)</div><div class="line"></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// First up, use ID3</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	tree = trees.NewID3DecisionTree<span class="number">(0.6</span>)</div><div class="line">	<span class="comment">// (Parameter controls train-prune split.)</span></div><div class="line"></div><div class="line">	<span class="comment">// Train the ID3 tree</span></div><div class="line">	err = tree.Fit(trainData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Generate predictions</span></div><div class="line">	predictions, err := tree.Predict(testData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Evaluate</span></div><div class="line">	fmt.Println(<span class="string">"ID3 Performance (information gain)"</span>)</div><div class="line">	cf, err := evaluation.GetConfusionMatrix(testData, predictions)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Unable to get confusion matrix: %s"</span>, err.Error()))</div><div class="line">	}</div><div class="line">	fmt.Println(evaluation.GetSummary(cf))</div><div class="line"></div><div class="line">	tree = trees.NewID3DecisionTreeFromRule<span class="number">(0.6</span>, <span class="built_in">new</span>(trees.InformationGainRatioRuleGenerator))</div><div class="line">	<span class="comment">// (Parameter controls train-prune split.)</span></div><div class="line"></div><div class="line">	<span class="comment">// Train the ID3 tree</span></div><div class="line">	err = tree.Fit(trainData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Generate predictions</span></div><div class="line">	predictions, err = tree.Predict(testData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Evaluate</span></div><div class="line">	fmt.Println(<span class="string">"ID3 Performance (information gain ratio)"</span>)</div><div class="line">	cf, err = evaluation.GetConfusionMatrix(testData, predictions)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Unable to get confusion matrix: %s"</span>, err.Error()))</div><div class="line">	}</div><div class="line">	fmt.Println(evaluation.GetSummary(cf))</div><div class="line"></div><div class="line">	tree = trees.NewID3DecisionTreeFromRule<span class="number">(0.6</span>, <span class="built_in">new</span>(trees.GiniCoefficientRuleGenerator))</div><div class="line">	<span class="comment">// (Parameter controls train-prune split.)</span></div><div class="line"></div><div class="line">	<span class="comment">// Train the ID3 tree</span></div><div class="line">	err = tree.Fit(trainData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Generate predictions</span></div><div class="line">	predictions, err = tree.Predict(testData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Evaluate</span></div><div class="line">	fmt.Println(<span class="string">"ID3 Performance (gini index generator)"</span>)</div><div class="line">	cf, err = evaluation.GetConfusionMatrix(testData, predictions)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Unable to get confusion matrix: %s"</span>, err.Error()))</div><div class="line">	}</div><div class="line">	fmt.Println(evaluation.GetSummary(cf))</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Next up, Random Trees</span></div><div class="line">	<span class="comment">//</span></div><div class="line"></div><div class="line">	<span class="comment">// Consider two randomly-chosen attributes</span></div><div class="line">	tree = trees.NewRandomTree<span class="number">(2</span>)</div><div class="line">	err = tree.Fit(trainData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	predictions, err = tree.Predict(testData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	fmt.Println(<span class="string">"RandomTree Performance"</span>)</div><div class="line">	cf, err = evaluation.GetConfusionMatrix(testData, predictions)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Unable to get confusion matrix: %s"</span>, err.Error()))</div><div class="line">	}</div><div class="line">	fmt.Println(evaluation.GetSummary(cf))</div><div class="line"></div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="comment">// Finally, Random Forests</span></div><div class="line">	<span class="comment">//</span></div><div class="line">	tree = ensemble.NewRandomForest<span class="number">(70</span>,<span class="number"> 3</span>)</div><div class="line">	err = tree.Fit(trainData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	predictions, err = tree.Predict(testData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	fmt.Println(<span class="string">"RandomForest Performance"</span>)</div><div class="line">	cf, err = evaluation.GetConfusionMatrix(testData, predictions)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Unable to get confusion matrix: %s"</span>, err.Error()))</div><div class="line">	}</div><div class="line">	fmt.Println(evaluation.GetSummary(cf))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首选使用<a href="http://www.aaai.org/Papers/AAAI/1992/AAAI92-019.pdf" target="_blank" rel="external">ChiMerge</a>方法进行数据离散，ChiMerge 是监督的、自底向上的(即基于合并的)数据离散化方法。它依赖于卡方分析：具有最小卡方值的相邻区间合并在一起，直到满足确定的停止准则。<br>基本思想：对于精确的离散化，相对类频率在一个区间内应当完全一致。因此，如果两个相邻的区间具有非常类似的类分布，则这两个区间可以合并；否则，它们应当保持分开。而低卡方值表明它们具有相似的类分布。可以参考&quot;Principles of Data Mining&quot;第二版中的第105页--第115页。</p>
<p>接着调用<code>base.NewLazilyFilteredInstances</code>应用filter得到FixedDataGrid。</p>
<p>之后将数据集分成训练数据和测试数据两部分。</p>
<p>接下来就是训练数据、预测与评估了。</p>
<p>分别使用<code>ID3</code>、<code>ID3 with InformationGainRatioRuleGenerator</code>、<code>ID3 with GiniCoefficientRuleGenerator</code>、<code>RandomTree</code>、<code>RandomForest</code>算法进行处理。</p>
<h2 id="评估结果">评估结果</h2>
<p>以下是各种算法的评估结果，可以和　kNN进行比较,看起来比不过kNN的预测。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">ID3</span> <span class="comment">Performance</span> <span class="comment">(information</span> <span class="comment">gain)</span></div><div class="line"><span class="comment">Reference</span> <span class="comment">Class	True</span> <span class="comment">Positives	False</span> <span class="comment">Positives	True</span> <span class="comment">Negatives	Precision	Recall	F1</span> <span class="comment">Score</span></div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">virginica	32		5		46		0</span><span class="string">.</span><span class="comment">8649		0</span><span class="string">.</span><span class="comment">9697	0</span><span class="string">.</span><span class="comment">9143</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">versicolor	4		1		61		0</span><span class="string">.</span><span class="comment">8000		0</span><span class="string">.</span><span class="comment">1818	0</span><span class="string">.</span><span class="comment">2963</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">setosa	29		13		42		0</span><span class="string">.</span><span class="comment">6905		1</span><span class="string">.</span><span class="comment">0000	0</span><span class="string">.</span><span class="comment">8169</span></div><div class="line"><span class="comment">Overall</span> <span class="comment">accuracy:</span> <span class="comment">0</span><span class="string">.</span><span class="comment">7738</span></div><div class="line"></div><div class="line"><span class="comment">ID3</span> <span class="comment">Performance</span> <span class="comment">(information</span> <span class="comment">gain</span> <span class="comment">ratio)</span></div><div class="line"><span class="comment">Reference</span> <span class="comment">Class	True</span> <span class="comment">Positives	False</span> <span class="comment">Positives	True</span> <span class="comment">Negatives	Precision	Recall	F1</span> <span class="comment">Score</span></div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">virginica	29		3		48		0</span><span class="string">.</span><span class="comment">9062		0</span><span class="string">.</span><span class="comment">8788	0</span><span class="string">.</span><span class="comment">8923</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">versicolor	5		3		59		0</span><span class="string">.</span><span class="comment">6250		0</span><span class="string">.</span><span class="comment">2273	0</span><span class="string">.</span><span class="comment">3333</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">setosa	29		15		40		0</span><span class="string">.</span><span class="comment">6591		1</span><span class="string">.</span><span class="comment">0000	0</span><span class="string">.</span><span class="comment">7945</span></div><div class="line"><span class="comment">Overall</span> <span class="comment">accuracy:</span> <span class="comment">0</span><span class="string">.</span><span class="comment">7500</span></div><div class="line"></div><div class="line"><span class="comment">ID3</span> <span class="comment">Performance</span> <span class="comment">(gini</span> <span class="comment">index</span> <span class="comment">generator)</span></div><div class="line"><span class="comment">Reference</span> <span class="comment">Class	True</span> <span class="comment">Positives	False</span> <span class="comment">Positives	True</span> <span class="comment">Negatives	Precision	Recall	F1</span> <span class="comment">Score</span></div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">virginica	26		5		46		0</span><span class="string">.</span><span class="comment">8387		0</span><span class="string">.</span><span class="comment">7879	0</span><span class="string">.</span><span class="comment">8125</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">versicolor	17		36		26		0</span><span class="string">.</span><span class="comment">3208		0</span><span class="string">.</span><span class="comment">7727	0</span><span class="string">.</span><span class="comment">4533</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">setosa	0		0		55		NaN		0</span><span class="string">.</span><span class="comment">0000	NaN</span></div><div class="line"><span class="comment">Overall</span> <span class="comment">accuracy:</span> <span class="comment">0</span><span class="string">.</span><span class="comment">5119</span></div><div class="line"></div><div class="line"><span class="comment">RandomTree</span> <span class="comment">Performance</span></div><div class="line"><span class="comment">Reference</span> <span class="comment">Class	True</span> <span class="comment">Positives	False</span> <span class="comment">Positives	True</span> <span class="comment">Negatives	Precision	Recall	F1</span> <span class="comment">Score</span></div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">virginica	30		3		48		0</span><span class="string">.</span><span class="comment">9091		0</span><span class="string">.</span><span class="comment">9091	0</span><span class="string">.</span><span class="comment">9091</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">versicolor	9		3		59		0</span><span class="string">.</span><span class="comment">7500		0</span><span class="string">.</span><span class="comment">4091	0</span><span class="string">.</span><span class="comment">5294</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">setosa	29		10		45		0</span><span class="string">.</span><span class="comment">7436		1</span><span class="string">.</span><span class="comment">0000	0</span><span class="string">.</span><span class="comment">8529</span></div><div class="line"><span class="comment">Overall</span> <span class="comment">accuracy:</span> <span class="comment">0</span><span class="string">.</span><span class="comment">8095</span></div><div class="line"></div><div class="line"><span class="comment">RandomForest</span> <span class="comment">Performance</span></div><div class="line"><span class="comment">Reference</span> <span class="comment">Class	True</span> <span class="comment">Positives	False</span> <span class="comment">Positives	True</span> <span class="comment">Negatives	Precision	Recall	F1</span> <span class="comment">Score</span></div><div class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">	</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">virginica	31		8		43		0</span><span class="string">.</span><span class="comment">7949		0</span><span class="string">.</span><span class="comment">9394	0</span><span class="string">.</span><span class="comment">8611</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">versicolor	0		0		62		NaN		0</span><span class="string">.</span><span class="comment">0000	NaN</span></div><div class="line"><span class="comment">Iris</span><span class="literal">-</span><span class="comment">setosa	29		16		39		0</span><span class="string">.</span><span class="comment">6444		1</span><span class="string">.</span><span class="comment">0000	0</span><span class="string">.</span><span class="comment">7838</span></div><div class="line"><span class="comment">Overall</span> <span class="comment">accuracy:</span> <span class="comment">0</span><span class="string">.</span><span class="comment">7143</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章， 继续使用<a href="https://github.com/sjwhitworth/golearn" target="_blank" rel="external">golearn</a>库分析鸢尾花的数据集。 这一次，我们会使用决策树和随机森林来分析。</p>
]]>
    
    </summary>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Go 机器学习库来进行数据分析 1 (kNN)]]></title>
    <link href="http://colobu.com/2017/12/07/One-Machine-Learning-for-Go/"/>
    <id>http://colobu.com/2017/12/07/One-Machine-Learning-for-Go/</id>
    <published>2017-12-07T01:46:04.000Z</published>
    <updated>2017-12-09T15:22:06.063Z</updated>
    <content type="html"><![CDATA[<p>这个系列的文章是介绍如何使用Go语言来进行数据分析和机器学习。</p>
<p>Go机器学习的库目前还不是很多，功能海没有Python的丰富，希望在未来的几年里能有更多的功能丰富库面试。</p>
<p>这篇文章利用<a href="https://github.com/sjwhitworth/golearn" target="_blank" rel="external">golearn</a>库， 使用kNN方法来对Iris数据集进行分析。</p>
<a id="more"></a>
<h2 id="Iris数据集">Iris数据集</h2>
<p>Iris数据集也称为鸢尾花数据集，或者叫做费雪鸢尾花卉数据集或者安德森鸢尾花卉数据集。是一类多重变量分析的数据集。它最初是埃德加·安德森从加拿大加斯帕半岛上的鸢尾属花朵中提取的地理变异数据，后由罗纳德·费雪作为判别分析的一个例子，运用到统计学中。</p>
<p>其它比较流行的数据集还有Adult,Wine,Car Evaluation等(<a href="http://www.jianshu.com/p/be23b3870d2e" target="_blank" rel="external">1</a>)。</p>
<p>Iris数据集包含了150个样本，都属于鸢尾属下的三个亚属，分别是山鸢尾(setosa)、变色鸢尾(versicolor)和维吉尼亚鸢尾(virginica)。四个特征被用作样本的定量分析，它们分别是<strong>花萼</strong>和<strong>花瓣</strong>的<strong>长度</strong>和<strong>宽度</strong>。基于这四个特征的集合，费雪发展了一个线性判别分析以确定其属种。</p>
<p>下面是这三种鸢尾的花,非常的漂亮：</p>
<table class="one" border="1" width="100%"><br><tr><br><td width="33%"><a href="/2017/12/07/One-Machine-Learning-for-Go/Kosaciec_szczecinkowaty_Iris_setosa.jpg" title="" class="fancybox" rel="article0"><img src="Kosaciec_szczecinkowaty_Iris_setosa.jpg" alt=""></a></td><br><td width="33%"><a href="/2017/12/07/One-Machine-Learning-for-Go/Iris_versicolor_3.jpg" title="" class="fancybox" rel="article0"><img src="Iris_versicolor_3.jpg" alt=""></a></td><br><td width="33%"><a href="/2017/12/07/One-Machine-Learning-for-Go/Iris_virginica.jpg" title="" class="fancybox" rel="article0"><img src="Iris_virginica.jpg" alt=""></a></td><br></tr><br></table>


<p>下图是鸢尾花数据集的散布图， 第一个种类与另外两个种类是线性可分离的，后两个种类是非线性可分离的：</p>
<p><img src="Iris_dataset_scatterplot.png" alt=""></p>
<p>以上内容主要参考维基百科和百度百科关于Iris数据集的介绍。</p>
<p>这个数据集在网上很容易搜到，也可以在 golearn 项目中下载。</p>
<h2 id="kNN_K近邻算法">kNN K近邻算法</h2>
<p>分类算法是数据挖掘分类技术中最简单的方法之一。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。</p>
<p>kNN算法的核心思想是如果一个样本在特征空间中的k个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 kNN方法在类别决策时，只与极少量的相邻样本有关。由于kNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，kNN方法较其他方法更为适合。</p>
<p>简单说， 如果你住在高档小区，周围都是&quot;高端人口&quot;， 那么可以判定你就是&quot;高端人口&quot;, 然后就不会被......</p>
<p><code>k</code> 代表最近的<code>k</code>个邻居。</p>
<p>算法更详细的介绍可以参考:<a href="https://baike.baidu.com/item/邻近算法/1151153?fromtitle=Knn&amp;fromid=3479559" target="_blank" rel="external">百度百科</a>和<a href="https://zh.wikipedia.org/wiki/最近鄰居法" target="_blank" rel="external">维基百科</a>。</p>
<h2 id="训练数据和预测">训练数据和预测</h2>
<p>下面就让我们看看 golearn使用kNN算法分析鸢尾花数据集的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/base"</span></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/evaluation"</span></div><div class="line">	<span class="string">"github.com/sjwhitworth/golearn/knn"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	rawData, err := base.ParseCSVToInstances(<span class="string">"../datasets/iris_headers.csv"</span>, <span class="constant">true</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">//Initialises a new KNN classifier</span></div><div class="line">	cls := knn.NewKnnClassifier(<span class="string">"euclidean"</span>, <span class="string">"linear"</span>,<span class="number"> 2</span>)</div><div class="line"></div><div class="line">	<span class="comment">//Do a training-test split</span></div><div class="line">	trainData, testData := base.InstancesTrainTestSplit(rawData,<span class="number"> 0.50</span>)</div><div class="line">	cls.Fit(trainData)</div><div class="line"></div><div class="line">	<span class="comment">//Calculates the Euclidean distance and returns the most popular label</span></div><div class="line">	predictions, err := cls.Predict(testData)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(err)</div><div class="line">	}</div><div class="line">	fmt.Println(predictions)</div><div class="line"></div><div class="line">	<span class="comment">// Prints precision/recall metrics</span></div><div class="line">	confusionMat, err := evaluation.GetConfusionMatrix(testData, predictions)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Unable to get confusion matrix: %s"</span>, err.Error()))</div><div class="line">	}</div><div class="line">	fmt.Println(evaluation.GetSummary(confusionMat))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>#12</strong> 行加载鸢尾花数据集， base提供了读取CSV文本文件的方法。</p>
<p><strong>#18</strong> 行创建一个kNN分类器， 距离的计算使用欧几里德方法，此外还支持<code>manhattan</code>、<code>cosine</code>距离计算方法。第二个参数支持<code>linear</code>和<code>kdtree</code>。</p>
<p><strong>#18</strong> 还指定了<code>K</code>为2。</p>
<p><strong>#21</strong> 将鸢尾花数据集按照参数分成两份，它使用随机数和这个参数比较，所以分成的数据的结果大致是这个比例。一部分用于训练数据，一部分用于测试。接着<strong>#22</strong>开始训练数据。</p>
<p><strong>#25</strong> 使用测试预测数据，并将预测结果打印出来。</p>
<p><strong>#32 ~ #36</strong> 是评估预测模型，并将评估结果输出。</p>
<h2 id="评估">评估</h2>
<p>首先看一下评估结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Reference Class	True Positives	False Positives	True Negatives	Precision	Recall	F1 Score</div><div class="line">---------------	--------------	---------------	--------------	---------	------	--------</div><div class="line">Iris-setosa<span class="number">	30</span>	<span class="number">	0</span>	<span class="number">	58</span>	<span class="number">	1.0000</span>	<span class="number">	1.0000</span><span class="number">	1.0000</span></div><div class="line">Iris-virginica<span class="number">	27</span>	<span class="number">	1</span>	<span class="number">	58</span>	<span class="number">	0.9643</span>	<span class="number">	0.9310</span><span class="number">	0.9474</span></div><div class="line">Iris-versicolor<span class="number">	28</span>	<span class="number">	2</span>	<span class="number">	57</span>	<span class="number">	0.9333</span>	<span class="number">	0.9655</span><span class="number">	0.9492</span></div></pre></td></tr></table></figure>

<p>这里有几个概念需要说明一下。</p>
<ul>
<li>ConfusionMatrix： 混淆矩阵，它描绘样本数据的真实属性与识别结果类型之间的关系，是评价分类器性能的一种常用方法，用于有监督学习。</li>
<li>True Positives: 真正，TP, 被模型预测为正的正样本；可以称作判断为真的正确率</li>
<li>False Positives: 假正，FP，误报， 被模型预测为正的负样本；可以称作误报率</li>
<li>True Negatives: 真负，TN, 被模型预测为负的负样本 ；可以称作判断为假的正确率</li>
<li>False Negatives: 假负，FN,漏报， 被模型预测为负的正样本；可以称作漏报率</li>
<li>Precision: 精确率, 正确预测正负的个数/总个数，它表示的是预测为正的样本中有多少是真正的正样本。 $$P = \frac{TP}{TP+FP}$$,</li>
<li>Recall: 召回率，它表示的是样本中的正例有多少被预测正确了， $$R = TPR = \frac{TP}{TP+FN}$$</li>
<li>F1 Score:  为了能够评价不同算法的优劣，在Precision和Recall的基础上提出了F1值的概念，来对Precision和Recall进行整体评价。F1的定义如下：<code>F1值  = 正确率 * 召回率 * 2 / (正确率 + 召回率)</code></li>
</ul>
<h2 id="Python代码实现">Python代码实现</h2>
<p>使用<code>sklearn</code>很容易实现上面的逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors, datasets, metrics</div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"></div><div class="line"> </div><div class="line"><span class="comment"># import some data to play with</span></div><div class="line">IRIS = datasets.load_iris()</div><div class="line"> </div><div class="line"><span class="comment"># prepare data</span></div><div class="line">X_train, X_test, Y_train, Y_test = train_test_split(IRIS.data, IRIS.target, test_size=<span class="number">0.5</span>, random_state=<span class="number">0</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># we create an instance of Neighbours Classifier and fit the data.</span></div><div class="line">knn = neighbors.KNeighborsClassifier(n_neighbors=<span class="number">2</span>, weights=<span class="string">'distance'</span>)</div><div class="line">knn.fit(X_train, Y_train)</div><div class="line"></div><div class="line"><span class="comment"># make prediction</span></div><div class="line">predicted = knn.predict(X_test)</div><div class="line"> </div><div class="line"><span class="comment"># evaluate</span></div><div class="line">print(metrics.classification_report(Y_test, predicted))</div><div class="line">print(metrics.confusion_matrix(Y_test, predicted))</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>这个系列的文章是介绍如何使用Go语言来进行数据分析和机器学习。</p>
<p>Go机器学习的库目前还不是很多，功能海没有Python的丰富，希望在未来的几年里能有更多的功能丰富库面试。</p>
<p>这篇文章利用<a href="https://github.com/sjwhitworth/golearn" target="_blank" rel="external">golearn</a>库， 使用kNN方法来对Iris数据集进行分析。</p>
]]>
    
    </summary>
    
      <category term="大数据" scheme="http://colobu.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>
