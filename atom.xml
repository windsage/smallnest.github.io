<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[鸟窝]]></title>
  <subtitle><![CDATA[大道至简 Simplicity is the ultimate form of sophistication]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://colobu.com/"/>
  <updated>2017-09-30T15:45:50.558Z</updated>
  <id>http://colobu.com/</id>
  
  <author>
    <name><![CDATA[smallnest]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[functor applicative 和 monad]]></title>
    <link href="http://colobu.com/2017/09/30/functor-applicative-and-monad/"/>
    <id>http://colobu.com/2017/09/30/functor-applicative-and-monad/</id>
    <published>2017-09-30T14:16:53.000Z</published>
    <updated>2017-09-30T14:58:43.454Z</updated>
    <content type="html"><![CDATA[<p>Monad 函数式编程中的一个概念， 在 Haskell 和 Scala 语言中用的比较多。</p>
<p>&lt;!--<br>这个概念来源于数学中的范畴学，过于学术化，我看国内的文章介绍的很多，但是准确、清晰而简要的介绍的文章却没有看到。</p>
<p>我也不准备介绍，因为我对它的理解也不够深，这里引用 <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="external">Functors, Applicatives, And Monads In Pictures</a>一文中的图片和总结，来加深一下自己的理解。</p>
<p><img src="recap.png" alt=""></p>
<ul>
<li><strong>functors</strong>: you apply a function to a wrapped value using fmap or &lt;$&gt;</li>
<li><strong>applicatives</strong>: you apply a wrapped function to a wrapped value using &lt;*&gt; or liftA</li>
<li><strong>monads</strong>: you apply a function that returns a wrapped value, to a wrapped value using &gt;&gt;= or liftM</li>
</ul>
<p><img src="fmap.png" alt="Functor 的作用就是应用一个函数到一个上下文中的值"></p>
<p><img src="applicative.png" alt="Applicative 的作用则是应用一个上下文中的函数到一个上下文中的值"></p>
<p><img src="bind.png" alt="Monad 应用的是一个返回上下文的值的函数，将这个函数应用在一个上下文中的值上"></p>
<p>这篇文章已经被翻译成中文： <a href="http://jiyinyiyong.github.io/monads-in-pictures/" target="_blank" rel="external">Functor, Applicative, 以及 Monad 的图片阐释</a>。<br>kotlin中文版： <a href="https://hltj.me/kotlin/2017/08/25/kotlin-functor-applicative-monad-cn.html" target="_blank" rel="external">Kotlin 版图解 Functor、Applicative 与 Monad</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Monad 函数式编程中的一个概念， 在 Haskell 和 Scala 语言中用的比较多。</p>
<p>&lt;!--<br>这个概念来源于数学中的范畴学，过于学术化，我看国内的文章介绍的很多，但是准确、清晰而简要的介绍的文章却没有看到。</p>
<p>我也不准备介绍，]]>
    </summary>
    
      <category term="算法" scheme="http://colobu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Go 和 Let's Encrypt 快速配置HTTPS加密]]></title>
    <link href="http://colobu.com/2017/09/30/use-letsencrypt-in-go/"/>
    <id>http://colobu.com/2017/09/30/use-letsencrypt-in-go/</id>
    <published>2017-09-30T08:28:28.000Z</published>
    <updated>2017-09-30T14:15:44.802Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.google.com.sg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjAguS9vszWAhXDo48KHZPNCMUQFggnMAA&amp;url=https%3A%2F%2Fletsencrypt.org%2F&amp;usg=AOvVaw3jJenSMDof06eZ9Vr2RLNL" target="_blank" rel="external">Let&#39;s Encrypt</a> 在2015年秋季推出了免费的数字证书认证计划，旨在消除当前手动创建和安装证书的复杂性，并推广加密的万维网服务，为安全网站提供<strong>免费</strong>的SSL/TLS证书。<br>Let&#39;s Encrypt 是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。主要赞助商包括电子前哨基金会，Mozilla基金会，Akamai以及思科。2015年4月9日，ISRG与Linux基金会宣布合作。</p>
<p>用以实现这一新的数字证书认证机构的协议被称为自动证书管理环境（<a href="https://github.com/ietf-wg-acme/acme/" target="_blank" rel="external">ACME</a>）。提案的一个版本已作为一个Internet草案发布。</p>
<p>目前， 申请证书的域名只能是特定的域名， 不支持<a href="https://zh.wikipedia.org/wiki/通配符证书" target="_blank" rel="external">通配符证书</a>(*.example.com)，这对于一个拥有众多子域名的公司来说很不方便。但是今年已经说了，将于2018年1月<a href="https://letsencrypt.org/2017/07/06/wildcard-certificates-coming-jan-2018.html" target="_blank" rel="external">支持通配符证书</a>和ACME v2 API。</p>
<a id="more"></a>
<p>原先有一些支持Let&#39;s Encrypt的 Go 工具和库， 比如<a href="https://github.com/xenolf/lego" target="_blank" rel="external">lego</a>、<a href="https://github.com/hlandau/acme" target="_blank" rel="external">acme</a>、<a href="https://github.com/ericchiang/letsencrypt" target="_blank" rel="external">letsencrypt</a>、<a href="https://github.com/rsc/letsencrypt" target="_blank" rel="external">rsc/letsencrypt</a>, 但是我推荐使用官方的库：<a href="https://godoc.org/golang.org/x/crypto/acme/autocert" target="_blank" rel="external">x/crypto/acme/autocert</a>, 简单好用，并且官方维护。</p>
<p>稍微复杂一点的使用姿势如下(其实已经很简单了)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">m := autocert.Manager{</div><div class="line">    Cache:      autocert.DirCache(<span class="string">"secret-dir"</span>),</div><div class="line">    Prompt:     autocert.AcceptTOS,</div><div class="line">    HostPolicy: autocert.HostWhitelist(<span class="string">"example.org"</span>),</div><div class="line">}</div><div class="line">s := &http.Server{</div><div class="line">    Addr:      <span class="string">":https"</span>,</div><div class="line">    TLSConfig: &tls.Config{GetCertificate: m.GetCertificate},</div><div class="line">}</div><div class="line">s.ListenAndServeTLS(<span class="string">""</span>, <span class="string">""</span>)</div></pre></td></tr></table></figure>

<p><code>autocert.Manager</code>提供了<code>GetCertificate</code>方法， 可以用来配置<code>TLSConfig</code>。</p>
<p>更简单的方式是一行搞定：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mux := http.NewServeMux()</div><div class="line">mux.HandleFunc(<span class="string">"/"</span>, <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request) {</div><div class="line">    fmt.Fprintf(w, <span class="string">"Hello, TLS user! Your config: %+v"</span>, r.TLS)</div><div class="line">})</div><div class="line">log.Fatal(http.Serve(autocert.NewListener(<span class="string">"example.com"</span>), mux))</div></pre></td></tr></table></figure>

<p><code>autocert.NewListener</code>提供了一个自动配置的listener，使用起来非常的方便。</p>
<p>所以，如果你想做一些额外的配置，如果证书要缓存的位置，就用上面的方式， 如果想傻瓜式的使用，就用一行代码的方式。</p>
<p>关于这个包的设计的一些讨论可以看: <a href="https://github.com/golang/go/issues/17053" target="_blank" rel="external">#17053</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://www.google.com.sg/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjAguS9vszWAhXDo48KHZPNCMUQFggnMAA&amp;url=https%3A%2F%2Fletsencrypt.org%2F&amp;usg=AOvVaw3jJenSMDof06eZ9Vr2RLNL" target="_blank" rel="external">Let&#39;s Encrypt</a> 在2015年秋季推出了免费的数字证书认证计划，旨在消除当前手动创建和安装证书的复杂性，并推广加密的万维网服务，为安全网站提供<strong>免费</strong>的SSL/TLS证书。<br>Let&#39;s Encrypt 是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。主要赞助商包括电子前哨基金会，Mozilla基金会，Akamai以及思科。2015年4月9日，ISRG与Linux基金会宣布合作。</p>
<p>用以实现这一新的数字证书认证机构的协议被称为自动证书管理环境（<a href="https://github.com/ietf-wg-acme/acme/" target="_blank" rel="external">ACME</a>）。提案的一个版本已作为一个Internet草案发布。</p>
<p>目前， 申请证书的域名只能是特定的域名， 不支持<a href="https://zh.wikipedia.org/wiki/通配符证书" target="_blank" rel="external">通配符证书</a>(*.example.com)，这对于一个拥有众多子域名的公司来说很不方便。但是今年已经说了，将于2018年1月<a href="https://letsencrypt.org/2017/07/06/wildcard-certificates-coming-jan-2018.html" target="_blank" rel="external">支持通配符证书</a>和ACME v2 API。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转][译]面向分布式系统工程师的分布式系统理论]]></title>
    <link href="http://colobu.com/2017/09/27/distributed-systems-theory-for-the-distributed-systems-engineer/"/>
    <id>http://colobu.com/2017/09/27/distributed-systems-theory-for-the-distributed-systems-engineer/</id>
    <published>2017-09-27T08:06:40.000Z</published>
    <updated>2017-09-30T14:15:44.755Z</updated>
    <content type="html"><![CDATA[<p>原文：<a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">Distributed systems theory for the distributed systems engineer</a></p>
<p>译者：<a href="http://blog.xiayf.cn/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">youngsterxyf</a></p>
<p>Gwen Shapira，大腕级的解决方案架构师（SA），如今Cloudera的全职工程师，在<a href="https://twitter.com/gwenshap/status/497203248332165121" target="_blank" rel="external">Twitter上提的一个问题</a>引起了我的思考。</p>
<p>如果是以前，我可能会回答“嗯，这里有篇FLP论文，这里有篇Paxos论文，这里还有篇拜占庭将军问题的论文...”，我会罗列一箩筐重要的材料，如果你一头扎进去，至少花费6个月的时间才能过一遍这些材料。然而我已逐渐明白推荐大量的理论性的论文通常恰恰是着手学习分布式系统理论的错误方式（除非你在做一个PhD项目）。论文通常比较深入难懂，需要认真地研习，通常还需要大量的时间投入(significant experience)来理清这些论文的重要贡献，以及在整个理论体系中的位置。要求工程师具备这样的专业水平又有多大的意义呢？</p>
<p>但是，很遗憾，对分布式系统理论方面的重大研究成果和思想进行概括、归纳、背景分析的‘导引’性质的优秀材料非常缺乏；特别是没有居高临下态度的材料。对这块空白区域的思考让我想到了另一个有趣的问题：</p>
<blockquote>
<p>一个分布式系统工程师应该知道些什么分布式系统理论？</p>
</blockquote>
<p>在这种情况下，一知半解(a little theory)并不会是一件多危险的事情。因此我尝试整理一个列表，罗列出作为一个分布式系统工程师的我认为能够直接应用于我日常工作的一些基本概念；或者让分布式系统工程师完全有能力设计一个新系统的“筹码”。如果你认为我漏掉了一些东西，请联系我。</p>
<a id="more"></a>
<h2 id="入门第一步">入门第一步</h2>
<p>以下4篇材料出色地解释了构建分布式系统会遇到的一些挑战，共同概述了一系列分布式系统工程师必须要解决的技术上的难题，为之后章节中更深入的研究做好准备。</p>
<ul>
<li><a href="http://book.mixu.net/distsys/" target="_blank" rel="external">好玩又实在的分布式系统理论</a>是一本简短的书籍，其内容覆盖了分布式系统领域的一些基本议题，包括时间的作用及不同的复制策略。 《Distributed Systems for Fun and Profit》</li>
<li><a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/" target="_blank" rel="external">为分布式系统领域新人整理的笔记</a> - 不是理论对理论地讲述，而是做一个非常好非常实用的平衡，让你对其余材料的阅读能够落地。《Notes on distributed systems for young bloods》</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.7628" target="_blank" rel="external">分布式系统研究综述报告</a> - 一篇经典的论文，解释了为什么不能将所有远程交互都模拟成和本地对象一样。《A Note on Distributed Systems》</li>
<li><a href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing" target="_blank" rel="external">关于分布式计算的若干谬论</a> - 分布式计算方面的8点谬论，提醒系统设计者可能会忘记的几类事情。《The fallacies of distributed computing》</li>
</ul>
<h2 id="失败和时间">失败和时间</h2>
<p>分布式系统工程师需要面对的许多困难最终都可以归咎于两个潜在的原因：</p>
<ul>
<li>进程可能会失败</li>
<li>不存在一种好的方式来周知目前为止进程已经做了些什么</li>
</ul>
<p>进程之间对于时间的认知能共享些什么？哪些失败的场景是能够检测到？什么算法和原语可能被正确地实现？这三个问题有着非常深层的联系。多数时候，我们会假设两个不同节点之间对于时间概念或时间以什么样的速度逝去没有任何可共享的认知。</p>
<p>你应该知道：</p>
<ul>
<li>失败模式的（部分）分层：<a href="http://www.cse.psu.edu/~gcao/teach/513-00/c7.pdf" target="_blank" rel="external">崩溃停止-&gt;排除(omission)</a>-&gt;<a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance" target="_blank" rel="external">拜占庭容错</a>。你应该理解：在高层次上可能发生的问题在低层次上肯定可能发生，在低层次上不可能发生的问题在高层次上也肯定不可能发生。</li>
<li>在没有任何共享时钟的情况下如何判断在另一个事件之前是否产生了某事件。这意味着你需要理解<a href="http://web.stanford.edu/class/cs240/readings/lamport.pdf" target="_blank" rel="external">Lamport时钟</a>及其一般化的<a href="http://en.wikipedia.org/wiki/Vector_clock" target="_blank" rel="external">向量时钟</a>，也需要阅读一下这篇<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">Dynamo论文</a>。</li>
<li>单个失败发生的可能性对于我们实现正确的分布式系统到底会有多大的影响（请阅读下面关于FLP结果的笔记）？</li>
<li>不同的时间模型：同步、部分同步和异步（若我找到好的参考文献会添加链接）</li>
</ul>
<h2 id="容错的基本矛盾">容错的基本矛盾</h2>
<p>一个系统，若要不降级而容忍某些错误的发生，就必须能够好像那些错误没有发生一样地运作。这通常意味着系统的这些部分必须能够冗余地工作，但是非绝对必要地做更多的工作通常会在性能和资源耗用方面产生一些消耗。这是为系统添加容错带来的基本矛盾。</p>
<p>你应该知道：</p>
<ul>
<li>确保单拷贝可串行化(single-copy serialisability)的仲裁(quorum)技术。可阅读<a href="https://ecommons.library.cornell.edu/bitstream/1813/6323/1/82-483.pdf" target="_blank" rel="external">Skeen的原始论文</a>，但可能更建议阅读<a href="http://en.wikipedia.org/wiki/Quorum_(distributed_computing" target="_blank" rel="external">这个Wikipedia词条</a>)。</li>
<li>关于<a href="http://the-paper-trail.org/blog/consensus-protocols-two-phase-commit/" target="_blank" rel="external">两阶段提交</a>、<a href="http://the-paper-trail.org/blog/consensus-protocols-three-phase-commit/" target="_blank" rel="external">三阶段提交</a>和<a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/" target="_blank" rel="external">Paxos算法</a>，以及为什么它们有不同的容错性质。</li>
<li>最终一致性，及其他技术是如何以弱化对系统行为的保证为代价来尝试避免这种矛盾的。这篇<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="external">Dynamo论文</a>是一个很好的起点，同时Pat Helland的经典之作<a href="http://www.ics.uci.edu/~cs223/papers/cidr07p15.pdf" target="_blank" rel="external">Life Beyond Transactions</a>也是必读的。</li>
</ul>
<h2 id="基本的原语">基本的原语</h2>
<p>分布式系统中很少有大家一致认同的基本构建块，但越来越多地在出现。你应该以下的问题是什么，以及在哪可以找到它们的解决方案：</p>
<ul>
<li>Leader选举(leader election)（例如<a href="http://en.wikipedia.org/wiki/Bully_algorithm" target="_blank" rel="external">Bully算法</a>）</li>
<li>一致的快照（例如Chandy和Lamport所写的<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/chandy.pdf" target="_blank" rel="external">经典论文</a>）</li>
<li>共识（阅读上文提到的关于2PC和Paxos的博文）</li>
<li>分布式状态机复制（看看<a href="http://en.wikipedia.org/wiki/State_machine_replication" target="_blank" rel="external">Wikipedia</a>就可以，但<a href="http://research.microsoft.com/en-us/um/people/blampson/58-Consensus/Acrobat.pdf" target="_blank" rel="external">Lampson的论文</a>更权威，只是枯燥了点）。</li>
</ul>
<h2 id="基础结论">基础结论</h2>
<p>某些客观事实是需要内化于心的，以下是几个关键点（a flavour）（当然还有更多）：</p>
<ul>
<li>如果进程之间可能丢失某些消息，那么不可能在实现一致性存储的同时能响应所有的请求。这就是<a href="http://lpd.epfl.ch/sgilbert/pubs/BrewersConjecture-SigAct.pdf" target="_blank" rel="external">CAP定理</a>。</li>
<li>一致性不可能同时满足以下条件 a) 总是正确 b) 在异步系统中只要有一个机器发生故障，系统总是能终止运行——停止失败（FLP 结论）。在给出证明之前，首先是一个我在洛杉矶演讲的幻灯片：我们喜爱的论文，我希望它能合理的解释这个结论。<br>建议：确实没有必要理解其证明。</li>
<li>一般而言，消息交互少于两轮是不可能达成共识(Consensus)。</li>
</ul>
<h2 id="真实系统">真实系统</h2>
<p>最重要的练习是重复地阅读新兴的、真实系统的描述，并尝试评价它们的设计决策。一遍又一遍地这样去做。一些建议：</p>
<p><strong>Google</strong>:</p>
<p><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/gfs-sosp2003.pdf" target="_blank" rel="external">GFS</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/spanner-osdi2012.pdf" target="_blank" rel="external">Spanner</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41344.pdf" target="_blank" rel="external">F1</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/chubby-osdi06.pdf" target="_blank" rel="external">Chubby</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/bigtable-osdi06.pdf" target="_blank" rel="external">BigTable</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41378.pdf" target="_blank" rel="external">MillWheel</a>、<a href="http://eurosys2013.tudos.org/wp-content/uploads/2013/paper/Schwarzkopf.pdf" target="_blank" rel="external">Omega</a>、<a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf" target="_blank" rel="external">Dapper</a>、<a href="http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/papers/paper2-1.pdf" target="_blank" rel="external">Paxos Made Live</a>、<a href="http://cacm.acm.org/magazines/2013/2/160173-the-tail-at-scale/abstract" target="_blank" rel="external">The Tail At Scale</a>。</p>
<p><strong>Not Google</strong>:</p>
<p><a href="http://research.microsoft.com/en-us/projects/dryad/eurosys07.pdf" target="_blank" rel="external">Dryad</a>, <a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf" target="_blank" rel="external">Cassandra</a>, <a href="http://ceph.com/papers/weil-ceph-osdi06.pdf" target="_blank" rel="external">Ceph</a>, <a href="https://ramcloud.stanford.edu/wiki/display/ramcloud/RAMCloud+Papers" target="_blank" rel="external">RAMCloud</a>, <a href="http://hyperdex.org/papers/" target="_blank" rel="external">HyperDex</a>, <a href="http://www.mpi-sws.org/~druschel/courses/ds/papers/cooper-pnuts.pdf" target="_blank" rel="external">PNUTS</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文：<a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">Distributed systems theory for the distributed systems engineer</a></p>
<p>译者：<a href="http://blog.xiayf.cn/2014/08/10/Distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="external">youngsterxyf</a></p>
<p>Gwen Shapira，大腕级的解决方案架构师（SA），如今Cloudera的全职工程师，在<a href="https://twitter.com/gwenshap/status/497203248332165121" target="_blank" rel="external">Twitter上提的一个问题</a>引起了我的思考。</p>
<p>如果是以前，我可能会回答“嗯，这里有篇FLP论文，这里有篇Paxos论文，这里还有篇拜占庭将军问题的论文...”，我会罗列一箩筐重要的材料，如果你一头扎进去，至少花费6个月的时间才能过一遍这些材料。然而我已逐渐明白推荐大量的理论性的论文通常恰恰是着手学习分布式系统理论的错误方式（除非你在做一个PhD项目）。论文通常比较深入难懂，需要认真地研习，通常还需要大量的时间投入(significant experience)来理清这些论文的重要贡献，以及在整个理论体系中的位置。要求工程师具备这样的专业水平又有多大的意义呢？</p>
<p>但是，很遗憾，对分布式系统理论方面的重大研究成果和思想进行概括、归纳、背景分析的‘导引’性质的优秀材料非常缺乏；特别是没有居高临下态度的材料。对这块空白区域的思考让我想到了另一个有趣的问题：</p>
<blockquote>
<p>一个分布式系统工程师应该知道些什么分布式系统理论？</p>
</blockquote>
<p>在这种情况下，一知半解(a little theory)并不会是一件多危险的事情。因此我尝试整理一个列表，罗列出作为一个分布式系统工程师的我认为能够直接应用于我日常工作的一些基本概念；或者让分布式系统工程师完全有能力设计一个新系统的“筹码”。如果你认为我漏掉了一些东西，请联系我。</p>
]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]使用 bcc/BPF 分析 go 程序]]></title>
    <link href="http://colobu.com/2017/09/22/golang-bcc-bpf-function-tracing/"/>
    <id>http://colobu.com/2017/09/22/golang-bcc-bpf-function-tracing/</id>
    <published>2017-09-22T06:03:54.000Z</published>
    <updated>2017-09-30T14:15:44.755Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>BCC 是基于 BPF 的 Linux IO 分析、监控、网络工具集合。BPF Compiler Collection (BCC) 是创建高效内核追踪和处理程序的工具包，包含几个有用的工具和用例。BCC 扩展了 BPF (Berkeley Packet Filters) 的用途，BPF 之前被称为 eBPF，是 Linux 3.15 新增的一个新特性。BCC 大部分的功能都要求 Linux 4.1+。</p>
</blockquote>
<p>本文翻译自性能分析大牛<a href="http://www.brendangregg.com/index.html" target="_blank" rel="external">Brendan Gregg</a>的 2017年中旬的一篇文章: <a href="http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html" target="_blank" rel="external">Golang bcc/BPF Function Tracing</a>, 介绍如何使用最新的工具更加深入的分析Go程序。</p>
<a id="more"></a>
<p><img src="bcc_tracing_tools_2017.png" alt="Linux bbc/BPF tracing tools"></p>
<p>本文中我将逐步展示一个新的分析Go程序的方式： 使用Linux 4.x的 eBPF 技术进行动态分析。如果你搜索一下<code>go</code>和<code>BPF</code>关键字， 你会发现一些使用 BPF的Go程序库(比如 <a href="https://github.com/iovisor/gobpf" target="_blank" rel="external">gobpf</a>)。这并不是我想在本文中介绍的：我是要使用 BPF 来对Go程序进行性能分析和调试。 如果你还不了解 BPF, 我几周前在 linux.conf.au 有一些介绍 (<a href="https://www.youtube.com/watch?v=JRFNIKUROPE" target="_blank" rel="external">youtube</a>, <a href="http://www.slideshare.net/brendangregg/bpf-tracing-and-more" target="_blank" rel="external">slideshare</a>)。</p>
<p>现在已经有一些方式可以调试和跟踪(debug and trace)Go程序, 包括(但不限于下列方式):</p>
<ul>
<li>使用 <a href="https://golang.org/doc/gdb" target="_blank" rel="external">gdb</a>和 go runtime支持</li>
<li><a href="https://golang.org/pkg/runtime/trace/" target="_blank" rel="external">go execution tracer</a></li>
<li>GODEBUG, 使用 gctrace 和 schedtrace 参数</li>
</ul>
<p>BPF tracing技术可以做更多的工作，当然它也有自己的优缺点，下面我会用一个简单的<code>hello.go</code>程序来演示这些：</p>
<figure class="highlight go"><figcaption><span>hello.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">        fmt.Println(<span class="string">"Hello, BPF!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我会用<code>gccgo</code>先编译，然后再用 go 自己的编译器来编译 (如果你不知道它们之间的区别，请看 VonC 做的这个 <a href="http://stackoverflow.com/a/25811505" target="_blank" rel="external">总结</a>。 一句话, gccgo可以产生更加优化的二进制文件，但适用于更老版本的go)。</p>
<h3 id="函数统计_(gccgo)">函数统计 (gccgo)</h3>
<p>编译:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gccgo -o hello hello.<span class="keyword">go</span></div><div class="line">$ ./hello</div><div class="line">Hello, BPF!</div></pre></td></tr></table></figure>

<p>现在可以使用 <a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc</a> tool <code>funccount</code> 动态跟踪和统计所有的以<code>fmt.</code>开头的Go库函数，我同时会在另外一个终端中运行这个hello程序：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funccount 'go:fmt.*'</span></div><div class="line">Tracing <span class="number">160</span> functions <span class="keyword">for</span> <span class="string">"go:fmt.*"</span><span class="keyword">...</span> Hit Ctrl-C to end.</div><div class="line">^C</div><div class="line">FUNC                                    COUNT</div><div class="line">fmt..import                                 <span class="number">1</span></div><div class="line">fmt.padString.pN7_fmt.fmt                   <span class="number">1</span></div><div class="line">fmt.fmt_s.pN7_fmt.fmt                       <span class="number">1</span></div><div class="line">fmt.WriteString.pN10_fmt.buffer             <span class="number">1</span></div><div class="line">fmt.free.pN6_fmt.pp                         <span class="number">1</span></div><div class="line">fmt.fmtString.pN6_fmt.pp                    <span class="number">1</span></div><div class="line">fmt.doPrint.pN6_fmt.pp                      <span class="number">1</span></div><div class="line">fmt.init.pN7_fmt.fmt                        <span class="number">1</span></div><div class="line">fmt.printArg.pN6_fmt.pp                     <span class="number">1</span></div><div class="line">fmt.WriteByte.pN10_fmt.buffer               <span class="number">1</span></div><div class="line">fmt.Println                                 <span class="number">1</span></div><div class="line">fmt.truncate.pN7_fmt.fmt                    <span class="number">1</span></div><div class="line">fmt.Fprintln                                <span class="number">1</span></div><div class="line">fmt.$nested1                                <span class="number">1</span></div><div class="line">fmt.newPrinter                              <span class="number">1</span></div><div class="line">fmt.clearflags.pN7_fmt.fmt                  <span class="number">2</span></div><div class="line">Detaching...</div></pre></td></tr></table></figure>

<p>漂亮! 输出结果中包含了<code>fmt.Println()</code>, 还有一些其它的调用。</p>
<p>实际并不需要以特定的方式运行Go程序， 你可以跟踪一个已经运行的Go程序进程，并不需要重新启动它， 怎么做呢？</p>
<ul>
<li>使用 <a href="http://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html" target="_blank" rel="external">Linux uprobes: User-Level Dynamic Tracing</a>, Linux 3.5中增加的一个功能。 它使用一个软中断重写了kernel的指令，并且当跟踪程序结束的时候会恢复进程。</li>
<li>gccgo编译的程序有一个标准的符号表，可以用来查询函数。</li>
<li>本例中使用了 <code>libgo</code>, 它包含<code>fmt</code>包。</li>
<li>uprobes可以附加到已经运行的进程上， 或者像我上面做的那样， 捕获所有使用它的进程。</li>
<li>更有效地， 我经常统计内核上下文的函数调用次数， 只将调用次数发送到用户空间。</li>
</ul>
<p>对于操作系统来讲， 这个二进制文件的信息如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>file hello</div><div class="line"><span class="symbol">hello:</span> <span class="constant">ELF</span> <span class="number">64</span>-bit <span class="constant">LSB</span> executable, x86-<span class="number">64</span>, version <span class="number">1</span> (<span class="constant">SYSV</span>), dynamically linked, interpreter /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span>, <span class="keyword">for</span> <span class="constant">GNU</span>/<span class="constant">Linux</span> <span class="number">2.6</span>.<span class="number">32</span>, <span class="constant">BuildID</span>[sha1]=<span class="number">4</span>dc45f1eb023f44ddb32c15bbe0fb4f933e61815, <span class="keyword">not</span> stripped</div><div class="line"><span class="variable">$ </span>ls -lh hello</div><div class="line">-rwxr-xr-x <span class="number">1</span> bgregg root <span class="number">29</span>K <span class="constant">Jan</span> <span class="number">12</span> <span class="number">21</span><span class="symbol">:</span><span class="number">18</span> hello</div><div class="line"><span class="variable">$ </span>ldd hello</div><div class="line">    linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0x00007ffc4cb1a000</span>)</div><div class="line">    libgo.so.<span class="number">9</span> =&gt; <span class="regexp">/usr/lib</span><span class="regexp">/x86_64-linux-gnu/libgo</span>.so.<span class="number">9</span> (<span class="number">0x00007f25f2407000</span>)</div><div class="line">    libgcc_s.so.<span class="number">1</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libgcc_s.so.<span class="number">1</span> (<span class="number">0x00007f25f21f1000</span>)</div><div class="line">    libc.so.<span class="number">6</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libc.so.<span class="number">6</span> (<span class="number">0x00007f25f1e27000</span>)</div><div class="line">    /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0x0000560b44960000</span>)</div><div class="line">    libpthread.so.<span class="number">0</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libpthread.so.<span class="number">0</span> (<span class="number">0x00007f25f1c0a000</span>)</div><div class="line">    libm.so.<span class="number">6</span> =&gt; <span class="regexp">/lib/x</span>86_64-linux-gnu/libm.so.<span class="number">6</span> (<span class="number">0x00007f25f1901000</span>)</div><div class="line"><span class="variable">$ </span>objdump -tT /usr/lib/x86_64-linux-gnu/libgo.so.<span class="number">9</span> | grep fmt.<span class="constant">Println</span></div><div class="line"><span class="number">0000000001221070</span> g     <span class="constant">O</span> .data.rel.ro   <span class="number">000000000000000</span>8              fmt.<span class="constant">Println</span><span class="variable">$descriptor</span></div><div class="line"><span class="number">0000000000</span>97809<span class="number">0</span> g     <span class="constant">F</span> .text  <span class="number">0000000000000075</span>              fmt.<span class="constant">Println</span></div><div class="line"><span class="number">0000000001221070</span> g    <span class="constant">DO</span> .data.rel.ro   <span class="number">000000000000000</span>8  <span class="constant">Base</span>        fmt.<span class="constant">Println</span><span class="variable">$descriptor</span></div><div class="line"><span class="number">0000000000</span>97809<span class="number">0</span> g    <span class="constant">DF</span> .text  <span class="number">0000000000000075</span>  <span class="constant">Base</span>        fmt.<span class="constant">Println</span></div></pre></td></tr></table></figure>

<p>看起来像编译的 C 程序， 你可以使用很多已有的调试器和跟踪器， 包括 bcc/BPF。 而且比那么即时编译的运行时比如 Java 和 Node.js更容易操作。目前唯一一点不爽的就是函数名包含一些非标准的字符， 比如本例中的&quot;.&quot; 。</p>
<p><code>funccount</code> 支持一些参数， 比如<code>-p</code>指定某个进程ID, <code>-i</code>指定输出的时间间隔。它当前只能同时支持最多1000个跟踪对象(probe), 对于<code>fmt.*</code>来说，函数不多还OK, 但是如果跟踪所有的<code>libgo</code>中的函数就有问题了:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funccount 'go:*'</span></div><div class="line">maximum <span class="keyword">of</span> <span class="number">1000</span> probes allowed, attempted <span class="number">21178</span></div></pre></td></tr></table></figure>

<p>嗯哼， 不工作了。 就像 bcc/BPF 中其它一些问题一样， 如果这个限制在应用中阻碍太多的话我们考虑寻找一个方式来解决它。</p>
<h3 id="函数统计_(Go_gc)">函数统计 (Go gc)</h3>
<p>使用 Go gc编译器来编译:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> build hello.<span class="keyword">go</span></div><div class="line">$ ./hello</div><div class="line">Hello, BPF!</div></pre></td></tr></table></figure>

<p>统计 <code>fmt</code> 的函数调用:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funccount '/home/bgregg/hello:fmt.*'</span></div><div class="line">Tracing <span class="number">78</span> functions <span class="keyword">for</span> <span class="string">"/home/bgregg/hello:fmt.*"</span><span class="keyword">...</span> Hit Ctrl-C to end.</div><div class="line">^C</div><div class="line">FUNC                                    COUNT</div><div class="line">fmt.init.1                                  <span class="number">1</span></div><div class="line">fmt.(*fmt).padString                        <span class="number">1</span></div><div class="line">fmt.(*fmt).truncate                         <span class="number">1</span></div><div class="line">fmt.(*fmt).fmt_s                            <span class="number">1</span></div><div class="line">fmt.newPrinter                              <span class="number">1</span></div><div class="line">fmt.(*pp).free                              <span class="number">1</span></div><div class="line">fmt.Fprintln                                <span class="number">1</span></div><div class="line">fmt.Println                                 <span class="number">1</span></div><div class="line">fmt.(*pp).fmtString                         <span class="number">1</span></div><div class="line">fmt.(*pp).printArg                          <span class="number">1</span></div><div class="line">fmt.(*pp).doPrint                           <span class="number">1</span></div><div class="line">fmt.glob.func1                              <span class="number">1</span></div><div class="line">fmt.init                                    <span class="number">1</span></div><div class="line">Detaching...</div></pre></td></tr></table></figure>

<p>你仍然可以跟踪<code>fmt.Println()</code>, 但是现在是从二进制程序中找到它， 而不是在<code>libgo</code>中， 这是因为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>file hello</div><div class="line"><span class="symbol">hello:</span> <span class="constant">ELF</span> <span class="number">64</span>-bit <span class="constant">LSB</span> executable, x86-<span class="number">64</span>, version <span class="number">1</span> (<span class="constant">SYSV</span>), statically linked, <span class="keyword">not</span> stripped</div><div class="line"><span class="variable">$ </span>ls -lh hello</div><div class="line">-rwxr-xr-x <span class="number">1</span> bgregg root <span class="number">2.2</span>M <span class="constant">Jan</span> <span class="number">12</span> <span class="number">05</span><span class="symbol">:</span><span class="number">16</span> hello</div><div class="line"><span class="variable">$ </span>ldd hello</div><div class="line">    <span class="keyword">not</span> a dynamic executable</div><div class="line"><span class="variable">$ </span>objdump -t hello | grep fmt.<span class="constant">Println</span></div><div class="line"><span class="number">000000000045</span>a68<span class="number">0</span> g     <span class="constant">F</span> .text  <span class="number">00000000000000</span>e<span class="number">0</span> fmt.<span class="constant">Println</span></div></pre></td></tr></table></figure>

<p>它包含一个 2M的静态库， 这个库中包含<code>fmt</code>的函数。</p>
<p>另外一个不同就是函数名中包含不常见的符号: &quot;*&quot;, &quot;(&quot;等等。</p>
<h3 id="函数跟踪_(gccgo)">函数跟踪 (gccgo)</h3>
<p>这次我将尝试 Sasha Goldshtein 的跟踪工具， 也是 <a href="https://github.com/iovisor/bcc" target="_blank" rel="external">bcc</a>跟踪工具集中一个。我会使用它来观察函数的每次调用。<br>还是先使用<code>gccgo</code>来编译， 这次的简单小程序叫做 <code>functions.go</code>:</p>
<figure class="highlight go"><figcaption><span>functions.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> add(x <span class="typename">int</span>, y <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    fmt.Println(add<span class="number">(42</span>,<span class="number"> 13</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>开始跟踪 <code>add()</code> 函数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add'</span></div><div class="line">PID    TID    COMM         FUNC             </div><div class="line"><span class="number">14424</span>  <span class="number">14424</span>  functions    main.<span class="built_in">add</span></div></pre></td></tr></table></figure>

<p>还可以查看它的传入的参数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" arg1, arg2'</span></div><div class="line">PID    TID    COMM         FUNC             -</div><div class="line"><span class="number">14390</span>  <span class="number">14390</span>  functions    main.<span class="built_in">add</span>         <span class="number">42</span> <span class="number">13</span></div></pre></td></tr></table></figure>

<p>酷，工作正常，参数显示正确。</p>
<p><code>trace</code> 还有其它的参数(使用 -h 查看), b比如时间戳、堆栈信息等。</p>
<h3 id="函数跟踪_(Go_gc)">函数跟踪 (Go gc)</h3>
<p>目前位置一切按照预想的执行。 同样的程序， 使用 <code>go gc</code>编译器来编译:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> build functions.<span class="keyword">go</span></div><div class="line"></div><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" arg1, arg2'</span></div><div class="line">could not determine address of symbol main.<span class="built_in">add</span></div><div class="line"></div><div class="line">$ objdump -<span class="keyword">t</span> functions | <span class="keyword">grep</span> main.<span class="built_in">add</span></div><div class="line">$</div></pre></td></tr></table></figure>

<p>什么？没有<code>main.add()</code>函数？ 难道它被内联了？禁止内联：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">go</span> build -gcflags <span class="string">'-l'</span> functions.<span class="keyword">go</span></div><div class="line">$ objdump -<span class="keyword">t</span> functions | <span class="keyword">grep</span> main.<span class="built_in">add</span></div><div class="line"><span class="number">0000000000401000</span> <span class="keyword">g</span>     F .text  <span class="number">0000000000000020</span> main.<span class="built_in">add</span></div></pre></td></tr></table></figure>

<p>现在好了，虚惊一场。 跟踪这个程序和它的参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" arg1, arg2'</span></div><div class="line">PID    TID    COMM         FUNC             -</div><div class="line"><span class="number">16061</span>  <span class="number">16061</span>  functions    main.<span class="built_in">add</span>         <span class="number">536912504</span> <span class="number">16</span></div></pre></td></tr></table></figure>

<p>有点不对， 参数应该是 <code>42</code> 和 <code>13</code>,并不是<code>536912504</code> 和 <code>16</code>。</p>
<p>超期gdb调试:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">$ gdb ./functions</div><div class="line">[<span class="keyword">...</span>]</div><div class="line"><span class="keyword">warning</span>: File <span class="string">"/usr/share/go-1.6/src/runtime/runtime-gdb.py"</span> auto-loading has been declined</div><div class="line"> by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".</div><div class="line">[...]</div><div class="line">(gdb) b main.add</div><div class="line">Breakpoint 1 at 0x401000: file /home/bgregg/functions.go, line 6.</div><div class="line">(gdb) r</div><div class="line">Starting program: /home/bgregg/functions </div><div class="line">[New LWP 16082]</div><div class="line">[New LWP 16083]</div><div class="line">[New LWP 16084]</div><div class="line"></div><div class="line">Thread 1 "functions" hit Breakpoint 1, main.add (x=42, y=13, ~r2=4300314240) at</div><div class="line"> /home/bgregg/functions.go:6</div><div class="line">6           return x + y</div><div class="line">(gdb) i r</div><div class="line">rax            0xc820000180 859530330496</div><div class="line">rbx            0x584ea0 5787296</div><div class="line">rcx            0xc820000180 859530330496</div><div class="line">rdx            0xc82005a048 859530698824</div><div class="line">rsi            0x10 16</div><div class="line">rdi            0xc82000a2a0 859530371744</div><div class="line">rbp            0x0  0x0</div><div class="line">rsp            0xc82003fed0 0xc82003fed0</div><div class="line">r8             0x41 65</div><div class="line">r9             0x41 65</div><div class="line">r10            0x4d8ba0 5082016</div><div class="line">r11            0x0  0</div><div class="line">r12            0x10 16</div><div class="line">r13            0x52a3c4 5415876</div><div class="line">r14            0xa  10</div><div class="line">r15            0x8  8</div><div class="line">rip            0x401000 0x401000 </div><div class="line">eflags         0x206    [ PF IF ]</div><div class="line">cs             0xe033   57395</div><div class="line">ss             0xe02b   57387</div><div class="line">ds             0x0  0</div><div class="line">es             0x0  0</div><div class="line">fs             0x0  0</div><div class="line">gs             0x0  0</div></pre></td></tr></table></figure>

<p>我包含了<code>runtime-gdb.py</code>启动时的警告， 这个警告很有用：如果我想更深入到go的上下文， 我会解决这个问题。及时忽略这个问题, gdb也显示了参数的&quot;x=42, y=13&quot;.</p>
<p>我也检查了寄存器的值， bcc的trace程序也是从这些寄存器中得到的值。 从 <code>syscall(2)</code> man帮助中可以知道：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">       arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes</div><div class="line">       ──────────────────────────────────────────────────────────────────</div><div class="line">[<span class="keyword">...</span>]</div><div class="line">       x86_64        rdi   rsi   rdx   r10   r8    r9    -</div></pre></td></tr></table></figure>

<p>但是 42 和 13 并没有在寄存器 rdi 或者 rsi 中， 原因在于Go gc编译器并不遵循标准的 AMD ABI 函数调用约定， 这导致这个调试器或者其它的调试器跟踪参数有问题(我以前也听过前同事抱怨过这个问题)。我猜Go需要使用一个不同的ABI来返回值， 因为它需要返回多个值。</p>
<p>我查看了 Go 汇编器的快速手册， 还有Plan 9 的汇编手册，看起来函数在栈上传递，  42 和 13在栈上:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) x/3dg $<span class="literal">rsp</span></div><div class="line"><span class="number">0xc82003fed0</span>:   <span class="number">4198477</span> <span class="number">42</span></div><div class="line"><span class="number">0xc82003fee0</span>:   <span class="number">13</span></div></pre></td></tr></table></figure>

<p>BPF也可以获取这些值， 作为验证， 我 hacked几个别名， 把这些参数叫做<code>go1</code>,<code>go2</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># trace <span class="string">'/home/bgregg/functions:main.add "%d %d" go1, go2'</span></div><div class="line">PID    TID    COMM         FUNC             -</div><div class="line"><span class="number">17555</span>  <span class="number">17555</span>  functions    main.<span class="built_in">add</span>         <span class="number">42</span> <span class="number">13</span></div></pre></td></tr></table></figure>

<p>完美。希望你读到这篇文章的时候， 我(或者其他人)已经解决了这个问题，并把它加入懂啊 bcc trace工具中。 可能叫&quot;goarg1&quot;, &quot;goarg2&quot;更好。</p>
<h3 id="Interface_参数">Interface 参数</h3>
<p>下面我会演示另一个<code>fmt.Println()</code>打印字符串的例子，但这一次参数是<code>interface</code>类型。从 go 的 <code>src/fmt/print.go</code>源代码中可以看到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Println(a ...<span class="keyword">interface</span>{}) (n <span class="typename">int</span>, err error) {</div><div class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</div></pre></td></tr></table></figure>

<p>使用gccgo编译， 然后使用 gdb 调试 你可以看到这个字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ gdb ./hello</div><div class="line">[<span class="keyword">...</span>]</div><div class="line">(gdb) b fmt.Println</div><div class="line">Breakpoint <span class="number">1</span> at <span class="number">0x401c50</span></div><div class="line">(gdb) r</div><div class="line">Starting program: /home/bgregg/hello </div><div class="line">[Thread debugging using libthread_db enabled]</div><div class="line">Using host libthread_db <span class="keyword">library</span> <span class="string">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span>.</div><div class="line">[New Thread <span class="number">0x7ffff449c700</span> (LWP <span class="number">16836</span>)]</div><div class="line">[New Thread <span class="number">0x7ffff3098700</span> (LWP <span class="number">16837</span>)]</div><div class="line">[Switching to Thread <span class="number">0x7ffff3098700</span> (LWP <span class="number">16837</span>)]</div><div class="line"></div><div class="line">Thread <span class="number">3</span> <span class="string">"hello"</span> hit Breakpoint <span class="number">1</span>, fmt.Println (a=<span class="keyword">...</span>) at ../../../src/libgo/go/fmt/print.go:<span class="number">263</span></div><div class="line"><span class="number">263</span> ../../../src/libgo/go/fmt/print.go: No such file or directory.</div><div class="line">(gdb) p a</div><div class="line">$<span class="number">1</span> = {__values = <span class="number">0xc208000240</span>, __count = <span class="number">1</span>, __capacity = <span class="number">1</span>}</div><div class="line">(gdb) p a.__values</div><div class="line">$<span class="number">18</span> = (struct {<span class="keyword">...</span>} *) <span class="number">0xc208000240</span></div><div class="line">(gdb) p a.__values[<span class="number">0</span>]</div><div class="line">$<span class="number">20</span> = {__type_descriptor = <span class="number">0x4037c0</span> &lt;__go_tdn_string&gt;, __object = <span class="number">0xc208000210</span>}</div><div class="line">(gdb) x/s *<span class="number">0xc208000210</span></div><div class="line"><span class="number">0x403483</span>:   <span class="string">"Hello, BPF!"</span></div></pre></td></tr></table></figure>

<p>可以正常查到这个字符串（我不确定是否有更容易的方式检查）。你也可以写一个定制的 bcc/BPF 程序来检查， 我们可以增加更多的别名来命名这些接口参数。</p>
<h3 id="函数耗时">函数耗时</h3>
<p>下面是一个跟踪函数耗时的简单例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># funclatency 'go:fmt.Println'</span></div><div class="line"><span class="constant">Tracing </span><span class="number">1</span> functions <span class="keyword">for</span> <span class="string">"go:fmt.Println"</span>... <span class="constant">Hit Ctrl-C </span>to <span class="keyword">end</span>.</div><div class="line">^<span class="constant">C</span></div><div class="line"></div><div class="line"><span class="constant">Function </span>= fmt.<span class="constant">Println </span>[<span class="number">3041</span>]</div><div class="line">     nsecs               <span class="symbol">:</span> count     distribution</div><div class="line">         <span class="number">0</span> -&gt; <span class="number">1</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">2</span> -&gt; <span class="number">3</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">4</span> -&gt; <span class="number">7</span>          <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">         <span class="number">8</span> -&gt; <span class="number">15</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">16</span> -&gt; <span class="number">31</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">32</span> -&gt; <span class="number">63</span>         <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">        <span class="number">64</span> -&gt; <span class="number">127</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">128</span> -&gt; <span class="number">255</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">256</span> -&gt; <span class="number">511</span>        <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">       <span class="number">512</span> -&gt; <span class="number">1023</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">1024</span> -&gt; <span class="number">2047</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">2048</span> -&gt; <span class="number">4095</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">4096</span> -&gt; <span class="number">8191</span>       <span class="symbol">:</span> <span class="number">0</span>        |                                        |</div><div class="line">      <span class="number">8192</span> -&gt; <span class="number">16383</span>      <span class="symbol">:</span> <span class="number">27</span>       |****************************************|</div><div class="line">     <span class="number">16384</span> -&gt; <span class="number">32767</span>      <span class="symbol">:</span> <span class="number">3</span>        |****                                    |</div><div class="line"><span class="constant">Detaching.</span>..</div></pre></td></tr></table></figure>

<p>它显示了<code>fmt.Println()</code>函数耗时的直方图(单位纳秒), 我在一个循环中不停的调用这个函数。</p>
<p><strong>⚠️警告</strong>: 这里有些不幸的问题： 如果在方法调用的时候goroutine从一个操作系统线程切换到另外一个线程，<code>funclatency</code>程序并不会找匹配的返回。 我们需要一个新工具， <code>gofunclatency</code>, 使用 go的内部 <code>GOID</code> 来跟踪耗时， 而不是根据操作系统的<code>TID</code>。同时修改<code>uretprobes</code>修改Go进程可能导致Go进程崩溃， 我们需要调试和制定一个修复计划。可以查看 Suresh 的评论以了解其中的细节。</p>
<h3 id="下一步">下一步</h3>
<p>利用动态跟踪和Linux eBPF技术，使用bcc的<code>funccount</code>和<code>trace</code>工具，我们快速了解了一个新的调试Go程序的技术。有些功能非常成功，有些功能还有一些挑战。 函数调用统计工作很完美，但是跟踪gccgo编译的函数参数的时候美问题，但是跟踪Go gc编译的函数参数有些问题， 因为Go gc编译器没有遵循标准的ABI调用约定，所以这个工具需要加强。 作为概念性的验证，我修改了bcc trace工具来显示Go gc编译的函数参数，但是这个特性需要正确实现和集成。处理接口对象也是一个挑战，因为Go支持多返回值， 这些都是我们需要加强的工作，以便是这些调试和跟踪工作更容易， 就像在c中增加一些宏一样。</p>
<p>希望之后还有一个后续的文章来介绍这些bcc/BPF功能的提升(不一定是我，如果你感兴趣，请拿好接力棒)。</p>
<p>另一个重要的跟踪问题，可以在下一篇文章中介绍，就是堆栈(stack trace)。值得高兴的是， Go已经在 1.7中实现了基于 frame pointer的堆栈。</p>
<p>最后，另一个重要的可以单拉出一篇文章介绍的跟踪问题是和内核上下文一起跟踪Go函数。 BPF和bcc都可以跟踪内核函数， 和用户空间一样。可以想象我们可以创建一个新的工具来同时跟踪这两个。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>BCC 是基于 BPF 的 Linux IO 分析、监控、网络工具集合。BPF Compiler Collection (BCC) 是创建高效内核追踪和处理程序的工具包，包含几个有用的工具和用例。BCC 扩展了 BPF (Berkeley Packet Filters) 的用途，BPF 之前被称为 eBPF，是 Linux 3.15 新增的一个新特性。BCC 大部分的功能都要求 Linux 4.1+。</p>
</blockquote>
<p>本文翻译自性能分析大牛<a href="http://www.brendangregg.com/index.html" target="_blank" rel="external">Brendan Gregg</a>的 2017年中旬的一篇文章: <a href="http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html" target="_blank" rel="external">Golang bcc/BPF Function Tracing</a>, 介绍如何使用最新的工具更加深入的分析Go程序。</p>
]]>
    
    </summary>
    
      <category term="bbc" scheme="http://colobu.com/tags/bbc/"/>
    
      <category term="trace" scheme="http://colobu.com/tags/trace/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用配置文件格式]]></title>
    <link href="http://colobu.com/2017/08/31/configuration-file-format/"/>
    <id>http://colobu.com/2017/08/31/configuration-file-format/</id>
    <published>2017-08-31T02:24:17.000Z</published>
    <updated>2017-09-01T16:28:31.706Z</updated>
    <content type="html"><![CDATA[<p>配置文件是工程中常用的初始化参数的配置方式，而配置文件的格式有很多种，不同的操作系统、编程语言都会有不同的配置文件的格式，本文罗列了一些常见的配置文件的格式。</p>
<p>不同的配置文件格式有不同的用户友好性， 对于功能的支持也有简单和复杂之分，很难简单说那种配置文件是最好的，有时候需要从多个方面去考虑， 比如Windows较早的开发喜欢使用<code>int</code>、java喜欢使用<code>properties</code>、通用的编程喜欢<code>yaml</code>、<code>json</code>等格式，本文也不会对这些格式进行排名，而是简单介绍一下这些格式，用户可以根据自己的实际情况进行选择。</p>
<a id="more"></a>
<h3 id="ini">ini</h3>
<p>ini文件是一个无固定标准格式的配置文件。它以简单的文字与简单的结构组成，常常使用在Windows操作系统。ini文件的命名来源，是取自英文“初始（Initial）”的首字缩写，正与它的用途——初始化程序相应。</p>
<p>文件格式比较简单， 分为 <code>节</code>、<code>参数</code>、<code>注释</code>。下面是一个简单的ini配置文件：</p>
<figure class="highlight ini"><figcaption><span>https://github.com/Microsoft/Windows-driver-samples/blob/master/print/v4PrintDriverSamples/v4PrintDriver-HostBasedSampleDriver/usb_host_based_sample-manifest.ini</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="title">[DriverConfig]</span></div><div class="line"><span class="setting">DriverCategory=<span class="value">PrintFax.Printer</span></span></div><div class="line"><span class="setting">DataFile=<span class="value">usb_host_based_sample.gpd</span></span></div><div class="line"></div><div class="line"><span class="comment">; Note: Please replace the GUID below when building a production driver.</span></div><div class="line"><span class="setting">PrinterDriverID=<span class="value">{<span class="number">00000000</span>-<span class="number">0000</span>-<span class="number">0000</span>-<span class="number">0000</span>-<span class="number">000000000000</span>}</span></span></div><div class="line"><span class="setting">Flags=<span class="value">HostBasedDevice</span></span></div><div class="line"><span class="setting">EventFile=<span class="value">usb_host_based_sample_events.xml</span></span></div><div class="line"><span class="setting">RequiredFiles=<span class="value">UNIRES.DLL,STDNAMES.GPD,MSXPSINC.GPD</span></span></div><div class="line"></div><div class="line"><span class="title">[BidiFiles]</span></div><div class="line"><span class="setting">BidiUSBFile=<span class="value">usb_host_based_sample_extension.xml</span></span></div><div class="line"><span class="setting">BidiUSBJSFile=<span class="value">usb_host_based_sample.js</span></span></div></pre></td></tr></table></figure>

<h3 id="properties">properties</h3>
<p>properties是一种主要在Java相关技术中用来存储应用程序的可配置参数的文件的文件扩展名。它们也可以存储用于国际化和本地化的字符串，这种文件被称为属性资源包（Property Resource Bundles）。<br>每个参数被存储为一对字符串：一个存储名称参数（被称为“键”），另一个存储值。</p>
<p>每个properties 文件中的行通常存储单个属性。对于每一行可能有这么几种格式，包括键=值，键 = 值，键:值，以及键 值。<br>.properties文件可以使用井号（#）或叹号（!）作为一行中第一个非空白字符来表示它后面的所有文本都是一个注释。反斜杠（\）用于转义字符。下面是一个properties文件：</p>
<figure class="highlight properties"><figcaption><span>https://github.com/netgloo/spring-boot-samples/blob/master/spring-boot-mysql-springdatajpa-hibernate/src/main/resources/application.properties</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ===============================</div><div class="line"># = DATA SOURCE</div><div class="line"># ===============================</div><div class="line"></div><div class="line"># <span class="operator"><span class="keyword">Set</span> here configurations <span class="keyword">for</span> the <span class="keyword">database</span> <span class="keyword">connection</span></span></div><div class="line"></div><div class="line"># <span class="keyword">Connection</span> url <span class="keyword">for</span> the <span class="keyword">database</span> <span class="string">"netgloo_blog"</span></div><div class="line">spring.datasource.url = jdbc:mysql://localhost:<span class="number">3306</span>/netgloo_blog?useSSL=<span class="literal">false</span></div><div class="line"></div><div class="line"># Username <span class="keyword">and</span> <span class="keyword">password</span></div><div class="line">spring.datasource.username = root</div><div class="line">spring.datasource.<span class="keyword">password</span> = root</div><div class="line"></div><div class="line"># Keep the <span class="keyword">connection</span> alive <span class="keyword">if</span> idle <span class="keyword">for</span> a long <span class="keyword">time</span> (needed <span class="keyword">in</span> production)</div><div class="line">spring.datasource.testWhileIdle = <span class="literal">true</span></div><div class="line">spring.datasource.validationQuery = <span class="keyword">SELECT</span> <span class="number">1</span></div></pre></td></tr></table></figure>

<h3 id="json">json</h3>
<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，以文字为基础，且易于让人阅读。尽管JSON是Javascript的一个子集，但JSON是独立于语言的文本格式，并且采用了类似于C语言家族的一些习惯。<br>JSON 数据格式与语言无关，脱胎于 JavaScript，但目前很多编程语言都支持 JSON 格式数据的生成和解析, 所以也常常用作配置文件。</p>
<p>JSON用于描述数据结构，有以下形式存在。</p>
<ul>
<li>对象（object）：一个对象以<code>{</code>开始，并以<code>}</code>结束。一个对象包含一系列非排序的名称／值对，每个名称／值对之间使用<code>,</code>分区</li>
<li>名称／值（collection）：名称和值之间使用<code>：</code>隔开，一般的形式是：<code>{name:value}</code></li>
<li>值的有序列表（Array）：一个或者多个值用,分区后，使用<code>[，]</code>括起来就形成了这样的列表</li>
<li>字符串：以&quot;&quot;括起来的一串字符。</li>
<li>数值：一系列0-9的数字组合，可以为负数或者小数。还可以用e或者E表示为指数形式。</li>
<li>布尔值：表示为true或者false。</li>
</ul>
<p>JSON的格式描述可以参考RFC 4627。</p>
<p>下面是一个json配置文件的例子:</p>
<figure class="highlight json"><figcaption><span>https://github.com/hashicorp/vault/blob/master/command/server/test-fixtures/config.hcl.json</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">	"<span class="attribute">listener</span>": <span class="value">[{</span></div><div class="line">		"<span class="attribute">tcp</span>": <span class="value">{</span></div><div class="line">			"<span class="attribute">address</span>": <span class="value"><span class="string">"127.0.0.1:443"</span></span></div><div class="line">		}</div><div class="line">	}],</div><div class="line">	"<span class="attribute">cluster_cipher_suites</span>": <span class="value"><span class="string">"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"</span></span>,</div><div class="line">	"<span class="attribute">storage</span>": <span class="value">{</span></div><div class="line">		"<span class="attribute">consul</span>": <span class="value">{</span></div><div class="line">			"<span class="attribute">foo</span>": <span class="value"><span class="string">"bar"</span></span>,</div><div class="line">			"<span class="attribute">disable_clustering</span>": <span class="value"><span class="string">"true"</span></span></div><div class="line">		}</div><div class="line">	},</div><div class="line">	"<span class="attribute">telemetry</span>": <span class="value">{</span></div><div class="line">		"<span class="attribute">statsite_address</span>": <span class="value"><span class="string">"baz"</span></span></div><div class="line">	},</div><div class="line">	"<span class="attribute">max_lease_ttl</span>": <span class="value"><span class="string">"10h"</span></span>,</div><div class="line">	"<span class="attribute">default_lease_ttl</span>": <span class="value"><span class="string">"10h"</span></span>,</div><div class="line">	"<span class="attribute">cluster_name</span>":<span class="value"><span class="string">"testcluster"</span></span>,</div><div class="line">	"<span class="attribute">ui</span>":<span class="value"><span class="literal">true</span></span></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="xml">xml</h3>
<p>xml是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。<br>XML是从1995年开始有其雏形，并向W3C（万维网联盟）提案，而在1998年二月发布为W3C的标准（XML1.0）。</p>
<p>XML设计用来传送及携带数据信息，所以也经常用来做配置文件。</p>
<p>xml实例:</p>
<figure class="highlight xml"><figcaption><span>https://github.com/kpavlov/spring-cloud-config-sample/blob/master/src/main/resources/spring-config.xml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></div><div class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">context:property-placeholder</span> <span class="attribute">location</span>=<span class="value">"</span></span></div><div class="line">    ${config.uri}/company.properties,</div><div class="line">    classpath:product.properties,</div><div class="line">    ${config.uri}/${product.name}/${product.version}/common.properties,</div><div class="line">    ${config.uri}/${product.name}/${product.version}/${config.stage}/stage.properties,</div><div class="line">    ${config.uri}/${product.name}/${product.version}/${config.stage}/${config.node}/node.properties"</div><div class="line">                                  <span class="attribute">system-properties-mode</span>=<span class="value">"FALLBACK"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">context:annotation-config</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"spring"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="yaml">yaml</h3>
<p>YAML（/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达数据序列的格式。Clark Evans在2001年首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。目前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。</p>
<p>YAML是&quot;YAML Ain&#39;t a Markup Language&quot;（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言，但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。</p>
<p>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色， 比较适合用来表达层次结构式的数据结构。</p>
<p>YAML 1.2 是 JSON 格式的<a href="http://www.yaml.org/spec/1.2/spec.html" target="_blank" rel="external">超集</a>。</p>
<figure class="highlight yaml"><figcaption><span>https://github.com/prometheus/prometheus/blob/master/config/testdata/conf.good.yml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># my global config</div><div class="line">global:</div><div class="line">  scrape_interval:     15s</div><div class="line">  evaluation_interval: 30s</div><div class="line">  # scrape_timeout is set to the global default (10s).</div><div class="line"></div><div class="line">  external_labels:</div><div class="line">    monitor: codelab</div><div class="line">    foo:     bar</div><div class="line"></div><div class="line">rule_files:</div><div class="line">-<span class="ruby"> <span class="string">"first.rules"</span></span></div><div class="line">-<span class="ruby"> <span class="string">"my/*.rules"</span></span></div><div class="line"></div><div class="line">remote_write:</div><div class="line">  -<span class="ruby"> <span class="symbol">url:</span> <span class="symbol">http:</span>/<span class="regexp">/remote1/push</span></span></div><div class="line">    write_relabel_configs:</div><div class="line">    -<span class="ruby"> <span class="symbol">source_labels:</span> [__name_<span class="number">_</span>]</span></div><div class="line">      regex:         expensive.*</div><div class="line">      action:        drop</div><div class="line">  -<span class="ruby"> <span class="symbol">url:</span> <span class="symbol">http:</span>/<span class="regexp">/remote2/push</span></span></div></pre></td></tr></table></figure>

<h3 id="toml_https://zh-wikipedia-org/wiki/TOML">toml <a href="https://zh.wikipedia.org/wiki/TOML" target="_blank" rel="external">https://zh.wikipedia.org/wiki/TOML</a></h3>
<p>TOML是一种旨在成为一个小规模、易于使用的语义化的配置文件格式，它被设计为可以无二义性的转换为一个哈希表。<br>“TOML”这个名字是“Tom&#39;s Obvious, Minimal Language（汤姆的浅显的、极简的语言）”的首字母略写词。“Tom”指它的作者Tom Preston-Werner。<br>TOML已在一些软件工程中使用，并且可在很多程序语言中执行。</p>
<p>TOML的语法广泛地由<code>key = &quot;value&quot;</code>、<code>[节名]</code>与<code>#注释</code>构成。<br>它支持以下数据类型：字符串、整形、浮点型、布尔型、日期时间、数组和图表。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># This is a TOML document.</span></div><div class="line"></div><div class="line"><span class="variable">title =</span> <span class="string">"TOML Example"</span></div><div class="line"></div><div class="line">[owner]</div><div class="line"><span class="variable">name =</span> <span class="string">"Tom Preston-Werner"</span></div><div class="line"><span class="variable">dob =</span> <span class="number">1979</span>-<span class="number">05</span>-<span class="number">27</span>T07:<span class="number">32</span>:<span class="number">00</span>-<span class="number">08</span>:<span class="number">00</span> <span class="comment"># First class dates</span></div><div class="line"></div><div class="line">[database]</div><div class="line"><span class="variable">server =</span> <span class="string">"192.168.1.1"</span></div><div class="line"><span class="variable">ports =</span> [ <span class="number">8001</span>, <span class="number">8001</span>, <span class="number">8002</span> ]</div><div class="line"><span class="variable">connection_max =</span> <span class="number">5000</span></div><div class="line"><span class="variable">enabled =</span> <span class="constant">true</span></div><div class="line"></div><div class="line">[servers]</div><div class="line"></div><div class="line">  <span class="comment"># Indentation (tabs and/or spaces) is allowed but not required</span></div><div class="line">  [servers.alpha]</div><div class="line">  <span class="variable">ip =</span> <span class="string">"10.0.0.1"</span></div><div class="line">  <span class="variable">dc =</span> <span class="string">"eqdc10"</span></div><div class="line"></div><div class="line">  [servers.beta]</div><div class="line">  <span class="variable">ip =</span> <span class="string">"10.0.0.2"</span></div><div class="line">  <span class="variable">dc =</span> <span class="string">"eqdc10"</span></div><div class="line"></div><div class="line">[clients]</div><div class="line"><span class="variable">data =</span> [ [<span class="string">"gamma"</span>, <span class="string">"delta"</span>], [<span class="number">1</span>, <span class="number">2</span>] ]</div><div class="line"></div><div class="line"><span class="comment"># Line breaks are OK when inside arrays</span></div><div class="line"><span class="variable">hosts =</span> [</div><div class="line">  <span class="string">"alpha"</span>,</div><div class="line">  <span class="string">"omega"</span></div><div class="line">]</div></pre></td></tr></table></figure>

<h3 id="HOCON">HOCON</h3>
<p>HOCON，全称Human-Optimized Config Object Notation（人性化配置对象表示法）是一种人类可读的数据格式，并是JSON和properties的一个超集。它由Lightbend(用Scala开发的人都知道)开发，主要与Play框架结合使用。它也在Puppet中作为配置格式使用。</p>
<p>基本上也算是Scala官方开发，所以在Scala的一些项目中得到使用。由于它是JSON和properties格式的超集，所以它的格式比较灵活。</p>
<p>格式定义可以参考官方文档： <a href="https://github.com/typesafehub/config/blob/master/HOCON.md" target="_blank" rel="external">HOCON</a>。</p>
<p>下面是它的一个实例：</p>
<figure class="highlight json"><figcaption><span>https://github.com/marcospereira/play-i18n-hocon/blob/master/samples/scala/conf/application.conf</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">play.http.secret.key = "changeme"</div><div class="line"></div><div class="line">play.modules {</div><div class="line">  # Disable built-in i18n module</div><div class="line">  disabled += play.api.i18n.I18nModule</div><div class="line"></div><div class="line">  # Enable Hocon module</div><div class="line">  enabled += com.marcospereira.play.i18n.HoconI18nModule</div><div class="line">}</div><div class="line"></div><div class="line">play.i18n {</div><div class="line">  langs = [ "en" ]</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="plist">plist</h3>
<p>在OS X的Cocoa，NeXTSTEP和GNUstep编程框架中，属性列表（Property List）文件是一种用来存储序列化后的对象的文件。属性列表文件的文件扩展名为.plist，因此通常被称为plist文件。<br>Plist文件通常用于储存用户设置，也可以用于存储捆绑的信息，该功能在旧式的Mac OS中是由资源分支提供的。</p>
<figure class="highlight plist"><figcaption><span>https://github.com/wahlmanj/com.plex.pms.plist/blob/master/com.plex.pms.plist</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></div><div class="line"><span class="doctype">&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" </span></div><div class="line">    "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="title">plist</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>com.plex.pms<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">true</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">array</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>/Applications/Plex\ Media\ Server.app/Contents/MacOS/Plex\ Media\ Server<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">array</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">true</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>__USERNAME__<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>WorkingDirectory<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>/Applications<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>ServiceDescription<span class="tag">&lt;/<span class="title">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>PMS<span class="tag">&lt;/<span class="title">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">plist</span>&gt;</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>配置文件是工程中常用的初始化参数的配置方式，而配置文件的格式有很多种，不同的操作系统、编程语言都会有不同的配置文件的格式，本文罗列了一些常见的配置文件的格式。</p>
<p>不同的配置文件格式有不同的用户友好性， 对于功能的支持也有简单和复杂之分，很难简单说那种配置文件是最好的，有时候需要从多个方面去考虑， 比如Windows较早的开发喜欢使用<code>int</code>、java喜欢使用<code>properties</code>、通用的编程喜欢<code>yaml</code>、<code>json</code>等格式，本文也不会对这些格式进行排名，而是简单介绍一下这些格式，用户可以根据自己的实际情况进行选择。</p>
]]>
    
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go Plugin的一个bug]]></title>
    <link href="http://colobu.com/2017/08/26/panic-on-go-plugin-Open-for-different-plugins/"/>
    <id>http://colobu.com/2017/08/26/panic-on-go-plugin-Open-for-different-plugins/</id>
    <published>2017-08-26T15:14:04.000Z</published>
    <updated>2017-08-26T16:27:35.556Z</updated>
    <content type="html"><![CDATA[<p>Go 1.8中增加了 <a href="https://golang.org/pkg/plugin/" target="_blank" rel="external">plugin</a> package,但是仅支持Linux操作系统，并且还有一些已知的bug。可以说，这个插件系统的实现还未达到&quot;产品级&quot;的水平。</p>
<blockquote>
<p>The plugin support is currently incomplete, only supports Linux, and has known bugs.</p>
</blockquote>
<p>一些已知的bug已经推到 Go1.10甚至以后的版本中修复了。</p>
<p>今天在测试Go 1.9中的功能的时候就遇到了plugin的一个bug。</p>
<a id="more"></a>
<p>按照官方的文档, 开发一个插件很简单：</p>
<figure class="highlight go"><figcaption><span>plugin1/main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> V <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> F() { fmt.Printf(<span class="string">"Hello, number %d\n"</span>, V) }</div></pre></td></tr></table></figure>

<p>插件中定义了变量<code>V</code>和方法<code>F</code>，可以通过下面的命令生成一个<code>so</code>文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build -buildmode=plugin -o ../p1.so main.go</div></pre></td></tr></table></figure>

<p>然后通过<code>plugin</code>包可以加载插件：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">p, err := plugin.Open(<span class="string">"p1.so"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">v, err := p.Lookup(<span class="string">"V"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">f, err := p.Lookup(<span class="string">"F"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line">*v.(*<span class="typename">int</span>) =<span class="number"> 7</span></div><div class="line">f.(<span class="keyword">func</span>())() <span class="comment">// prints "Hello, number 7"</span></div></pre></td></tr></table></figure>

<p>当然作为插件系统，我们希望可以加载新的插件，来替换已有的插件， 如果你复制<code>p1.so</code>为<code>p2.so</code>,然后上上面的测试代码中再加载<code>p2.so</code>会报错：</p>
<figure class="highlight go"><figcaption><span>main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">p, err := plugin.Open(<span class="string">"p1.so"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div><div class="line"></div><div class="line">......</div><div class="line"></div><div class="line">p, err = plugin.Open(<span class="string">"p2.so"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	<span class="built_in">panic</span>(err)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>错误信息如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></div><div class="line">Hello, number<span class="number"> 7</span></div><div class="line">plugin: plugin plugin/unnamed-f0c47a2a99a0d8e8fb40defabb50f238c78f5d58 already loaded</div><div class="line">fatal error: plugin: plugin already loaded</div><div class="line">......</div></pre></td></tr></table></figure>

<p>这一步我们还能理解，相同的plugin即使文件名更改了，加载进去还是一样的，所以会报<code>plugin already loaded</code>错误。</p>
<p>我们将<code>plugin1/main.go</code>中的代码<strong>稍微改一下</strong>：</p>
<figure class="highlight go"><figcaption><span>plugin1/main.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> V <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> F() { fmt.Printf(<span class="string">"Hello world,  %d\n"</span>, V) }</div></pre></td></tr></table></figure>

<p>然后生成插件<code>p2.so</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build -buildmode=plugin -o ../p2.so main.go</div></pre></td></tr></table></figure>

<p>按说这次我们修改了代码，生成了一个新的插件，如果代码同时加载这两个插件，因为没什么问题，但是运行上面的加载两个插件的测试代码，发现还是出错：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">go <span class="command">run</span> main.go</div><div class="line">Hello, <span class="type">number</span> <span class="number">7</span></div><div class="line">plugin: plugin plugin/unnamed-f0c47a2a99a0d8e8fb40defabb50f238c78f5d58 already loaded</div><div class="line">fatal <span class="keyword">error</span>: plugin: plugin already loaded</div><div class="line">......</div></pre></td></tr></table></figure>

<p>怪异吧，两个不同代码的生成插件，居然被认为是同一个插件（plugin/unnamed-f0c47a2a99a0d8e8fb40defabb50f238c78f5d58）。</p>
<p>使用<code>nm</code>查看两个插件的符号表：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@colobu t]<span class="comment"># nm p1.so |grep unname</span></div><div class="line"><span class="number">00000000001</span>acfc0 R go.link.pkghashbytes.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">00000000003</span>f9620 D go.link.pkghash.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">0000000000199080</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">0000000000199080</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">000000000048</span>e027 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.initdone·</div><div class="line"><span class="number">000000000048</span>e088 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.V</div><div class="line">[root@colobu t]<span class="comment">#</span></div><div class="line">[root@colobu t]<span class="comment">#</span></div><div class="line">[root@colobu t]<span class="comment"># nm p2.so |grep unname</span></div><div class="line"><span class="number">00000000001</span>acfc0 R go.link.pkghashbytes.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">00000000003</span>f9620 D go.link.pkghash.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58</div><div class="line"><span class="number">0000000000199080</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> t local.plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">0000000000199080</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.F</div><div class="line"><span class="number">0000000000199130</span> T plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.init</div><div class="line"><span class="number">000000000048</span>e027 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.initdone·</div><div class="line"><span class="number">000000000048</span>e088 B plugin/unnamed<span class="operator">-f</span>0c47a2a99a0d8e8fb40defabb50f238c78f5d58.V</div><div class="line">[root@colobu t]<span class="comment">#</span></div></pre></td></tr></table></figure>

<p>可以看到两个插件中生成的符号表符号表是相同的，所以被误认为了同一个插件。</p>
<p>这种情况是在特殊情况下产生的，如果两个插件的文件名不同，或者引用包不同，或者引用的cgo不同，则会生成不同的插件，同时加载不会有问题。但是如果文件名相同，相关的引用也相同，则可能生成相同的插件，尽管插件内包含的方法和变量不同，实现也不同。</p>
<p>这是Go plugin生成的时候一个bug: <a href="https://github.com/golang/go/issues/19358" target="_blank" rel="external">issue#19358</a>, 期望在Go 1.10中解决，目前的解决办法就是插件的go文件使用不同的名字，或者编译的时候指定<code>pluginpath</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go build -ldflags <span class="string">"-pluginpath=p1"</span>-buildmode=plugin -o ../p1.so main.go</div><div class="line">go build -ldflags <span class="string">"-pluginpath=p2"</span>-buildmode=plugin -o ../p2.so main.go</div></pre></td></tr></table></figure>

<p>导致问题的原因正如  LionNatsu 在bug中指出的， Go 判断两个插件是否相同是通过比较<a href="https://github.com/golang/go/blob/0efc8b21881ab35fdb45547088b1935fc8ebf263/src/runtime/plugin.go#L23" target="_blank" rel="external">pluginpath</a>实现的，如果你在编译的时候指定了不同的<code>pluginpath</code>，则编译出来的插件是不同的，但是如果没有指定<code>pluginpath</code>，则由内部的算法生成, <a href="https://github.com/golang/go/blob/f8b0231639859de7b8f1bfe7df1be0132aec9ad6/src/cmd/go/internal/work/build.go#L2426" target="_blank" rel="external">生成</a>的格式为<code>plugin/unnamed-&quot; + root.Package.Internal.BuildID</code> 。</p>
<p><a href="https://github.com/golang/go/blob/be04da8f0c5cb57e2736cfac8c76971d7d8cfc6f/src/cmd/go/internal/load/pkg.go#L1621" target="_blank" rel="external">func computeBuildID(p *Package)</a> 生成一个SHA-1的哈希值作为BuildID。</p>
<figure class="highlight go"><figcaption><span>go/src/cmd/go/internal/load/pkg.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> computeBuildID(p *Package) {</div><div class="line">	h := sha1.New()</div><div class="line"></div><div class="line">	<span class="comment">// Include the list of files compiled as part of the package.</span></div><div class="line">	<span class="comment">// This lets us detect removed files. See issue 3895.</span></div><div class="line">	inputFiles := str.StringList(</div><div class="line">		p.GoFiles,</div><div class="line">		p.CgoFiles,</div><div class="line">		p.CFiles,</div><div class="line">		p.CXXFiles,</div><div class="line">		p.MFiles,</div><div class="line">		p.HFiles,</div><div class="line">		p.SFiles,</div><div class="line">		p.SysoFiles,</div><div class="line">		p.SwigFiles,</div><div class="line">		p.SwigCXXFiles,</div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> _, file := <span class="keyword">range</span> inputFiles {</div><div class="line">		fmt.Fprintf(h, <span class="string">"file %s\n"</span>, file)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Include the content of runtime/internal/sys/zversion.go in the hash</span></div><div class="line">	<span class="comment">// for package runtime. This will give package runtime a</span></div><div class="line">	<span class="comment">// different build ID in each Go release.</span></div><div class="line">	<span class="keyword">if</span> p.Standard && p.ImportPath == <span class="string">"runtime/internal/sys"</span> && cfg.BuildContext.Compiler != <span class="string">"gccgo"</span> {</div><div class="line">		data, err := ioutil.ReadFile(filepath.Join(p.Dir, <span class="string">"zversion.go"</span>))</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			base.Fatalf(<span class="string">"go: %s"</span>, err)</div><div class="line">		}</div><div class="line">		fmt.Fprintf(h, <span class="string">"zversion %q\n"</span>, <span class="typename">string</span>(data))</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// Include the build IDs of any dependencies in the hash.</span></div><div class="line">	<span class="comment">// This, combined with the runtime/zversion content,</span></div><div class="line">	<span class="comment">// will cause packages to have different build IDs when</span></div><div class="line">	<span class="comment">// compiled with different Go releases.</span></div><div class="line">	<span class="comment">// This helps the go command know to recompile when</span></div><div class="line">	<span class="comment">// people use the same GOPATH but switch between</span></div><div class="line">	<span class="comment">// different Go releases. See issue 10702.</span></div><div class="line">	<span class="comment">// This is also a better fix for issue 8290.</span></div><div class="line">	<span class="keyword">for</span> _, p1 := <span class="keyword">range</span> p.Internal.Deps {</div><div class="line">		fmt.Fprintf(h, <span class="string">"dep %s %s\n"</span>, p1.ImportPath, p1.Internal.BuildID)</div><div class="line">	}</div><div class="line"></div><div class="line">	p.Internal.BuildID = fmt.Sprintf(<span class="string">"%x"</span>, h.Sum(<span class="constant">nil</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p>函数的后半部分为Go不同的版本生成不同的哈希，避免用户使用不同的Go版本生成相同的ID。重点看前半部分，可以发现计算哈希的时候只依赖文件名，并不关心文件的内容，这也是我们前面稍微修改一下插件的代码会生成相同的原因， 如果你在代码中<code>import _ &quot;fmt&quot;</code>也会产生不同的插件。</p>
<p>总之，在Go 1.10之前，为了避免插件冲突， 最好是在编译的时候指定<code>pluginpath</code>, 比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go build -ldflags <span class="string">"-pluginpath=plugin/hot-<span class="variable">$(date +%s)</span>"</span> -buildmode=plugin -o hotload.so hotload.go</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>Go 1.8中增加了 <a href="https://golang.org/pkg/plugin/" target="_blank" rel="external">plugin</a> package,但是仅支持Linux操作系统，并且还有一些已知的bug。可以说，这个插件系统的实现还未达到&quot;产品级&quot;的水平。</p>
<blockquote>
<p>The plugin support is currently incomplete, only supports Linux, and has known bugs.</p>
</blockquote>
<p>一些已知的bug已经推到 Go1.10甚至以后的版本中修复了。</p>
<p>今天在测试Go 1.9中的功能的时候就遇到了plugin的一个bug。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]设计一个容错的微服务架构]]></title>
    <link href="http://colobu.com/2017/08/23/Designing-a-Microservices-Architecture-for-Failure/"/>
    <id>http://colobu.com/2017/08/23/Designing-a-Microservices-Architecture-for-Failure/</id>
    <published>2017-08-23T05:31:10.000Z</published>
    <updated>2017-08-26T15:12:26.227Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://blog.risingstack.com/designing-microservices-architecture-for-failure/" target="_blank" rel="external">Designing a Microservices Architecture for Failure</a><br>翻译: <a href="https://github.com/jasonGeng88/blog" target="_blank" rel="external">设计一个容错的微服务架构</a> by Jason Geng</p>
<p>微服务架构使得可以通过明确定义的服务边界来隔离故障。但是像在每个分布式系统中一样，发生网络、硬件、应用级别的错误都是很常见的。由于服务依赖关系，任何组件可能暂时无法提供服务。为了尽量减少部分中断的影响，我们需要构建容错服务，来优雅地处理这些中断的响应结果。</p>
<p>本文介绍了基于<a href="https://risingstack.com/" target="_blank" rel="external">RisingStack 的 Node.js 咨询和开发经验</a>构建和操作高可用性微服务系统的最常见技术和架构模式。</p>
<p>如果你不熟悉本文中的模式，那并不一定意味着你做错了。建立可靠的系统总是会带来额外的成本。</p>
<a id="more"></a>
<h2 id="微服务架构的风险">微服务架构的风险</h2>
<p>微服务架构将应用程序逻辑移动到服务，并使用网络层在它们之间进行通信。这种通过网络间通信代替单应用程序内调用的做法，会带来额外的延迟，以及需要协调多个物理和逻辑组件的系统复杂度。分布式系统的复杂性增加也将导致更高的网络故障率。</p>
<blockquote>
<p>microservices allow you to achieve graceful service degradation as components can be set up to fail separately.</p>
</blockquote>
<p>微服务体系结构的最大优势之一是，团队可以独立设计，开发和部署他们的服务。他们对服务的生命周期拥有完全的所有权。这也意味着团队无法控制他们依赖的服务，因为它更有可能由不同的团队管理。使用微服务架构，我们需要记住，提供者服务可能会临时不可用，由于其他人员发行的错误版本，配置以及其他更改等。</p>
<h2 id="优雅的服务降级">优雅的服务降级</h2>
<p>微服务架构的最大优点之一是您可以隔离故障，并在当组件单独故障时，进行优雅的服务降级。 例如，在中断期间，照片共享应用程序中的客户可能无法上传新图片，但仍可以浏览，编辑和共享其现有照片。</p>
<p><img src="microservices-fail-separately-in-theory.png" alt="微服务容错隔离"></p>
<p>在大多数情况下，由于分布式系统中的应用程序相互依赖，因此很难实现这种优雅的服务降级，您需要应用几种故障转移的逻辑（其中一些将在本文后面介绍），以为暂时的故障和中断做准备。</p>
<p><img src="Microservices-depend-on-each-other.png" alt="服务间彼此依赖，再没有故障转移逻辑下，服务全部失败。"></p>
<h2 id="变更管理">变更管理</h2>
<p>Google的网站可靠性小组发现，<strong>大约70％的中断是由现有系统的变化引起的</strong>。当您更改服务中的某些内容时，您将部署新版本的代码或更改某些配置 - 这总有可能会造成故障，或者引入新的bug。</p>
<p>在微服务架构中，服务依赖于彼此。这就是为什么你应该尽量减少故障并限制它的负面影响。要处理变更中的问题，您可以实施变更管理策略和<strong>自动回滚</strong>机制。</p>
<p>例如，当您部署新代码或更改某些配置时，您应该先小范围的进行部分的替换，以渐进式的方式替换服务的全部实例。在这期间，需要监视它们，如果您发现它们对您的关键指标有负面影响，应立即进行服务回滚，这称为“金丝雀部署”。</p>
<p><img src="microservices-change-management.png" alt="变更管理 - 回滚部署"></p>
<p>另一个解决方案可能是您运行两个生产环境。您始终只能部署其中一个，并且在验证新版本是否符合预期之后才，将负载均衡器指向新的。这称为蓝绿或红黑部署。</p>
<p><strong>回滚代码不是坏事</strong>。你不应该在生产中遗留错误的代码，然后考虑出了什么问题。如果必要，越早回滚你的代码越好。</p>
<h2 id="健康检查与负载均衡">健康检查与负载均衡</h2>
<p>实例由于出现故障、部署或自动缩放的情况，会进行持续启动、重新启动或停止操作。它可能导致它们暂时或永久不可用。为避免问题，您的负载均衡器应该从路由中<strong>跳过不健康的实例</strong>，因为它们当前无法为客户或子系统提供服务。</p>
<p>应用实例健康状况可以通过外部观察来确定。您可以通过重复调用<strong>GET /health</strong>端点或通过自我报告来实现。现在主流的<strong>服务发现</strong>解决方案，会持续从实例中收集健康信息，并配置负载均衡器，将流量仅路由到健康的组件上。</p>
<h2 id="自我修复">自我修复</h2>
<p>自我修复可以帮助应用程序从错误中恢复过来。当应用程序可以<strong>采取必要步骤</strong>从故障状态恢复时，我们就可以说它是可以实现自我修复的。在大多数情况下，它由外部系统实现，该系统会监视实例运行状况，并在较长时间内处于故障状态时重新启动它们。自我修复在大多数情况下是非常有用的。但是在某些情况下，持续地重启应用程序可能会<strong>导致麻烦</strong>。 当您的应用程序由于超负荷或其数据库连接超时而无法给出健康的运行状况时，这种情况下的频繁的重启就可能就不太合适了。</p>
<p>对于这种特殊的场景（如丢失的数据库连接），要实现满足它的高级自我修复的解决方案可能很棘手。在这种情况下，您需要为应用程序添加额外的逻辑来处理边缘情况，并让外部系统知道实例不需要立即重新启动。</p>
<h2 id="故障转移缓存">故障转移缓存</h2>
<p>由于网络问题和我们系统的变化，服务经常会失败。然而，由于自我修复和负载均衡的保障，它们中的大多数中断是临时的，我们应该找到一个解决方案，使我们的服务在这些故障时服务仍就可以工作。这就是<strong>故障转移缓存</strong> (failover caching)的作用，它可以帮助并为我们的应用程序在服务故障时提供必要的数据。</p>
<p>故障转移缓存通常使用<strong>两个不同的过期日期</strong>; 较短的时间告诉您在正常情况下缓存可以使用的过期时间，而较长的时间可以在服务故障时缓存依旧可用的过期时间。</p>
<p><img src="microservices-failover-caching.png" alt="故障转移缓存"></p>
<p>请务必提及，只有当服务使用过时的数据比没有数据更好时，才能使用故障转移缓存。</p>
<p>要设置缓存和故障转移缓存，可以在 HTTP 中使用标准响应头。</p>
<p>例如，使用 <code>max-age</code> 属性可以指定资源被视为有效的最大时间。使用 <code>stale-if-error</code> 属性，您可以明确在出现故障的情况下，依旧可以从缓存中获取资源的最大时间。</p>
<p>现代的 CDN 和负载均衡器都提供各种缓存和故障转移行为，但您也可以为拥有标准可靠性解决方案的公司创建一个共享库。</p>
<h2 id="重试逻辑">重试逻辑</h2>
<p>在某些情况下，我们无法缓存数据，或者我们想对其进行更改，但是我们的操作最终都失败了。对于此，我们可以重试我们的操作，因为我们可以预期资源将在一段时间后恢复，或者我们的负载均衡器将请求发送到了健康的实例上。</p>
<p>您应该小心地为您的应用程序和客户端添加重试逻辑，因为大量的<strong>重试可能会使事情更糟</strong>，甚至阻止应用程序恢复，如当服务超载时，大量的重试只能使状况更糟。</p>
<p>在分布式系统中，微服务系统重试可以触发多个其他请求或重试，并启动<strong>级联效应</strong>。为了最小化重试的影响，您应该限制它们的数量，并使用指数退避算法来持续增加重试之间的延迟，直到达到最大限制。</p>
<p>当客户端（浏览器，其他微服务等）发起重试，并且客户端不知道在处理请求之前或之后操作失败时，您应该为你的应用程序做好<strong>幂等处理</strong>的准备。例如，当您重试购买操作时，您不应该再次向客户收取费用。为每个交易使用唯一的<strong>幂等值键</strong>可以帮助处理重试。</p>
<h2 id="限流器和负载降级">限流器和负载降级</h2>
<p>流量限制是在一段时间内定义特定客户或应用程序可以接收或处理多少个请求的技术。例如，通过流量限制，您可以过滤掉造成流量峰值的客户和服务，或者您可以确保您的应用程序在自动缩放无法满足时，依然不会超载。</p>
<p>您还可以阻止较低优先级的流量，为关键事务提供足够的资源。</p>
<p><img src="microservices-rate-limiter.png" alt="限流器可以阻止流量峰值产生"></p>
<p>有一个不同类型的限流器，叫做并发请求限制器。当您有重要的端点，您不应该被调用超过指定的次数，而您仍然想要能提供服务时，这将是有用的。</p>
<p>负载降级的一系列使用，可以确保总是有足够的资源来提供关键交易。它为高优先级请求保留一些资源，不允许低优先级的事务使用它们。负载降级开关是根据系统的整体状态做出决定，而不是基于单个用户的请求量大小。负载降级有助于您的系统恢复，因为当你有一个偶发事件时（可能是一个热点事件），您仍能保持核心功能的正常工作。</p>
<p>要了解有关限流器和负载降级的更多信息，我建议查看这篇<a href="https://stripe.com/blog/rate-limiters" target="_blank" rel="external">Stripe的文章</a>。</p>
<h2 id="快速失败原则与独立性">快速失败原则与独立性</h2>
<p>在微服务架构中，我们想要做到让我们的服务具备快速失败与相互独立的能力。为了在服务级别上进行故障隔离，我们可以使用舱壁模式。你可以在本文的后面阅读更多有关舱壁的内容。</p>
<p>我们也希望我们的组件能够快速失败，因为我们不希望对于有故障的服务，在请求超时后才断开。没有什么比挂起的请求和无响应的 UI 更令人失望。这不仅浪费资源，而且还会影响用户体验。我们的服务在调用链中是相互调用的，所以在这些延迟累加之前，我们应该特别注意防止挂起操作。</p>
<p>你想到的第一个想法是对每个服务调用都设置明确的超时等级。这种方法的问题是，您不能知道真正合理的超时值是多少，因为网络故障和其他问题发生的某些情况只会影响一两次操作。在这种情况下，如果只有其中一些超时，您可能不想拒绝这些请求。</p>
<p>我们可以说，在微服务种通过使用超时来达到快速失败的效果是一种反模式的，你应该避免使用它。取而代之，您可以应用断路器模式，依据操作的成功与失败统计数据决定。</p>
<h2 id="舱壁模式">舱壁模式</h2>
<p>工业中使用舱壁将船舶划分为几个部分，以便在船体破坏的情况下，可以将船舶各个部件密封起来。</p>
<p>舱壁的概念在软件开发中可以被应用在隔离资源上。</p>
<p>通过应用舱壁模式，我们可以保护有限的资源不被耗尽。例如，对于一个有连接数限制的数据库实例来说，如果我们有两种连接它的操作，我们采用可以采用两个连接池的方式进行连接，来代替仅采用一个共享连接池的方式。由于这种客户端与资源进行了隔离，超时或过度使用池的操作页不会使其他操作失败。</p>
<p>泰坦尼克号沉没的主要原因之一是其舱壁设计失败，水可以通过上面的甲板倒在舱壁的顶部，导致整个船体淹没。</p>
<p><img src="titanic-bulkhead-microservices.png" alt="泰坦尼克号舱壁设计（无效的设计）"></p>
<h2 id="断路器">断路器</h2>
<p>为了限制操作的持续时间，我们可以使用超时。超时可以防止挂起操作并保持系统响应。然而，在微服务中使用静态、精细的超时是一种反模式，因为我们处于高度动态的环境中，几乎不可能提出在每种情况下都能正常工作的正确的时间限制。</p>
<p>替代这种静态超时的手段是，我们可以使用断路器来处理错误。断路器以现实世界的电子元件命名，因为它们的作用是相同的。您可以保护资源，并帮助他们使用断路器进行恢复。它们在分布式系统中非常有用，因为在分布式系统中，重复故障可能导致雪球效应并使整个系统瘫痪。</p>
<p>当特定类型的错误在短时间内多次发生时，断路器会被断开。开路的断路器可以防止进一步的请求 - 就像我们平时所说的电路跳闸一样。断路器通常在一定时间后关闭，在这期间可以为底层服务提供足够的空间来恢复。</p>
<p>请记住，并不是所有的错误都应该触发断路器。例如，您可能希望跳过客户端问题，例如具有4xx响应代码的请求，但不包括5xx服务器端故障。一些断路器也具有半开状态。在这种状态下，服务发送第一个请求以检查系统可用性，同时让其他请求失败。如果这个第一个请求成功，它将使断路器恢复到关闭状态并使流量流动。否则，它保持打开。</p>
<p><img src="microservices-circuit-breakers.png" alt="断路器"></p>
<h2 id="测试故障">测试故障</h2>
<p>您应该不断测试您系统的常见问题，以确保您的服务可以抵抗各种故障。您应经常测试故障，让您的团队具备故障处理的能力。</p>
<p>对于测试，您可以使用外部服务来标识实例组，并随机终止此组中的一个实例。这样，您可以准备单个实例故障，但您甚至可以关闭整个区域来模拟云提供商的故障。</p>
<p>最流行的测试解决方案之一是 Netflix 的 <a href="https://github.com/Netflix/chaosmonkey" target="_blank" rel="external">ChaosMonkey 弹性工具</a>。</p>
<h2 id="结尾">结尾</h2>
<p>实施和运行可靠的服务并不容易。 您需要付出很多努力，同时公司也要有相应的财力投入。</p>
<p>可靠性有很多层次和方面，因此找到最适合您团队的解决方案很重要。您应该使可靠性成为您的业务决策流程中的一个因素，并为其分配足够的预算和时间。</p>
<h2 id="关键点">关键点</h2>
<ul>
<li>动态环境和分布式系统（如微服务）会导致更高的故障机率；</li>
<li>服务应该做到故障隔离，到达优雅降级，来提升用户体验；</li>
<li>70％的中断是由变化引起的，代码回滚不是一件坏事；</li>
<li>做到服务快速失败与独立性。团队是无法控制他们所依赖的服务情况；</li>
<li>缓存、舱壁、断路器和限流器等架构模式与技术有助于构建可靠的微服务架构。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://blog.risingstack.com/designing-microservices-architecture-for-failure/" target="_blank" rel="external">Designing a Microservices Architecture for Failure</a><br>翻译: <a href="https://github.com/jasonGeng88/blog" target="_blank" rel="external">设计一个容错的微服务架构</a> by Jason Geng</p>
<p>微服务架构使得可以通过明确定义的服务边界来隔离故障。但是像在每个分布式系统中一样，发生网络、硬件、应用级别的错误都是很常见的。由于服务依赖关系，任何组件可能暂时无法提供服务。为了尽量减少部分中断的影响，我们需要构建容错服务，来优雅地处理这些中断的响应结果。</p>
<p>本文介绍了基于<a href="https://risingstack.com/" target="_blank" rel="external">RisingStack 的 Node.js 咨询和开发经验</a>构建和操作高可用性微服务系统的最常见技术和架构模式。</p>
<p>如果你不熟悉本文中的模式，那并不一定意味着你做错了。建立可靠的系统总是会带来额外的成本。</p>
]]>
    
    </summary>
    
      <category term="架构" scheme="http://colobu.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再谈谈获取 goroutine id 的方法]]></title>
    <link href="http://colobu.com/2017/08/04/talk-about-getting-goroutine-id-again/"/>
    <id>http://colobu.com/2017/08/04/talk-about-getting-goroutine-id-again/</id>
    <published>2017-08-04T03:38:05.000Z</published>
    <updated>2017-09-30T14:15:44.802Z</updated>
    <content type="html"><![CDATA[<p>去年年初的时候曾经写过一篇关于如何获取goroutine id的方法： <a href="http://colobu.com/2016/04/01/how-to-get-goroutine-id/" target="_blank" rel="external">如何得到goroutine 的 id?</a>, 当时调研了一些一些获取goid的方法。基本的方法有三种：</p>
<ol>
<li>通过Stack信息解析出ID</li>
<li>通过汇编获取<code>runtime·getg</code>方法的调用结果</li>
<li>直接修改运行时的代码，export一个可以外部调用的GoID()方法</li>
</ol>
<p>每个方式都有些问题， #1比较慢， #2因为是hack的方式(Go team并不想暴露go id的信息), 针对不同的Go版本中需要特殊的hack手段， #3需要定制Go运行时，不通用。当时的<a href="https://github.com/petermattis/goid" target="_blank" rel="external">petermattis/goid</a>提供了 #2 的方法， 但是只能在 go 1.3中才起作用，所以只能选择#1的方式获取go id。</p>
<p>最近一年来， petermattis更新了他的代码，逐步增加了对 Go 1.4、1.5、1.6、1.7、1.8、1.9的支持，同时也提供了#1的方法，在#2方法不起作用的时候作为备选，所以我们可以在当前的所有的版本中可以使用stable的获取go id的方法了。</p>
<a id="more"></a>
<p>你或许会遇到一些需要使用Go ID的场景， 比如在多goroutine长时间运行任务的时候，我们通过日志来跟踪任务的执行情况，可以通过go id来大致地跟踪程序并发执行的时候的状况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/petermattis/goid"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 10</span>; i++ {</div><div class="line">		<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">			<span class="keyword">for</span> j :=<span class="number"> 0</span>; j &lt;<span class="number"> 1000000</span>; j++ {</div><div class="line">				log.Printf(<span class="string">"[#%d] %d"</span>, goid.Get(), j)</div><div class="line">				time.Sleep<span class="number">(10e9</span>)</div><div class="line">			}</div><div class="line">		}()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">select</span> {}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>依照Go代码中的文档<a href="https://golang.org/src/runtime/HACKING.md" target="_blank" rel="external">HACKING</a>, go运行时中实现了一个<code>getg()</code>方法，可以获取当前的goroutine：</p>
<blockquote>
<p><code>getg()</code> alone returns the current <code>g</code></p>
</blockquote>
<p>当然这个方法是内部方法，不是exported,不能被外部的调用，而且返回的数据结构也是未exported的。如果有办法暴露出这个方法，问题就解决了。</p>
<p><a href="https://github.com/petermattis/goid" target="_blank" rel="external">petermattis/goid</a> 模仿<code>runtime.getg</code>暴露出一个<code>getg</code>的方法</p>
<figure class="highlight asm"><figcaption><span>https://github.com/petermattis/goid/blob/master/goid_go1.5plus.s</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// +build amd64 amd64p32</div><div class="line">// +build go1<span class="string">.5</span></div><div class="line"></div><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line"></div><div class="line">// func getg() uintptr</div><div class="line">TEXT ·getg(SB),<span class="preprocessor">NOSPLIT</span>,<span class="number">$0</span>-<span class="number">8</span></div><div class="line">	<span class="keyword">MOVQ</span> (TLS), <span class="number">BX</span></div><div class="line">	<span class="keyword">MOVQ</span> <span class="number">BX</span>, <span class="keyword">ret</span>+<span class="number">0</span>(FP)</div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

<p>上面的代码实际是将当前的goroutine的结构体的指针(TLS)返回。</p>
<blockquote>
<p>参考： <a href="https://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html" target="_blank" rel="external">Golang Internals</a> 以及中文翻译 <a href="http://blog.jobbole.com/92371/" target="_blank" rel="external">Go语言内幕</a><br>TLS 其实是线程本地存储 （Thread Local Storage ）的缩写。这个技术在很多编程语言中都有用到（请参考这里）。简单地说，它为每个线程提供了一个这样的变量，不同变量用于指向不同的内存区域。</p>
<p>在 Go 语言中，TLS 存储了一个 G 结构体的指针。这个指针所指向的结构体包括 Go 例程的内部细节（后面会详细谈到这些内容）。因此，当在不同的例程中访问该变量时，实际访问的是该例程相应的变量所指向的结构体。链接器知道这个变量所在的位置，前面的指令中移动到 CX 寄存器的就是这个变量。对于 AMD64，TLS 是用 FS 寄存器来实现的， 所在我们前面看到的命令实际上可以翻译为 MOVQ FS, CX。</p>
</blockquote>
<p>不同的Go版本获取的数据结构可能是不同的，所以<code>petermattis/goid</code>针对1.5、1.6、1.9有变动的版本定制了不同的数据结构，因为我们只需要得到goroutine的ID,所以只需实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Get() <span class="typename">int64</span> {</div><div class="line">	gg := (*g)(unsafe.Pointer(getg()))</div><div class="line">	<span class="keyword">return</span> gg.goid</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我比较了一下#1和#2这两种实现方式的性能，差距还是非常大的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> pkg</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"testing"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/petermattis/goid"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkASM(b *testing.B) {</div><div class="line">	b.ReportAllocs()</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		goid.Get()</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> BenchmarkSlow(b *testing.B) {</div><div class="line">	b.ReportAllocs()</div><div class="line">	<span class="keyword">var</span> buf <span class="number">[64</span>]<span class="typename">byte</span></div><div class="line">	b.ResetTimer()</div><div class="line">	<span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt; b.N; i++ {</div><div class="line">		goid.ExtractGID(buf[:runtime.Stack(buf[:], <span class="constant">false</span>)])</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>性能比较结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BenchmarkASM-4    	300000000	         3.70 ns/op	       0 B/op	       0 allocs/op</div><div class="line">BenchmarkSlow-4   	  300000	      4071 ns/op	       1 B/op	       1 allocs/op</div></pre></td></tr></table></figure>

<p>一千多倍的差距。</p>
<p><code>petermattis/goid</code>这种hack的方式可以暴露更多的运行时的细节，比如我们可以扩展一下，得到当前哪个<code>m</code>正在运行，甚至可以得到当前的线程的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> {</div><div class="line">	g0        *g</div><div class="line">	morebuf   gobuf</div><div class="line">	divmod    <span class="typename">uint32</span></div><div class="line">	procid    <span class="typename">uint64</span></div><div class="line">	gsignal   *g</div><div class="line">	sigmask   sigset</div><div class="line">	tls       <span class="number">[6</span>]<span class="typename">uintptr</span></div><div class="line">	mstartfn  <span class="keyword">func</span>()</div><div class="line">	curg      *g</div><div class="line">	caughtsig <span class="typename">uintptr</span></div><div class="line">	p         <span class="typename">uintptr</span></div><div class="line">	nextp     <span class="typename">uintptr</span></div><div class="line">	id        <span class="typename">int32</span></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">func</span> GetM() <span class="typename">int32</span> {</div><div class="line">	gg := (*g)(unsafe.Pointer(getg()))</div><div class="line">	m := (*m)(unsafe.Pointer(gg.m))</div><div class="line">	<span class="keyword">return</span> m.id</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>sigset</code>在不同的平台的大小是不一样的，可以参考<a href="https://github.com/golang/go/tree/master/src/runtime" target="_blank" rel="external">os_*.go</a>中各平台的定义。上面是得到<code>m</code>的ID, 更全的<code>m</code>的结构定义海包括<code>thread</code>等信息。</p>
<p><strong>2017-09-05 更新</strong></p>
<p>petermattis 最近做了更新， 利用go本身的<code>g_goid</code>宏，直接利用汇编就可以获取goroutine id,比上面的方式更简单，性能还好:</p>
<figure class="highlight asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"go_asm.h"</span></div><div class="line">#include <span class="string">"textflag.h"</span></div><div class="line"></div><div class="line">// func Get() int64</div><div class="line">TEXT ·Get(SB),<span class="preprocessor">NOSPLIT</span>,<span class="number">$0</span>-<span class="number">8</span></div><div class="line">	<span class="keyword">MOVQ</span> (TLS), <span class="literal">R14</span></div><div class="line">	<span class="keyword">MOVQ</span> g_goid(<span class="literal">R14</span>), <span class="literal">R13</span></div><div class="line">	<span class="keyword">MOVQ</span> <span class="literal">R13</span>, <span class="keyword">ret</span>+<span class="number">0</span>(FP)</div><div class="line">	<span class="keyword">RET</span></div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>去年年初的时候曾经写过一篇关于如何获取goroutine id的方法： <a href="http://colobu.com/2016/04/01/how-to-get-goroutine-id/" target="_blank" rel="external">如何得到goroutine 的 id?</a>, 当时调研了一些一些获取goid的方法。基本的方法有三种：</p>
<ol>
<li>通过Stack信息解析出ID</li>
<li>通过汇编获取<code>runtime·getg</code>方法的调用结果</li>
<li>直接修改运行时的代码，export一个可以外部调用的GoID()方法</li>
</ol>
<p>每个方式都有些问题， #1比较慢， #2因为是hack的方式(Go team并不想暴露go id的信息), 针对不同的Go版本中需要特殊的hack手段， #3需要定制Go运行时，不通用。当时的<a href="https://github.com/petermattis/goid" target="_blank" rel="external">petermattis/goid</a>提供了 #2 的方法， 但是只能在 go 1.3中才起作用，所以只能选择#1的方式获取go id。</p>
<p>最近一年来， petermattis更新了他的代码，逐步增加了对 Go 1.4、1.5、1.6、1.7、1.8、1.9的支持，同时也提供了#1的方法，在#2方法不起作用的时候作为备选，所以我们可以在当前的所有的版本中可以使用stable的获取go id的方法了。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/tags/Go/"/>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 1.9 sync.Map揭秘]]></title>
    <link href="http://colobu.com/2017/07/11/dive-into-sync-Map/"/>
    <id>http://colobu.com/2017/07/11/dive-into-sync-Map/</id>
    <published>2017-07-11T10:09:48.000Z</published>
    <updated>2017-07-28T15:12:23.268Z</updated>
    <content type="html"><![CDATA[<p>在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<p>本文带你深入到<code>sync.Map</code>的具体实现中，看看为了增加一个功能，代码是如何变的复杂的,以及作者在实现<code>sync.Map</code>的一些思想。</p>
<a id="more"></a>
<h3 id="有并发问题的map">有并发问题的map</h3>
<p>官方的<a href="https://golang.org/doc/faq#atomic_maps" target="_blank" rel="external">faq</a>已经提到内建的<code>map</code>不是线程(goroutine)安全的。</p>
<p>首先，让我们看一段并发读写的代码,下列程序中一个goroutine一直读，一个goroutine一只写同一个键值，即即使读写的键不相同，而且map也没有&quot;扩容&quot;等操作，代码还是会报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">int</span>]<span class="typename">int</span>)</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			_ = m<span class="number">[1</span>]</div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		<span class="keyword">for</span> {</div><div class="line">			m<span class="number">[2</span>] =<span class="number"> 2</span></div><div class="line">		}</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">select</span> {}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>错误信息是: <code>fatal error: concurrent map read and map write</code>。</p>
<p>如果你查看Go的源代码: <a href="https://github.com/golang/go/blob/master/src/runtime/hashmap_fast.go#L118" target="_blank" rel="external">hashmap_fast.go#L118</a>,会看到读的时候会检查<code>hashWriting</code>标志， 如果有这个标志，就会报并发错误。</p>
<p>写的时候会设置这个标志: <a href="https://github.com/golang/go/blob/master/src/runtime/hashmap.go#L542" target="_blank" rel="external">hashmap.go#L542</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">h.flags |= hashWriting</div></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/master/src/runtime/hashmap.go#L628" target="_blank" rel="external">hashmap.go#L628</a>设置完之后会取消这个标记。</p>
<p>当然，代码中还有好几处并发读写的检查， 比如写的时候也会检查是不是有并发的写，删除键的时候类似写，遍历的时候并发读写问题等。</p>
<p>有时候，map的并发问题不是那么容易被发现, 你可以利用<code>-race</code>参数来检查。</p>
<h3 id="Go_1-9之前的解决方案">Go 1.9之前的解决方案</h3>
<p>但是，很多时候，我们会并发地使用map对象，尤其是在一定规模的项目中，map总会保存goroutine共享的数据。在Go官方blog的<a href="https://blog.golang.org/go-maps-in-action" target="_blank" rel="external">Go maps in action</a>一文中，提供了一种简便的解决方案。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>{</div><div class="line">    sync.RWMutex</div><div class="line">    m <span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span></div><div class="line">}{m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="typename">string</span>]<span class="typename">int</span>)}</div></pre></td></tr></table></figure>

<p>它使用嵌入struct为map增加一个读写锁。</p>
<p>读数据的时候很方便的加锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">counter.RLock()</div><div class="line">n := counter.m[<span class="string">"some_key"</span>]</div><div class="line">counter.RUnlock()</div><div class="line">fmt.Println(<span class="string">"some_key:"</span>, n)</div></pre></td></tr></table></figure>

<p>写数据的时候:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">counter.Lock()</div><div class="line">counter.m[<span class="string">"some_key"</span>]++</div><div class="line">counter.Unlock()</div></pre></td></tr></table></figure>

<h3 id="sync-Map">sync.Map</h3>
<p>可以说，上面的解决方案相当简洁，并且利用读写锁而不是Mutex可以进一步减少读写的时候因为锁带来的性能。</p>
<p>但是，它在一些场景下也有问题，如果熟悉Java的同学，可以对比一下java的<code>ConcurrentHashMap</code>的实现，在map的数据非常大的情况下，一把锁会导致大并发的客户端共争一把锁，Java的解决方案是<code>shard</code>, 内部使用多个锁，每个区间共享一把锁，这样减少了数据共享一把锁带来的性能影响，<a href="https://github.com/orcaman" target="_blank" rel="external">orcaman</a>提供了这个思路的一个实现： <a href="https://github.com/orcaman/concurrent-map" target="_blank" rel="external">concurrent-map</a>，他也询问了Go相关的开发人员是否在Go中也实现这种<a href="https://github.com/golang/go/issues/20360" target="_blank" rel="external">方案</a>，由于实现的复杂性，答案是<code>Yes, we considered it.</code>,但是除非有特别的性能提升和应用场景，否则没有进一步的开发消息。</p>
<p>那么，在Go 1.9中<code>sync.Map</code>是怎么实现的呢？它是如何解决并发提升性能的呢？</p>
<p><code>sync.Map</code>的实现有几个优化点，这里先列出来，我们后面慢慢分析。</p>
<ol>
<li>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</li>
<li>使用只读数据(read)，避免读写冲突。</li>
<li>动态调整，miss次数多了之后，将dirty数据提升为read。</li>
<li>double-checking。</li>
<li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li>
<li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li>
</ol>
<p>下面我们介绍<code>sync.Map</code>的重点代码，以便理解它的实现思想。</p>
<p>首先，我们看一下<code>sync.Map</code>的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> {</div><div class="line">	<span class="comment">// 当涉及到dirty数据的操作的时候，需要使用这个锁</span></div><div class="line">	mu Mutex</div><div class="line"></div><div class="line">	<span class="comment">// 一个只读的数据结构，因为只读，所以不会有读写冲突。</span></div><div class="line">	<span class="comment">// 所以从这个数据中读取总是安全的。</span></div><div class="line">	<span class="comment">// 实际上，实际也会更新这个数据的entries,如果entry是未删除的(unexpunged), 并不需要加锁。如果entry已经被删除了，需要加锁，以便更新dirty数据。</span></div><div class="line">	read atomic.Value <span class="comment">// readOnly</span></div><div class="line"></div><div class="line">	<span class="comment">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></div><div class="line">	<span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></div><div class="line">	<span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></div><div class="line">	dirty <span class="keyword">map</span>[<span class="keyword">interface</span>{}]*entry</div><div class="line"></div><div class="line">	<span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></div><div class="line">	<span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span></div><div class="line">	misses <span class="typename">int</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>它的数据结构很简单，值包含四个字段：<code>read</code>、<code>mu</code>、<code>dirty</code>、<code>misses</code>。</p>
<p>它使用了冗余的数据结构<code>read</code>、<code>dirty</code>。<code>dirty</code>中会包含<code>read</code>中为删除的entries，新增加的entries会加入到<code>dirty</code>中。</p>
<p><code>read</code>的数据结构是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> {</div><div class="line">	m       <span class="keyword">map</span>[<span class="keyword">interface</span>{}]*entry</div><div class="line">	amended <span class="typename">bool</span> <span class="comment">// 如果Map.dirty有些数据不在中的时候，这个值为true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>amended</code>指明<code>Map.dirty</code>中有<code>readOnly.m</code>未包含的数据，所以如果从<code>Map.read</code>找不到数据的话，还要进一步到<code>Map.dirty</code>中查找。</p>
<p>对Map.read的修改是通过原子操作进行的。</p>
<p>虽然<code>read</code>和<code>dirty</code>有冗余数据，但这些数据是通过指针指向同一个数据，所以尽管Map的value会很大，但是冗余的空间占用还是有限的。</p>
<p><code>readOnly.m</code>和<code>Map.dirty</code>存储的值类型是<code>*entry</code>,它包含一个指针p, 指向用户存储的value值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> {</div><div class="line">	p unsafe.Pointer <span class="comment">// *interface{}</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>p有三种值：</p>
<ul>
<li>nil: entry已被删除了，并且m.dirty为nil</li>
<li>expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中</li>
<li>其它： entry是一个正常的值</li>
</ul>
<p>以上是<code>sync.Map</code>的数据结构，下面我们重点看看<code>Load</code>、<code>Store</code>、<code>Delete</code>、<code>Range</code>这四个方法，其它辅助方法可以参考这四个方法来理解。</p>
<h4 id="Load">Load</h4>
<p>加载方法，也就是提供一个键<code>key</code>,查找对应的值<code>value</code>,如果不存在，通过<code>ok</code>反映：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Load(key <span class="keyword">interface</span>{}) (value <span class="keyword">interface</span>{}, ok <span class="typename">bool</span>) {</div><div class="line">	<span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	e, ok := read.m[key]</div><div class="line"></div><div class="line">	<span class="comment">// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></div><div class="line">	<span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div><div class="line">		<span class="comment">// 双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></div><div class="line">		read, _ = m.read.Load().(readOnly)</div><div class="line">		e, ok = read.m[key]</div><div class="line"></div><div class="line">		<span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></div><div class="line">		<span class="keyword">if</span> !ok && read.amended {</div><div class="line">			<span class="comment">// 从m.dirty查找</span></div><div class="line">			e, ok = m.dirty[key]</div><div class="line">			<span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></div><div class="line">			<span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></div><div class="line">			m.missLocked()</div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> !ok {</div><div class="line">		<span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">false</span></div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> e.load()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里有两个值的关注的地方。一个是首先从<code>m.read</code>中加载，不存在的情况下，并且<code>m.dirty</code>中有新数据，加锁，然后从<code>m.dirty</code>中加载。</p>
<p>二是这里使用了双检查的处理，因为在下面的两个语句中，这两行语句并不是一个原子操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div></pre></td></tr></table></figure>

<p>虽然第一句执行的时候条件满足，但是在加锁之前，<code>m.dirty</code>可能被提升为<code>m.read</code>,所以加锁后还得再检查<code>m.read</code>，后续的方法中都使用了这个方法。</p>
<p>双检查的技术Java程序员非常熟悉了，单例模式的实现之一就是利用双检查的技术。</p>
<p>可以看到，如果我们查询的键值正好存在于<code>m.read</code>中，无须加锁，直接返回，理论上性能优异。即使不存在于<code>m.read</code>中，经过<code>miss</code>几次之后，<code>m.dirty</code>会被提升为<code>m.read</code>，又会从<code>m.read</code>中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。</p>
<p>下面看看<code>m.dirty</code>是如何被提升的。 <code>missLocked</code>方法中可能会将<code>m.dirty</code>提升。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) missLocked() {</div><div class="line">	m.misses++</div><div class="line">	<span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line">	m.read.Store(readOnly{m: m.dirty})</div><div class="line">	m.dirty = <span class="constant">nil</span></div><div class="line">	m.misses =<span class="number"> 0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的最后三行代码就是提升<code>m.dirty</code>的，很简单的将<code>m.dirty</code>作为<code>readOnly</code>的<code>m</code>字段，原子更新<code>m.read</code>。提升后<code>m.dirty</code>、<code>m.misses</code>重置， 并且<code>m.read.amended</code>为false。</p>
<h4 id="Store">Store</h4>
<p>这个方法是更新或者新增一个entry。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Store(key, value <span class="keyword">interface</span>{}) {</div><div class="line">	<span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></div><div class="line">	<span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok && e.tryStore(&value) {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 如果`m.read`不存在或者已经被标记删除</span></div><div class="line">	m.mu.Lock()</div><div class="line">	read, _ = m.read.Load().(readOnly)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> e, ok := read.m[key]; ok {</div><div class="line">		<span class="keyword">if</span> e.unexpungeLocked() { <span class="comment">//标记成未被删除</span></div><div class="line">			m.dirty[key] = e <span class="comment">//m.dirty中不存在这个键，所以加入m.dirty</span></div><div class="line">		}</div><div class="line">		e.storeLocked(&value) <span class="comment">//更新</span></div><div class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok { <span class="comment">// m.dirty存在这个键，更新</span></div><div class="line">		e.storeLocked(&value)</div><div class="line">	} <span class="keyword">else</span> { <span class="comment">//新键值</span></div><div class="line">		<span class="keyword">if</span> !read.amended { <span class="comment">//m.dirty中没有新的数据，往m.dirty中增加第一个新键</span></div><div class="line">			m.dirtyLocked() <span class="comment">//从m.read中复制未删除的数据</span></div><div class="line">			m.read.Store(readOnly{m: read.m, amended: <span class="constant">true</span>})</div><div class="line">		}</div><div class="line">		m.dirty[key] = newEntry(value) <span class="comment">//将这个entry加入到m.dirty中</span></div><div class="line">	}</div><div class="line">	m.mu.Unlock()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (m *Map) dirtyLocked() {</div><div class="line">	<span class="keyword">if</span> m.dirty != <span class="constant">nil</span> {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>{}]*entry, <span class="built_in">len</span>(read.m))</div><div class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m {</div><div class="line">		<span class="keyword">if</span> !e.tryExpungeLocked() {</div><div class="line">			m.dirty[k] = e</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="keyword">func</span> (e *entry) tryExpungeLocked() (isExpunged <span class="typename">bool</span>) {</div><div class="line">	p := atomic.LoadPointer(&e.p)</div><div class="line">	<span class="keyword">for</span> p == <span class="constant">nil</span> {</div><div class="line">		<span class="comment">// 将已经删除标记为nil的数据标记为expunged</span></div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&e.p, <span class="constant">nil</span>, expunged) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">		p = atomic.LoadPointer(&e.p)</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> p == expunged</div><div class="line">}</div></pre></td></tr></table></figure>

<p>你可以看到，以上操作都是先从操作<code>m.read</code>开始的，不满足条件再加锁，然后操作<code>m.dirty</code>。</p>
<p><code>Store</code>可能会在某种情况下(初始化或者m.dirty刚被提升后)从<code>m.read</code>中复制数据，如果这个时候<code>m.read</code>中数据量非常大，可能会影响性能。</p>
<h4 id="Delete">Delete</h4>
<p>删除一个键值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Delete(key <span class="keyword">interface</span>{}) {</div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line">	e, ok := read.m[key]</div><div class="line">	<span class="keyword">if</span> !ok && read.amended {</div><div class="line">		m.mu.Lock()</div><div class="line">		read, _ = m.read.Load().(readOnly)</div><div class="line">		e, ok = read.m[key]</div><div class="line">		<span class="keyword">if</span> !ok && read.amended {</div><div class="line">			<span class="built_in">delete</span>(m.dirty, key)</div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> ok {</div><div class="line">		e.<span class="built_in">delete</span>()</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>同样，删除操作还是从<code>m.read</code>中开始， 如果这个entry不存在于<code>m.read</code>中，并且<code>m.dirty</code>中有新数据，则加锁尝试从<code>m.dirty</code>中删除。</p>
<p>注意，还是要双检查的。 从<code>m.dirty</code>中直接删除即可，就当它没存在过，但是如果是从<code>m.read</code>中删除，并不会直接删除，而是打标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (e *entry) <span class="built_in">delete</span>() (hadValue <span class="typename">bool</span>) {</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		p := atomic.LoadPointer(&e.p)</div><div class="line">		<span class="comment">// 已标记为删除</span></div><div class="line">		<span class="keyword">if</span> p == <span class="constant">nil</span> || p == expunged {</div><div class="line">			<span class="keyword">return</span> <span class="constant">false</span></div><div class="line">		}</div><div class="line">		<span class="comment">// 原子操作，e.p标记为nil</span></div><div class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&e.p, p, <span class="constant">nil</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="constant">true</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="Range">Range</h4>
<p>因为<code>for ... range map</code>是内建的语言特性，所以没有办法使用<code>for range</code>遍历<code>sync.Map</code>, 但是可以使用它的<code>Range</code>方法，通过回调的方式遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> (m *Map) Range(f <span class="keyword">func</span>(key, value <span class="keyword">interface</span>{}) <span class="typename">bool</span>) {</div><div class="line">	read, _ := m.read.Load().(readOnly)</div><div class="line"></div><div class="line">	<span class="comment">// 如果m.dirty中有新数据，则提升m.dirty,然后在遍历</span></div><div class="line">	<span class="keyword">if</span> read.amended {</div><div class="line">		<span class="comment">//提升m.dirty</span></div><div class="line">		m.mu.Lock()</div><div class="line">		read, _ = m.read.Load().(readOnly) <span class="comment">//双检查</span></div><div class="line">		<span class="keyword">if</span> read.amended {</div><div class="line">			read = readOnly{m: m.dirty}</div><div class="line">			m.read.Store(read)</div><div class="line">			m.dirty = <span class="constant">nil</span></div><div class="line">			m.misses =<span class="number"> 0</span></div><div class="line">		}</div><div class="line">		m.mu.Unlock()</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="comment">// 遍历, for range是安全的</span></div><div class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m {</div><div class="line">		v, ok := e.load()</div><div class="line">		<span class="keyword">if</span> !ok {</div><div class="line">			<span class="keyword">continue</span></div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> !f(k, v) {</div><div class="line">			<span class="keyword">break</span></div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Range方法调用前可能会做一个<code>m.dirty</code>的提升，不过提升<code>m.dirty</code>不是一个耗时的操作。</p>
<h3 id="sync-Map的性能">sync.Map的性能</h3>
<p>Go 1.9源代码中提供了性能的测试： <a href="https://github.com/golang/go/blob/master/src/sync/map_bench_test.go" target="_blank" rel="external">map_bench_test.go</a>、<a href="https://github.com/golang/go/blob/master/src/sync/map_reference_test.go" target="_blank" rel="external">map_reference_test.go</a></p>
<p>我也基于这些代码修改了一下，得到下面的测试数据，相比较以前的解决方案，性能多少回有些提升，如果你特别关注性能，可以考虑<code>sync.Map</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">BenchmarkHitAll/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>   	<span class="number">20000000</span>	        <span class="number">83.8</span> ns/op</div><div class="line">BenchmarkHitAll/*<span class="keyword">sync</span>.Map-<span class="number">4</span>          	<span class="number">30000000</span>	        <span class="number">59.9</span> ns/op</div><div class="line">BenchmarkHitAll_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>         	<span class="number">20000000</span>	        <span class="number">96.9</span> ns/op</div><div class="line">BenchmarkHitAll_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                	<span class="number">20000000</span>	        <span class="number">64.1</span> ns/op</div><div class="line">BenchmarkHitNone/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>                         	<span class="number">20000000</span>	        <span class="number">79.1</span> ns/op</div><div class="line">BenchmarkHitNone/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                                	<span class="number">30000000</span>	        <span class="number">43.3</span> ns/op</div><div class="line">BenchmarkHit_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>            	<span class="number">20000000</span>	        <span class="number">81.5</span> ns/op</div><div class="line">BenchmarkHit_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                   	<span class="number">30000000</span>	        <span class="number">44.0</span> ns/op</div><div class="line">BenchmarkUpdate/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>                          	 <span class="number">5000000</span>	       <span class="number">328</span> ns/op</div><div class="line">BenchmarkUpdate/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                                 	<span class="number">10000000</span>	       <span class="number">146</span> ns/op</div><div class="line">BenchmarkUpdate_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>         	 <span class="number">5000000</span>	       <span class="number">336</span> ns/op</div><div class="line">BenchmarkUpdate_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                	 <span class="number">5000000</span>	       <span class="number">324</span> ns/op</div><div class="line">BenchmarkDelete/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>                          	<span class="number">10000000</span>	       <span class="number">155</span> ns/op</div><div class="line">BenchmarkDelete/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                                 	<span class="number">30000000</span>	        <span class="number">55.0</span> ns/op</div><div class="line">BenchmarkDelete_WithoutPrompting/*<span class="keyword">sync</span>.RWMutexMap-<span class="number">4</span>         	<span class="number">10000000</span>	       <span class="number">173</span> ns/op</div><div class="line">BenchmarkDelete_WithoutPrompting/*<span class="keyword">sync</span>.Map-<span class="number">4</span>                	<span class="number">10000000</span>	       <span class="number">147</span> ns/op</div></pre></td></tr></table></figure>

<h3 id="其它">其它</h3>
<p><code>sync.Map</code>没有<code>Len</code>方法，并且目前没有迹象要加上 (<a href="https://github.com/golang/go/issues/20680" target="_blank" rel="external">issue#20680</a>),所以如果想得到当前Map中有效的entries的数量，需要使用<code>Range</code>方法遍历一次， 比较X疼。</p>
<p><code>LoadOrStore</code>方法如果提供的key存在，则返回已存在的值(Load)，否则保存提供的键值(Store)。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<p>本文带你深入到<code>sync.Map</code>的具体实现中，看看为了增加一个功能，代码是如何变的复杂的,以及作者在实现<code>sync.Map</code>的一些思想。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS X显示连接]]></title>
    <link href="http://colobu.com/2017/07/11/show-connections-in-MACOS/"/>
    <id>http://colobu.com/2017/07/11/show-connections-in-MACOS/</id>
    <published>2017-07-11T07:23:34.000Z</published>
    <updated>2017-07-28T15:12:23.275Z</updated>
    <content type="html"><![CDATA[<p>Mac OSX中虽然带了 <code>netstat</code>工具，可是用起来不像Linux下那么爽， 一个是慢 (<code>netstat -p tcp | grep $PORT</code>)，二是不能pid，所以<a href="https://stackoverflow.com/questions/4421633/who-is-listening-on-a-given-tcp-port-on-mac-os-x" target="_blank" rel="external">stackoverflow</a>上建议使用<code>lsof</code>工具。</p>
<p>所以你可以使用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lsof -n -i4TCP:<span class="variable">$PORT</span> | grep LISTEN <span class="comment"># Verified on macOS Sierra</span></div><div class="line">lsof -n -iTCP:<span class="variable">$PORT</span> | grep LISTEN</div><div class="line">lsof -n -i:<span class="variable">$PORT</span> | grep LISTEN</div></pre></td></tr></table></figure>

<p>为了不显示端口的俗称，你可以加<code>P</code>参数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lsof -nP -i4TCP:<span class="variable">$PORT</span> | <span class="keyword">grep</span> LISTEN <span class="comment"># Verified on macOS Sierra</span></div><div class="line">lsof -nP -iTCP:<span class="variable">$PORT</span> | <span class="keyword">grep</span> LISTEN</div><div class="line">lsof -nP -i:<span class="variable">$PORT</span> | <span class="keyword">grep</span> LISTEN</div></pre></td></tr></table></figure>

<p>如果不想<code>grep Listen</code>,可以加<code>-sTCP:LISTEN</code>。</p>
<p>没有更多要说的了，谨记一下备用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Mac OSX中虽然带了 <code>netstat</code>工具，可是用起来不像Linux下那么爽， 一个是慢 (<code>netstat -p tcp | grep $PORT</code>)，二是不能pid，所以<a href="https://stackove]]>
    </summary>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go语言中 select 和 switch 的比较]]></title>
    <link href="http://colobu.com/2017/07/07/select-vs-switch-in-golang/"/>
    <id>http://colobu.com/2017/07/07/select-vs-switch-in-golang/</id>
    <published>2017-07-07T11:31:10.000Z</published>
    <updated>2017-07-28T15:12:23.274Z</updated>
    <content type="html"><![CDATA[<p><code>select</code> 和 <code>switch</code> 是 Go语言中进行分支操作的两个方式，各有各的应用场景。</p>
<a id="more"></a>
<h3 id="select">select</h3>
<p><code>select</code>只能应用于channel的操作，既可以用于channel的数据接收，也可以用于channel的数据发送。</p>
<p>如果<code>select</code>的多个分支都满足条件，则会随机的选取其中一个满足条件的分支， 如语言规范中所说：</p>
<blockquote>
<p>If multiple cases can proceed, a uniform pseudo-random choice is made to decide which single communication will execute.</p>
</blockquote>
<p>｀case｀语句的表达式可以为一个变量或者两个变量赋值。</p>
<p>有<code>default</code>语句。</p>
<p>下面的代码是 <a href="https://gobyexample.com/select" target="_blank" rel="external">go by example 上的例子</a>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)</div><div class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">string</span>)</div><div class="line"></div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        time.Sleep(time.Second *<span class="number"> 1</span>)</div><div class="line">        c1 &lt;- <span class="string">"one"</span></div><div class="line">    }()</div><div class="line">    <span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">        time.Sleep(time.Second *<span class="number"> 2</span>)</div><div class="line">        c2 &lt;- <span class="string">"two"</span></div><div class="line">    }()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i :=<span class="number"> 0</span>; i &lt;<span class="number"> 2</span>; i++ {</div><div class="line">        <span class="keyword">select</span> {</div><div class="line">        <span class="keyword">case</span> msg1 := &lt;-c1:</div><div class="line">            fmt.Println(<span class="string">"received"</span>, msg1)</div><div class="line">        <span class="keyword">case</span> msg2 := &lt;-c2:</div><div class="line">            fmt.Println(<span class="string">"received"</span>, msg2)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="switch">switch</h3>
<p><code>switch</code>可以为各种类型进行分支操作， 设置可以为接口类型进行分支判断(通过i.(type))。</p>
<p><code>switch</code> 分支是顺序执行的，这和<code>select</code>不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"time"</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line"></div><div class="line">    i :=<span class="number"> 2</span></div><div class="line">    fmt.Print(<span class="string">"Write "</span>, i, <span class="string">" as "</span>)</div><div class="line">    <span class="keyword">switch</span> i {</div><div class="line">    <span class="keyword">case</span><span class="number"> 1</span>:</div><div class="line">        fmt.Println(<span class="string">"one"</span>)</div><div class="line">    <span class="keyword">case</span><span class="number"> 2</span>:</div><div class="line">        fmt.Println(<span class="string">"two"</span>)</div><div class="line">    <span class="keyword">case</span><span class="number"> 3</span>:</div><div class="line">        fmt.Println(<span class="string">"three"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> time.Now().Weekday() {</div><div class="line">    <span class="keyword">case</span> time.Saturday, time.Sunday:</div><div class="line">        fmt.Println(<span class="string">"It's the weekend"</span>)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Println(<span class="string">"It's a weekday"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    t := time.Now()</div><div class="line">    <span class="keyword">switch</span> {</div><div class="line">    <span class="keyword">case</span> t.Hour() &lt;<span class="number"> 12</span>:</div><div class="line">        fmt.Println(<span class="string">"It's before noon"</span>)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Println(<span class="string">"It's after noon"</span>)</div><div class="line">    }</div><div class="line"></div><div class="line">    whatAmI := <span class="keyword">func</span>(i <span class="keyword">interface</span>{}) {</div><div class="line">        <span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) {</div><div class="line">        <span class="keyword">case</span> <span class="typename">bool</span>:</div><div class="line">            fmt.Println(<span class="string">"I'm a bool"</span>)</div><div class="line">        <span class="keyword">case</span> <span class="typename">int</span>:</div><div class="line">            fmt.Println(<span class="string">"I'm an int"</span>)</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            fmt.Printf(<span class="string">"Don't know type %T\n"</span>, t)</div><div class="line">        }</div><div class="line">    }</div><div class="line">    whatAmI(<span class="constant">true</span>)</div><div class="line">    whatAmI<span class="number">(1</span>)</div><div class="line">    whatAmI(<span class="string">"hey"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><code>select</code> 和 <code>switch</code> 是 Go语言中进行分支操作的两个方式，各有各的应用场景。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]golang concurrency tricks]]></title>
    <link href="http://colobu.com/2017/07/07/golang-concurrency-tricks/"/>
    <id>http://colobu.com/2017/07/07/golang-concurrency-tricks/</id>
    <published>2017-07-07T10:58:21.000Z</published>
    <updated>2017-07-28T15:12:23.269Z</updated>
    <content type="html"><![CDATA[<p>原文地址: <a href="https://udhos.github.io/golang-concurrency-tricks/" target="_blank" rel="external">Golang Concurrency Tricks</a></p>
<p>Golang concurrency model based on goroutines and channels is not free from sharp edges.</p>
<p>This page intends both (1) to collect helpful guidelines for writing concurrent code in Go and (2) to bring up well known potential issues to attention.</p>
<a id="more"></a>
<h2 id="Channel_Hints">Channel Hints</h2>
<ul>
<li><p>C1. Some channel operations cause runtime panic:</p>
<ul>
<li>P1. Closing the nil channel.</li>
<li>P2. Closing a closed channel.</li>
<li>P3. Sending on a closed channel.</li>
</ul>
</li>
<li><p>C2. Do not close a channel from a receiver goroutine. Closing the channel from a receiver could make future sender goroutines to panic.</p>
</li>
<li><p>C3. If a channel has multiple senders, do not close the channel from a sender goroutine. Closing the channel from a sender could make future sender goroutine to panic.</p>
</li>
</ul>
<p>Alternatively, coordinate senders so that only the last sender to leave closes the channel (for instance by using either atomic int or sync.WaitGroup)</p>
<p>Last one sender to leave, turns off the lights, which can be controlled by a atomic int.<br><a href="https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/oZFSD-oMAwAJ" target="_blank" rel="external">https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/oZFSD-oMAwAJ</a></p>
<ul>
<li>C4. It is not required to close an unused channel. If no goroutine is left referencing the channel, it will be garbage collected.</li>
</ul>
<p>Note that it is only necessary to close a channel if the receiver is looking for a close. Closing the channel is a control signal on the channel indicating that no more data follows.<br><a href="https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ" target="_blank" rel="external">https://groups.google.com/forum/#!msg/golang-nuts/pZwdYRGxCIk/qpbHxRRPJdUJ</a></p>
<ul>
<li>C5. Channels work well when enclosed in a &#39;select&#39;.</li>
</ul>
<p>If you are ever using a channel outside of a select in production code, you are probably doing it wrong.<br><a href="https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ" target="_blank" rel="external">https://groups.google.com/d/msg/golang-nuts/LM648yrPpck/j5eHsPc2AwAJ</a></p>
<ul>
<li><p>C6. If you need bidirectional communication between two goroutines, consider using two unidirectional channels. Thus both channel sides will be able to use the close idiom to signal termination.</p>
</li>
<li><p>C7. Beware: one sender goroutine risks blocking indefinitely when writing on a channel if there is no goroutine left receiving from it.</p>
</li>
<li><p>C8. When designing a goroutine which provides service through channels, and at some point a running goroutine is no longer needed, consider exactly how it will finish. Otherwise, unused goroutines may leak idly servicing an unattended channel.</p>
</li>
<li><p>C9. Keep Dave Cheney&#39;s Four Channel Axioms in mind:</p>
<ul>
<li>A1. A send to a nil channel blocks forever.</li>
<li>A2. A receive from a nil channel blocks forever. (Why? Here is why. Example.)</li>
<li>A3. A send to a closed channel panics.</li>
<li>A4. A receive from a closed channel returns the zero value immediately.</li>
</ul>
</li>
<li><p>C10. &#39;select&#39; never selects a blocking case.</p>
</li>
</ul>
<h2 id="Goroutine_Hints">Goroutine Hints</h2>
<ul>
<li>G1. Only one goroutine accessing a piece of data is good practice.</li>
</ul>
<p>In particular, consider structuring your program so that only one goroutine at a time is ever responsible for a particular piece of data.<br><a href="https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes" target="_blank" rel="external">https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes</a></p>
<ul>
<li>G2. runtime.Goexit() terminates the goroutine that calls it.</li>
</ul>
<h2 id="See_also:">See also:</h2>
<p><a href="http://www.slideshare.net/cloudflare/a-channel-compendium" target="_blank" rel="external">http://www.slideshare.net/cloudflare/a-channel-compendium</a><br><a href="https://github.com/golang/go/wiki/LearnConcurrency" target="_blank" rel="external">https://github.com/golang/go/wiki/LearnConcurrency</a><br><a href="http://dave.cheney.net/2014/03/19/channel-axioms" target="_blank" rel="external">http://dave.cheney.net/2014/03/19/channel-axioms</a></p>
<hr>
<p>Repository: git clone <a href="https://github.com/udhos/golang-concurrency-tricks.git" target="_blank" rel="external">https://github.com/udhos/golang-concurrency-tricks.git</a><br>Web URL: <a href="http://udhos.github.io/golang-concurrency-tricks" target="_blank" rel="external">http://udhos.github.io/golang-concurrency-tricks</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文地址: <a href="https://udhos.github.io/golang-concurrency-tricks/" target="_blank" rel="external">Golang Concurrency Tricks</a></p>
<p>Golang concurrency model based on goroutines and channels is not free from sharp edges.</p>
<p>This page intends both (1) to collect helpful guidelines for writing concurrent code in Go and (2) to bring up well known potential issues to attention.</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]参考资料: 地道的GO代码]]></title>
    <link href="http://colobu.com/2017/06/30/idiomatic-go-references/"/>
    <id>http://colobu.com/2017/06/30/idiomatic-go-references/</id>
    <published>2017-06-30T02:41:52.000Z</published>
    <updated>2017-07-28T15:12:23.271Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://pocketgophers.com/idiomatic-go/" target="_blank" rel="external">Idiomatic Go</a></p>
<p>什么样的代码才算最地道的Go代码？ 这个问题经常被人问起，但是确不太好回答。部分原因在于我们还在摸索之中，抑或Go还是一个年轻的语言。随着语言和社区的逐渐成熟，老司机们才会对地道的Go代码达成共识。</p>
<p>请注意，地道的代码不是限制你的规则，而是代码指导。工作正常的代码比地道的代码更重要。因为所谓的地道,只是大家达成的一种共识，所以&quot;不地道&quot;的的代码不一定代表着错误。</p>
<p>既然没有确定的答案，我在本文中收集了相关的参考资料, 以飨读者。</p>
<a id="more"></a>
<h3 id="Accept_interfaces,_return_concrete_types"><a href="http://idiomaticgo.com/post/best-practice/accept-interfaces-return-structs/" target="_blank" rel="external">Accept interfaces, return concrete types</a></h3>
<p><strong>Craig Brookes 2016-11-02</strong></p>
<p>解释什么是地道的代码， 为什么你要遵循它。</p>
<h3 id="Code_Review_Comments"><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="external">Code Review Comments</a></h3>
<p>在Code review的时候一套通用的指导， 简短几句话介绍编写代码的地道的方式。 Go官方出品。</p>
<h3 id="Effective_Go"><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="external">Effective Go</a></h3>
<p>Go开发组提供了编写清晰、地道的Go代码的小窍门。这是Go程序员必读的参考文档， 不止有地道的代码指导，而且还有Go各种特性的背后的考量。</p>
<h3 id="Go_Patterns"><a href="http://tmrts.com/go-patterns/" target="_blank" rel="external">Go Patterns</a></h3>
<p><strong>Tamer Tas</strong></p>
<p>关于Go语言的设计模式和应用程序模式的集合。</p>
<h3 id="Go_Proverbs"><a href="https://go-proverbs.github.io/" target="_blank" rel="external">Go Proverbs</a></h3>
<p>Rob Pike收集的简单、富有诗意的精辟语录， 解释Go语言深层次的哲学、以更容易理解方式。真正理解并应用它们会让你成为Go大牛。</p>
<h3 id="Go_and_the_Zen_of_Python"><a href="https://talks.golang.org/2012/zen.slide" target="_blank" rel="external">Go and the Zen of Python</a></h3>
<p><strong>Andrew Gerrand</strong></p>
<p>比较 Python 和 Go 之禅意。</p>
<h3 id="Go_by_Example"><a href="https://gobyexample.com/" target="_blank" rel="external">Go by Example</a></h3>
<p>使用带注解的例子教授Go， 会讨论什么样的代码才是地道的代码。</p>
<h3 id="Idiomatic_Doc_Comments:_Document_Your_Function,_Not_Your_Function_Signature"><a href="http://whipperstacker.com/2015/10/14/idiomatic-doc-comments-document-your-function-not-your-function-signature/" target="_blank" rel="external">Idiomatic Doc Comments: Document Your Function, Not Your Function Signature</a></h3>
<p><strong>Katrina Owen 2015-10-14</strong></p>
<p>通过示例解释如何为Go函数编写有帮助的注释。</p>
<h3 id="Idiomatic_Go"><a href="https://dmitri.shuralyov.com/idiomatic-go" target="_blank" rel="external">Idiomatic Go</a></h3>
<p><strong>Dmitri Shuralyov</strong></p>
<p>对<a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="external">Code Review Comments</a>的补充，通过令人信服理由和参考文献， 列举了地道的Go代码指导。</p>
<h3 id="Idiomatic_Go_Readability"><a href="https://medium.com/@haya14busa/idiomatic-go-readability-f0b42ef381dc" target="_blank" rel="external">Idiomatic Go Readability</a></h3>
<p>haya14busa</p>
<p>地道的可读性的Go代码的实践经验和窍门， 包括自动和手动方式。</p>
<h3 id="Idiomatic_Go_Tests"><a href="http://idiomaticgo.com/post/testing/idiomatic-go-tests/" target="_blank" rel="external">Idiomatic Go Tests</a></h3>
<p><strong>Craig Brookes</strong></p>
<p>作者通过例子解释地道的Go测试应该怎么做。</p>
<h3 id="Idiomatic_Go_Trickshttps://medium-com/@matryer/idiomatic-go-tricks-62abea5c50fb"><a href="">Idiomatic Go Tricks</a><a href="https://medium.com/@matryer/idiomatic-go-tricks-62abea5c50fb" target="_blank" rel="external">https://medium.com/@matryer/idiomatic-go-tricks-62abea5c50fb</a></h3>
<p><strong>Mat Ryer video slides 2016-08-18</strong></p>
<p>一些技巧和窍门让你像个老司机一样谈论Go。</p>
<h3 id="Itty_Bitty_Go_Idiom:_If_Without_Else"><a href="http://whipperstacker.com/2015/10/16/itty-bitty-go-idiom-if-without-else/" target="_blank" rel="external">Itty Bitty Go Idiom: If Without Else</a></h3>
<p><strong>Katrina Owen 2015-10-16</strong></p>
<p>为什么你通常看到的Go代码中<code>if</code>语句没有<code>else</code>分支， 这篇文章解释了这个问题。</p>
<h3 id="Things_I_learned_teaching_Go"><a href="https://youtu.be/B-r3Wf_I2Lk" target="_blank" rel="external">Things I learned teaching Go</a></h3>
<p><strong>Francesc Campoy Flores 2014-10-10</strong></p>
<blockquote>
<p>It&#39;s better because it&#39;s what other people in the community expect.</p>
</blockquote>
<p>通过教学总结的经验。</p>
<h3 id="What_is_idiomatic_Go?"><a href="https://www.reddit.com/r/golang/comments/5b2j38/what_is_idiomatic_go/" target="_blank" rel="external">What is idiomatic Go?</a></h3>
<p>这是reddit是的一篇讨论，对一个代码库的中的非地道Go代码的抨击。评论显示这些地道代码指导对社区的帮助和伤害。</p>
<h3 id="When_in_Go,_do_as_Gophers_do"><a href="https://talks.golang.org/2014/readability.slide" target="_blank" rel="external">When in Go, do as Gophers do</a></h3>
<p><strong>Fumitoshi Ukai 2014-11-30</strong></p>
<p>通过Review对Go项目代码的提交学到的一些地道的编写Go代码的方式。作者作为 Go Readability Approver,一年中review大约200左右的 CL， 在本文中总结了他所学到的。</p>
<p>一旦我发现了更多的参考资料，我会更新这篇文章， 所以记得收藏本文。</p>
<p><em>当然作为译者，我也会补充更多的参考资料，如果你发现了一些关于这方面的参考资料，记得在评论中贴出来哦。</em></p>
<h3 id="50_Shades_of_Go:_Traps,_Gotchas,_and_Common_Mistakes_for_New_Golang_Devs"><a href="http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs</a></h3>
<p><strong>Kyle Quest</strong></p>
<p><a href="http://colobu.com/2015/09/07/gotchas-and-common-mistakes-in-go-golang/" target="_blank" rel="external">Go的50度灰：Golang新开发者要注意的陷阱和常见错误</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://pocketgophers.com/idiomatic-go/" target="_blank" rel="external">Idiomatic Go</a></p>
<p>什么样的代码才算最地道的Go代码？ 这个问题经常被人问起，但是确不太好回答。部分原因在于我们还在摸索之中，抑或Go还是一个年轻的语言。随着语言和社区的逐渐成熟，老司机们才会对地道的Go代码达成共识。</p>
<p>请注意，地道的代码不是限制你的规则，而是代码指导。工作正常的代码比地道的代码更重要。因为所谓的地道,只是大家达成的一种共识，所以&quot;不地道&quot;的的代码不一定代表着错误。</p>
<p>既然没有确定的答案，我在本文中收集了相关的参考资料, 以飨读者。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Nginx内部自动处理3XX跳转]]></title>
    <link href="http://colobu.com/2017/06/29/How-to-follow-HTTP-redirects-inside-nginx/"/>
    <id>http://colobu.com/2017/06/29/How-to-follow-HTTP-redirects-inside-nginx/</id>
    <published>2017-06-29T05:57:51.000Z</published>
    <updated>2017-07-28T15:12:23.253Z</updated>
    <content type="html"><![CDATA[<p>利用Nginx很容易的配置反向代理和负载均衡的服务, 比如下面的配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">upstream backends {</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.10</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.11</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.12</span>:<span class="number">8080</span>;</div><div class="line">}</div><div class="line"></div><div class="line">server{ </div><div class="line">    listen <span class="number">8080</span>; </div><div class="line">    location / { </div><div class="line">        proxy_pass         http://backends; </div><div class="line">        proxy_<span class="keyword">set</span>_header   Host             <span class="variable">$host</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Real-IP        <span class="variable">$remote_addr</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>; </div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<p>它将客户端的请求转发给后台的三个服务器。 负载均衡的算法又多种， 比如轮询、least_conn、ip_hash、weight等算法，本文重点不介绍这方面的内容，而是下面的需求。</p>
<p>后端服务器可能返回 3XX的redirect的response, Nginx会把这个请求直接返回给客户端。现在我们的需求是让Nginx自己处理这个跳转，而客户端无感知。</p>
<a id="more"></a>
<p>经过查找，找到一种解决方案， 如 <a href="https://serverfault.com/questions/423265/how-to-follow-http-redirects-inside-nginx" target="_blank" rel="external">serverfault</a>提到的，我们可以利用<code>error_page</code>指令将3xx转发给另外的location, 利用<code>$upstream_http_location</code>获得转发的地址：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">upstream backends {</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.10</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.11</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.12</span>:<span class="number">8080</span>;</div><div class="line">}</div><div class="line"></div><div class="line">server{ </div><div class="line">    listen <span class="number">8080</span>; </div><div class="line">    location / { </div><div class="line">        proxy_pass         http://backends; </div><div class="line">        proxy_<span class="keyword">set</span>_header   Host             <span class="variable">$host</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Real-IP        <span class="variable">$remote_addr</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>; </div><div class="line"></div><div class="line">        proxy_intercept_errors on;</div><div class="line">        error_page <span class="number">301</span> <span class="number">302</span> <span class="number">307</span> = @handle_redirect;</div><div class="line">    } </div><div class="line"></div><div class="line">    location @handle_redirect {</div><div class="line">            <span class="keyword">set</span> <span class="variable">$saved_redirect_location</span> <span class="string">'$upstream_http_location'</span>;</div><div class="line">            proxy_pass <span class="variable">$saved_redirect_location</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>挺巧妙的一个解决方案。</p>
<p>另一个解决方案是 <a href="https://stackoverflow.com/questions/20254456/intercepting-backend-301-302-redirects-proxy-pass-and-rewriting-to-another-loc" target="_blank" rel="external">stackoverflow</a>提到的, 返回给客户端的时候， 利用<code>proxy_redirect</code>指令修改Location的头，让client端重定向到Nginx特定的地址，Nginx再将请求转发给后端服务器。， 不过这个方案要求客户端支持重定向的能力。</p>
<h5 id="参考文档">参考文档</h5>
<ol>
<li><a href="https://serverfault.com/questions/423265/how-to-follow-http-redirects-inside-nginx" target="_blank" rel="external">https://serverfault.com/questions/423265/how-to-follow-http-redirects-inside-nginx</a></li>
<li><a href="https://stackoverflow.com/questions/20254456/intercepting-backend-301-302-redirects-proxy-pass-and-rewriting-to-another-loc" target="_blank" rel="external">https://stackoverflow.com/questions/20254456/intercepting-backend-301-302-redirects-proxy-pass-and-rewriting-to-another-loc</a></li>
<li><a href="https://stackoverflow.com/questions/42134258/follow-redirect-301-and-proxy-pass-last-location-found-with-nginx" target="_blank" rel="external">https://stackoverflow.com/questions/42134258/follow-redirect-301-and-proxy-pass-last-location-found-with-nginx</a></li>
<li><a href="https://gist.github.com/sirsquidness/710bc76d7bbc734c7a3ff69c6b8ff591" target="_blank" rel="external">https://gist.github.com/sirsquidness/710bc76d7bbc734c7a3ff69c6b8ff591</a></li>
<li><a href="http://www.jianshu.com/p/ac8956f79206" target="_blank" rel="external">http://www.jianshu.com/p/ac8956f79206</a></li>
<li><a href="https://github.com/moonbingbing/openresty-best-practices/blob/master/ngx/reverse_proxy.md" target="_blank" rel="external">https://github.com/moonbingbing/openresty-best-practices/blob/master/ngx/reverse_proxy.md</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>利用Nginx很容易的配置反向代理和负载均衡的服务, 比如下面的配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">upstream backends {</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.10</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.11</span>:<span class="number">8080</span>;</div><div class="line">      server <span class="number">10.0</span>.<span class="number">0.12</span>:<span class="number">8080</span>;</div><div class="line">}</div><div class="line"></div><div class="line">server{ </div><div class="line">    listen <span class="number">8080</span>; </div><div class="line">    location / { </div><div class="line">        proxy_pass         http://backends; </div><div class="line">        proxy_<span class="keyword">set</span>_header   Host             <span class="variable">$host</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Real-IP        <span class="variable">$remote_addr</span>; </div><div class="line">        proxy_<span class="keyword">set</span>_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>; </div><div class="line">    } </div><div class="line">}</div></pre></td></tr></table></figure>

<p>它将客户端的请求转发给后台的三个服务器。 负载均衡的算法又多种， 比如轮询、least_conn、ip_hash、weight等算法，本文重点不介绍这方面的内容，而是下面的需求。</p>
<p>后端服务器可能返回 3XX的redirect的response, Nginx会把这个请求直接返回给客户端。现在我们的需求是让Nginx自己处理这个跳转，而客户端无感知。</p>
]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://colobu.com/tags/Nginx/"/>
    
      <category term="工具" scheme="http://colobu.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]像牛人一样改进你的Go代码]]></title>
    <link href="http://colobu.com/2017/06/27/Lint-your-golang-code-like-a-mad-man/"/>
    <id>http://colobu.com/2017/06/27/Lint-your-golang-code-like-a-mad-man/</id>
    <published>2017-06-27T11:04:33.000Z</published>
    <updated>2017-07-28T15:12:23.260Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://medium.com/@arshamshirvani/lint-your-golang-code-like-a-pro-668dc6637b39" target="_blank" rel="external">Lint your #golang code like a mad man!</a>, 作者: <a href="https://medium.com/@arshamshirvani?source=post_header_lockup" target="_blank" rel="external">Arsham Shirvani</a></p>
<p>我使用下面的工具来改进我的代码，除了<code>vendor</code>文件夹。我的操作系统是<code>GNU/Linux</code>,但是稍微修改一下脚本应该也能运行在你的操作系统上。我使用<a href="https://github.com/Masterminds/glide" target="_blank" rel="external">glide</a>来处理依赖(vendor),但你也可以使用你的包依赖管理工具来替换<code>glide nv</code>， 这个命令列出了所有的文件夹，除了vender (译者按： Go 1.9中可以直接使用<code>./...</code>，它会排除vendor文件夹)。有些情况下<code>glide nv</code>不适合，所以我使用了它的老式风格。</p>
<p>注意我使用<code>$</code>作为shell的提示符。</p>
<a id="more"></a>
<h3 id="gofmt">gofmt</h3>
<p>Go安装程序中自带了<code>gofmt</code>工具，可以使用它来格式化代码，保持一致的代码风格：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . -name <span class="string">"*.go"</span> -not -path <span class="string">"./vendor/*"</span> -not -path <span class="string">".git/*"</span> | xargs gofmt <span class="operator">-s</span> <span class="operator">-d</span></div></pre></td></tr></table></figure>

<h3 id="gocyclo">gocyclo</h3>
<p>gocyclo 用来检查函数的复杂度。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/fzipp/gocyclo</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gocyclo -over <span class="number">12</span> $(ls <span class="operator">-d</span> */ | grep -v vendor)</div></pre></td></tr></table></figure>

<p>上面的命令列出了所有复杂度大于12的函数。你还可以提出最复杂的几个：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gocyclo -top <span class="number">10</span> $(ls <span class="operator">-d</span> */ | grep -v vendor)</div></pre></td></tr></table></figure>

<h3 id="interfacer">interfacer</h3>
<p>interfacer 是一个有趣的工具，依照作者所说：</p>
<blockquote>
<p>这个工具提供接口类型的建议，换句话说，它会对可以本没有必要定义成具体的类型的代码提出警告</p>
</blockquote>
<p>安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/mvdan/interfacer/cmd/interfacer</div></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ interfacer $(glide nv)</div></pre></td></tr></table></figure>

<p>译者按：看官方的例子就明白这个工具的作用了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> ProcessInput(f *os.File) error {</div><div class="line">        b, err := ioutil.ReadAll(f)</div><div class="line">        <span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">                <span class="keyword">return</span> err</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> processBytes(b)</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ interfacer $(go list ./... | grep -v /vendor/)</div><div class="line">foo.go:<span class="number">10</span>:<span class="number">19</span>: f can be io.Reader</div></pre></td></tr></table></figure>

<h3 id="deadcode">deadcode</h3>
<p>deadcode会告诉你哪些代码片段根本没用。</p>
<p>安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/tsenart/deadcode</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">find</span> . -<span class="built_in">type</span> <span class="keyword">d</span> -not -path <span class="string">"./vendor/*"</span> | xargs deadcode</div></pre></td></tr></table></figure>

<h3 id="gotype">gotype</h3>
<p>gotype会对go文件和包进行语义(semantic)和句法(syntactic)的分析,这是google提供的一个工具。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u golang.org/x/tools/cmd/gotype</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . -name <span class="string">"*.go"</span> -not -path <span class="string">"./vendor/*"</span> -not -path <span class="string">".git/*"</span> -print0 | xargs -<span class="number">0</span> gotype <span class="operator">-a</span></div></pre></td></tr></table></figure>

<h3 id="misspell">misspell</h3>
<p>misspell用来拼写检查，对国内英语不太熟练的同学很有帮助。</p>
<p>安装:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/client9/misspell</div></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . -type f -not -path <span class="string">"./vendor/*"</span> -print0 | xargs -<span class="number">0</span> misspell</div></pre></td></tr></table></figure>

<h3 id="staticcheck">staticcheck</h3>
<p>staticcheck是一个超牛的工具，提供了巨多的静态检查，就像 C#生态圈的 ReSharper 一样。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u honnef.co/go/staticcheck/cmd/staticcheck</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ staticcheck $(glide nv)</div></pre></td></tr></table></figure>

<h3 id="gosimple">gosimple</h3>
<p>gosimple 提供信息，帮助你了解哪些代码可以简化。</p>
<p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u honnef.co/go/simple/cmd/gosimple</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gosimple $(glide nv)</div></pre></td></tr></table></figure>

<p>译者按： 事实上这个工具和上面的staticcheck工具已经合并为同一个项目了：<a href="https://github.com/dominikh/go-tools" target="_blank" rel="external">go-tools</a>，这个项目提供了非常好的工具， 还包括 <code>structlayout-optimize</code>、<code>unused</code>、<code>rdeps</code>、<code>keyify</code>等，值的你去探索。</p>
<h3 id="goconst">goconst</h3>
<p>goconst 会查找重复的字符串，这些字符串可以抽取成常量。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/jgautheron/goconst/cmd/goconst</div></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ goconst ./… | grep -v vendor</div></pre></td></tr></table></figure>

<p>以上是作者列出的一些工具， 和我以前的一篇文章中列出的工具有很多重合的： <a href="http://colobu.com/2017/02/07/write-idiomatic-golang-codes/#使用工具检查你的代码" target="_blank" rel="external">使用工具检查你的代码</a>， 事实上我在项目中已经使用了文中很多的代码，非常非常的有帮助，希望你在阅读后能有所收获，快将这些工具加入到你的Makefile文件中吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://medium.com/@arshamshirvani/lint-your-golang-code-like-a-pro-668dc6637b39" target="_blank" rel="external">Lint your #golang code like a mad man!</a>, 作者: <a href="https://medium.com/@arshamshirvani?source=post_header_lockup" target="_blank" rel="external">Arsham Shirvani</a></p>
<p>我使用下面的工具来改进我的代码，除了<code>vendor</code>文件夹。我的操作系统是<code>GNU/Linux</code>,但是稍微修改一下脚本应该也能运行在你的操作系统上。我使用<a href="https://github.com/Masterminds/glide" target="_blank" rel="external">glide</a>来处理依赖(vendor),但你也可以使用你的包依赖管理工具来替换<code>glide nv</code>， 这个命令列出了所有的文件夹，除了vender (译者按： Go 1.9中可以直接使用<code>./...</code>，它会排除vendor文件夹)。有些情况下<code>glide nv</code>不适合，所以我使用了它的老式风格。</p>
<p>注意我使用<code>$</code>作为shell的提示符。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[了解 Go 1.9 的类型别名]]></title>
    <link href="http://colobu.com/2017/06/26/learn-go-type-aliases/"/>
    <id>http://colobu.com/2017/06/26/learn-go-type-aliases/</id>
    <published>2017-06-26T09:20:19.000Z</published>
    <updated>2017-07-28T15:12:23.273Z</updated>
    <content type="html"><![CDATA[<p>如你所知， 类型别名(type aliases) 最终还是加入到Go 1.9中， Go 1.9 beta2今天已经发布了, 正式版预计8月初发布， 是时候深入了解一下它的新特性了，本文介绍的就是它的重要的新特性之一： 类型别名。 </p>
<p>当然，如果你想尝试这些新特性，需要安装Go 1.9的版本，目前是beta2版，可以在官方网站下载。<br><a id="more"></a></p>
<p>类型别名主要解决什么问题，为什么需要这个特性？ Russ Cox 的论文<a href="https://talks.golang.org/2016/refactor.article" target="_blank" rel="external">Codebase Refactoring (with help from Go)</a>介绍了它的背景。类型别名主要用在：</p>
<ol>
<li>在大规模的重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码使用新包中的类型，有些代码使用旧包中的类型， 比如<code>context</code></li>
<li>允许一个庞大的包分解成内部的几个小包，但是小包中的类型需要集中暴漏在上层的大包中</li>
</ol>
<h3 id="类型别名">类型别名</h3>
<p>类型别名的语法如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> identifier = Type</div></pre></td></tr></table></figure>

<p>它和类型定义(type definition)类似，仅仅是在<code>identifier</code>和<code>Type</code>之间加了一个等号<code>=</code>，但是和类型定义区别很大，这一点会在后面专门比较。</p>
<p>下面这个例子就是为字符串<code>string</code>类型定义了一个别名<code>S</code>,你可以声明变量、常量为<code>S</code>类型，将字符串赋值给它，它和字符串类型几乎一模一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> S = <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s S = <span class="string">"hello world"</span></div><div class="line">	fmt.Println(s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然， 你可以为任意的类型定义类型别名，语言规范中没有限制，可以为数组、结构体、指针、函数、接口、Slice、Map、Channel定义别名，甚至你还可以为通过类型定义(type definition)的类型定义别名，更甚者是你可以为别名定义别名。</p>
<p>比如下面这个例子， 为函数类型<code>func()</code>定义了一个别名<code>F</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> F = <span class="keyword">func</span>()</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> foo F = <span class="keyword">func</span>() {</div><div class="line">		fmt.Println(<span class="string">"hello type aliases"</span>)</div><div class="line">	}</div><div class="line"></div><div class="line">	foo()	</div><div class="line">}</div></pre></td></tr></table></figure>

<p>又如下面的代码，为<code>interface{}</code>定义了别名<code>G</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> G = <span class="keyword">interface</span>{}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> g G = <span class="string">"hello world"</span></div><div class="line">	fmt.Println(g)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>类型别名还可以为其它包中的类型定义别名，只要这个类型在其它包中是<code>exported</code>的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyTime = time.Time</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> t MyTime = time.Now()</div><div class="line">	fmt.Println(t)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="类型命名和类型声明的区别">类型命名和类型声明的区别</h3>
<p>记住下面一句话：</p>
<blockquote>
<p>类型别名和原类型完全一样，只不过是另一种叫法而已</p>
</blockquote>
<p>这句话隐藏着很多的智慧，你可以慢慢体会。</p>
<p>完全一样(<a href="https://golang.org/ref/spec#Type_identity" target="_blank" rel="external">identical types</a>)意味着这两种类型的数据可以互相赋值，而类型定义要和原始类型赋值的时候需要类型转换(Conversion <code>T(x)</code>)。</p>
<p>下面这个例子中，<code>v</code>是整数类型，可以直接赋值给<code>d</code>,因为d的类型是<code>D</code>,是是整数的别名。而<code>var i I = v</code>这一句会出错，因为<code>I</code>和整数是两个类型。 </p>
<p>所以类型别名和类型定义最大的区别在于：类型别名和原类型是相同的，而类型定义和原类型是不同的两个类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> D = <span class="typename">int</span></div><div class="line"><span class="keyword">type</span> I <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	v :=<span class="number"> 100</span></div><div class="line">	<span class="keyword">var</span> d D = v</div><div class="line">	<span class="keyword">var</span> i I = v</div><div class="line">}</div></pre></td></tr></table></figure>

<p>比如类型定义<code>type Tnamed Tunderlying</code>,系列类型和组合类型是不同的:</p>
<ul>
<li><code>Tnamed</code> 和 <code>Tunderlying</code></li>
<li><code>*Tnamed</code> 和 <code>*Tunderlying</code></li>
<li><code>chan Tnamed</code> 和 <code>chan Tunderlying</code></li>
<li><code>func(Tnamed)</code> 和 <code>func(Tunderlying)</code></li>
<li><code>interface{ M() Tnamed }</code> 和 <code>interface{ M() Tunderlying }</code></li>
</ul>
<p>但是对于别名<code>type T1 = T2</code>,下列类型和组合类型是相同的:</p>
<ul>
<li><code>T1</code> 和 <code>T2</code></li>
<li><code>*T1</code> 和 <code>*T2</code></li>
<li><code>chan T1</code> 和 <code>chan T2</code></li>
<li><code>func(T1)</code> 和 <code>func(T2)</code></li>
<li><code>interface{ M() T1 }</code> 和 <code>interface{ M() T2 }</code></li>
</ul>
<p>还有一个重要的区别在于类型定义的类型的方法集和原始类型的方法集没有任何关系，而类型别名和原始类型的方法集是一样的，下面再介绍。</p>
<p>既然类型别名和原类型是相同的，那么在`switch - type中，你不能将原类型和类型别名作为两个分支，因为这是重复的case:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> D = <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> v <span class="keyword">interface</span>{} </div><div class="line">	<span class="keyword">var</span> d D =<span class="number"> 100</span></div><div class="line">	v = d</div><div class="line">	</div><div class="line">	<span class="keyword">switch</span> i := v.(<span class="keyword">type</span>) {</div><div class="line">		<span class="keyword">case</span> <span class="typename">int</span>:</div><div class="line">			fmt.Println(<span class="string">"it is an int:"</span>, i)</div><div class="line">		<span class="comment">// case D:</span></div><div class="line">		<span class="comment">// 	fmt.Println("it is D type:", i)</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="类型循环">类型循环</h3>
<p>类型别名在定义的时候不允许出现循环定义别名的情况，如下面所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 = T2</div><div class="line"><span class="keyword">type</span> T2 = T1</div></pre></td></tr></table></figure>

<p>上面的例子太明显，下面这个例子比较隐蔽，也是循环定义类型别名的情况，当然这些在编译代码的时候编译器会帮你检查，如果出现循环定义的情况会出错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 = <span class="keyword">struct</span> {</div><div class="line">	next *T2</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T2 = T1</div></pre></td></tr></table></figure>

<h3 id="可导出性">可导出性</h3>
<p>如果定义的类型别名是<code>exported</code> (首字母大写)的，那么别的包中就可以使用，它和原始类型是否可<code>exported</code>没关系。也就是说，你可以为<code>unexported</code>类型定义一个<code>exported</code>的类型别名，如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> t1 <span class="keyword">struct</span> {</div><div class="line">	S <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> T2 = t1</div></pre></td></tr></table></figure>

<h3 id="方法集">方法集</h3>
<p>既然类型别名和原始类型是相同的，那么它们的方法集也是相同的。</p>
<p>下面的例子中<code>T1</code>和<code>T3</code>都有<code>say</code>和<code>greeting</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> T3 = T1</div><div class="line"></div><div class="line"><span class="keyword">func</span> (t1 T1) say(){}</div><div class="line"><span class="keyword">func</span> (t3 *T3) greeting(){}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> t1 T1</div><div class="line">	<span class="comment">// var t2 T2</span></div><div class="line">	<span class="keyword">var</span> t3 T3</div><div class="line"></div><div class="line">	t1.say()</div><div class="line">	t1.greeting()</div><div class="line"></div><div class="line">	t3.say()</div><div class="line">	t3.greeting()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果类型别名和原始类型定义了相同的方法，代码编译的时候会报错，因为有重复的方法定义。</p>
<p>另一个有趣的现象是 <code>embedded type</code>, 比如下面的例子， <code>T3</code>是<code>T1</code>的别名。在定义结构体<code>S</code>的时候，我们使用了匿名嵌入类型，那么这个时候调用<code>s.say</code>会怎么样呢？ 实际是你会编译出错，因为<code>s.say｀不知道该调用</code>s.T1.say<code>还是</code>s.T3.say`，所以这个时候你需要明确的调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>{}</div><div class="line"><span class="keyword">type</span> T3 = T1</div><div class="line"><span class="keyword">func</span> (t T1) say(){}</div><div class="line"></div><div class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> {</div><div class="line">	T1</div><div class="line">	T3</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> s S</div><div class="line">	s.say()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>进一步想，这样是不是我们可以为其它库中的类型增加新的方法了， 比如为标准库的<code>time.Time</code>增加一个滴答方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NTime = time.Time</div><div class="line"><span class="keyword">func</span> (t NTime) Dida() {</div><div class="line">	fmt.Println(<span class="string">"嘀嗒嘀嗒嘀嗒嘀嗒搜索"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	t := time.Now()	</div><div class="line">	t.Dida()</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答案是: <strong>NO</strong>, 编译的时候会报错: <code>cannot define new methods on non-local type time.Time</code>。</p>
<h3 id="byte_和_rune_类型">byte 和 rune 类型</h3>
<p>在Go 1.9中， 内部其实使用了类型别名的特性。 比如内建的<code>byte</code>类型，其实是<code>uint8</code>的类型别名，而<code>rune</code>其实是<code>int32</code>的类型别名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></div><div class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></div><div class="line"><span class="comment">// integer values.</span></div><div class="line"><span class="keyword">type</span> <span class="typename">byte</span> = <span class="typename">uint8</span></div><div class="line"></div><div class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></div><div class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></div><div class="line"><span class="keyword">type</span> <span class="typename">rune</span> = <span class="typename">int32</span></div></pre></td></tr></table></figure>

<h3 id="参考资料">参考资料</h3>
<ol>
<li><a href="https://github.com/golang/proposal/blob/master/design/18130-type-alias.md" target="_blank" rel="external">https://github.com/golang/proposal/blob/master/design/18130-type-alias.md</a></li>
<li><a href="https://github.com/golang/go/issues/18130" target="_blank" rel="external">https://github.com/golang/go/issues/18130</a></li>
<li><a href="https://talks.golang.org/2016/refactor.article" target="_blank" rel="external">https://talks.golang.org/2016/refactor.article</a></li>
<li><a href="https://github.com/golang/go/issues/16339" target="_blank" rel="external">https://github.com/golang/go/issues/16339</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>如你所知， 类型别名(type aliases) 最终还是加入到Go 1.9中， Go 1.9 beta2今天已经发布了, 正式版预计8月初发布， 是时候深入了解一下它的新特性了，本文介绍的就是它的重要的新特性之一： 类型别名。 </p>
<p>当然，如果你想尝试这些新特性，需要安装Go 1.9的版本，目前是beta2版，可以在官方网站下载。<br>]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Golang 中使用 JSON 的小技巧]]></title>
    <link href="http://colobu.com/2017/06/21/json-tricks-in-Go/"/>
    <id>http://colobu.com/2017/06/21/json-tricks-in-Go/</id>
    <published>2017-06-21T09:59:14.000Z</published>
    <updated>2017-07-28T15:12:23.272Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/taowen" target="_blank" rel="external">taowen</a>是<a href="https://github.com/json-iterator/go" target="_blank" rel="external">json-iterator</a>的作者。 序列化和反序列化需要处理JSON和struct的关系，其中会用到一些技巧。 原文 <a href="http://jsoniter.com/go-tips.cn.html" target="_blank" rel="external">Golang 中使用 JSON 的小技巧</a>是他的经验之谈，介绍了一些struct解析成json的技巧，以及 json-iterator 库的一些便利的处理。</p>
<p>有的时候上游传过来的字段是string类型的，但是我们却想用变成数字来使用。 本来用一个json:&quot;,string&quot; 就可以支持了，如果不知道golang的这些小技巧，就要大费周章了。</p>
<p>参考文章：<a href="http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/" target="_blank" rel="external">http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/</a></p>
<a id="more"></a>
<h3 id="临时忽略struct空字段">临时忽略struct空字段</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果想临时忽略掉空<code>Password</code>字段,可以用<code>omitempty</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">json.Marshal(<span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Password <span class="typename">bool</span> <span class="string">`json:"password,omitempty"`</span></div><div class="line">}{</div><div class="line">    User: user,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="临时添加额外的字段">临时添加额外的字段</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>临时忽略掉空<code>Password</code>字段，并且添加<code>token</code>字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">json.Marshal(<span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Token    <span class="typename">string</span> <span class="string">`json:"token"`</span></div><div class="line">    Password <span class="typename">bool</span> <span class="string">`json:"password,omitempty"`</span></div><div class="line">}{</div><div class="line">    User: user,</div><div class="line">    Token: token,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="临时粘合两个struct">临时粘合两个struct</h3>
<p>通过嵌入struct的方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> BlogPost <span class="keyword">struct</span> {</div><div class="line">    URL   <span class="typename">string</span> <span class="string">`json:"url"`</span></div><div class="line">    Title <span class="typename">string</span> <span class="string">`json:"title"`</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> Analytics <span class="keyword">struct</span> {</div><div class="line">    Visitors  <span class="typename">int</span> <span class="string">`json:"visitors"`</span></div><div class="line">    PageViews <span class="typename">int</span> <span class="string">`json:"page_views"`</span></div><div class="line">}</div><div class="line"></div><div class="line">json.Marshal(<span class="keyword">struct</span>{</div><div class="line">    *BlogPost</div><div class="line">    *Analytics</div><div class="line">}{post, analytics})</div></pre></td></tr></table></figure>

<h3 id="一个json切分成两个struct">一个json切分成两个struct</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">json.Unmarshal([]<span class="typename">byte</span>(<span class="string">`{</span></div><div class="line">  "url": "attila@attilaolah.eu",</div><div class="line">  "title": "Attila's Blog",</div><div class="line">  "visitors": 6,</div><div class="line">  "page_views": 14</div><div class="line">}`), &<span class="keyword">struct</span> {</div><div class="line">  *BlogPost</div><div class="line">  *Analytics</div><div class="line">}{&post, &analytics})</div></pre></td></tr></table></figure>

<h3 id="临时改名struct的字段">临时改名struct的字段</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> CacheItem <span class="keyword">struct</span> {</div><div class="line">    Key    <span class="typename">string</span> <span class="string">`json:"key"`</span></div><div class="line">    MaxAge <span class="typename">int</span>    <span class="string">`json:"cacheAge"`</span></div><div class="line">    Value  Value  <span class="string">`json:"cacheValue"`</span></div><div class="line">}</div><div class="line"></div><div class="line">json.Marshal(<span class="keyword">struct</span>{</div><div class="line">    *CacheItem</div><div class="line"></div><div class="line">    <span class="comment">// Omit bad keys</span></div><div class="line">    OmitMaxAge omit <span class="string">`json:"cacheAge,omitempty"`</span></div><div class="line">    OmitValue  omit <span class="string">`json:"cacheValue,omitempty"`</span></div><div class="line"></div><div class="line">    <span class="comment">// Add nice keys</span></div><div class="line">    MaxAge <span class="typename">int</span>    <span class="string">`json:"max_age"`</span></div><div class="line">    Value  *Value <span class="string">`json:"value"`</span></div><div class="line">}{</div><div class="line">    CacheItem: item,</div><div class="line"></div><div class="line">    <span class="comment">// Set the int by value:</span></div><div class="line">    MaxAge: item.MaxAge,</div><div class="line"></div><div class="line">    <span class="comment">// Set the nested struct by reference, avoid making a copy:</span></div><div class="line">    Value: &item.Value,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="用字符串传递数字">用字符串传递数字</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    Field1 <span class="typename">int</span>    <span class="string">`json:",string"`</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个对应的json是 <code>{&quot;Field1&quot;: &quot;100&quot;}</code></p>
<p>如果json是 <code>{&quot;Field1&quot;: 100}</code> 则会报错</p>
<h3 id="容忍字符串和数字互转">容忍字符串和数字互转</h3>
<p>如果你使用的是jsoniter，可以启动<strong>模糊模式</strong>来支持 PHP 传递过来的 JSON。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.RegisterFuzzyDecoders()</div></pre></td></tr></table></figure>

<p>这样就可以处理字符串和数字类型不对的问题了。比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val <span class="typename">string</span></div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`100`</span>, &val)</div></pre></td></tr></table></figure>

<p>又比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val <span class="typename">float32</span></div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`"1.23"`</span>, &val)</div></pre></td></tr></table></figure>

<h3 id="容忍空数组作为对象">容忍空数组作为对象</h3>
<p>PHP另外一个令人崩溃的地方是，如果 PHP array是空的时候，序列化出来是<code>[]</code>。但是不为空的时候，序列化出来的是<code>{&quot;key&quot;:&quot;value&quot;}</code>。 我们需要把 <code>[]</code> 当成 <code>{}</code> 处理。</p>
<p>如果你使用的是jsoniter，可以启动模糊模式来支持 PHP 传递过来的 JSON。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.RegisterFuzzyDecoders()</div></pre></td></tr></table></figure>

<p>这样就可以支持了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val <span class="keyword">map</span>[<span class="typename">string</span>]<span class="keyword">interface</span>{}</div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`[]`</span>, &val)</div></pre></td></tr></table></figure>

<h3 id="使用_MarshalJSON支持time-Time">使用 MarshalJSON支持time.Time</h3>
<p>golang 默认会把 <code>time.Time</code> 用字符串方式序列化。如果我们想用其他方式表示 <code>time.Time</code>，需要自定义类型并定义 <code>MarshalJSON</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> timeImplementedMarshaler time.Time</div><div class="line"></div><div class="line"><span class="keyword">func</span> (obj timeImplementedMarshaler) MarshalJSON() ([]<span class="typename">byte</span>, error) {</div><div class="line">    seconds := time.Time(obj).Unix()</div><div class="line">    <span class="keyword">return</span> []<span class="typename">byte</span>(strconv.FormatInt(seconds,<span class="number"> 10</span>)), <span class="constant">nil</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>序列化的时候会调用 MarshalJSON</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    Field timeImplementedMarshaler</div><div class="line">}</div><div class="line">should := require.New(t)</div><div class="line">val := timeImplementedMarshaler(time.Unix<span class="number">(123</span>,<span class="number"> 0</span>))</div><div class="line">obj := TestObject{val}</div><div class="line">bytes, err := jsoniter.Marshal(obj)</div><div class="line">should.Nil(err)</div><div class="line">should.Equal(<span class="string">`{"Field":123}`</span>, <span class="typename">string</span>(bytes))</div></pre></td></tr></table></figure>

<h3 id="使用_RegisterTypeEncoder支持time-Time">使用 RegisterTypeEncoder支持time.Time</h3>
<p>jsoniter 能够对不是你定义的type自定义JSON编解码方式。比如对于 <code>time.Time</code> 可以用 epoch int64 来序列化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.RegisterTimeAsInt64Codec(time.Microsecond)</div><div class="line">output, err := jsoniter.Marshal(time.Unix<span class="number">(1</span>,<span class="number"> 1002</span>))</div><div class="line">should.Equal(<span class="string">"1000001"</span>, <span class="typename">string</span>(output))</div></pre></td></tr></table></figure>

<p>如果要自定义的话，参见 <code>RegisterTimeAsInt64Codec</code> 的实现代码</p>
<h3 id="使用_MarshalText支持非字符串作为key的map">使用 MarshalText支持非字符串作为key的map</h3>
<p>虽然 JSON 标准里只支持 <code>string</code> 作为 <code>key</code> 的 <code>map</code>。但是 golang 通过 <code>MarshalText()</code> 接口，使得其他类型也可以作为 <code>map</code> 的 <code>key</code>。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f, _, _ := big.ParseFloat(<span class="string">"1"</span>,<span class="number"> 10</span>,<span class="number"> 64</span>, big.ToZero)</div><div class="line">val := <span class="keyword">map</span>[*big.Float]<span class="typename">string</span>{f: <span class="string">"2"</span>}</div><div class="line">str, err := MarshalToString(val)</div><div class="line">should.Equal(<span class="string">`{"1":"2"}`</span>, str)</div></pre></td></tr></table></figure>

<p>其中 <code>big.Float</code> 就实现了 <code>MarshalText()</code></p>
<h3 id="使用_json-RawMessage">使用 json.RawMessage</h3>
<p>如果部分json文档没有标准格式，我们可以把原始的信息用<code>[]byte</code>保存下来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    Field1 <span class="typename">string</span></div><div class="line">    Field2 json.RawMessage</div><div class="line">}</div><div class="line"><span class="keyword">var</span> data TestObject</div><div class="line">json.Unmarshal([]<span class="typename">byte</span>(<span class="string">`{"field1": "hello", "field2": [1,2,3]}`</span>), &data)</div><div class="line">should.Equal(<span class="string">` [1,2,3]`</span>, <span class="typename">string</span>(data.Field2))</div></pre></td></tr></table></figure>

<h3 id="使用_json-Number">使用 json.Number</h3>
<p>默认情况下，如果是 <code>interface{}</code> 对应数字的情况会是 <code>float64</code> 类型的。如果输入的数字比较大，这个表示会有损精度。所以可以 <code>UseNumber()</code> 启用 <code>json.Number</code> 来用字符串表示数字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">decoder1 := json.NewDecoder(bytes.NewBufferString(<span class="string">`123`</span>))</div><div class="line">decoder1.UseNumber()</div><div class="line"><span class="keyword">var</span> obj1 <span class="keyword">interface</span>{}</div><div class="line">decoder1.Decode(&obj1)</div><div class="line">should.Equal(json.Number(<span class="string">"123"</span>), obj1)</div></pre></td></tr></table></figure>

<p>jsoniter 支持标准库的这个用法。同时，扩展了行为使得 <code>Unmarshal</code> 也可以支持 <code>UseNumber</code> 了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">json := Config{UseNumber:<span class="constant">true</span>}.Froze()</div><div class="line"><span class="keyword">var</span> obj <span class="keyword">interface</span>{}</div><div class="line">json.UnmarshalFromString(<span class="string">"123"</span>, &obj)</div><div class="line">should.Equal(json.Number(<span class="string">"123"</span>), obj)</div></pre></td></tr></table></figure>

<h3 id="统一更改字段的命名风格">统一更改字段的命名风格</h3>
<p>经常 JSON 里的字段名 Go 里的字段名是不一样的。我们可以用 field tag 来修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">output, err := jsoniter.Marshal(<span class="keyword">struct</span> {</div><div class="line">    UserName      <span class="typename">string</span> <span class="string">`json:"user_name"`</span></div><div class="line">    FirstLanguage <span class="typename">string</span> <span class="string">`json:"first_language"`</span></div><div class="line">}{</div><div class="line">    UserName:      <span class="string">"taowen"</span>,</div><div class="line">    FirstLanguage: <span class="string">"Chinese"</span>,</div><div class="line">})</div><div class="line">should.Equal(<span class="string">`{"user_name":"taowen","first_language":"Chinese"}`</span>, <span class="typename">string</span>(output))</div></pre></td></tr></table></figure>

<p>但是一个个字段来设置，太麻烦了。如果使用 jsoniter，我们可以统一设置命名风格。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.SetNamingStrategy(LowerCaseWithUnderscores)</div><div class="line">output, err := jsoniter.Marshal(<span class="keyword">struct</span> {</div><div class="line">    UserName      <span class="typename">string</span></div><div class="line">    FirstLanguage <span class="typename">string</span></div><div class="line">}{</div><div class="line">    UserName:      <span class="string">"taowen"</span>,</div><div class="line">    FirstLanguage: <span class="string">"Chinese"</span>,</div><div class="line">})</div><div class="line">should.Nil(err)</div><div class="line">should.Equal(<span class="string">`{"user_name":"taowen","first_language":"Chinese"}`</span>, <span class="typename">string</span>(output))</div></pre></td></tr></table></figure>

<h3 id="使用私有的字段">使用私有的字段</h3>
<p>Go 的标准库只支持 public 的 field。jsoniter 额外支持了 private 的 field。需要使用 <code>SupportPrivateFields()</code> 来开启开关。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/json-iterator/go/extra"</span></div><div class="line"></div><div class="line">extra.SupportPrivateFields()</div><div class="line"><span class="keyword">type</span> TestObject <span class="keyword">struct</span> {</div><div class="line">    field1 <span class="typename">string</span></div><div class="line">}</div><div class="line">obj := TestObject{}</div><div class="line">jsoniter.UnmarshalFromString(<span class="string">`{"field1":"Hello"}`</span>, &obj)</div><div class="line">should.Equal(<span class="string">"Hello"</span>, obj.field1)</div></pre></td></tr></table></figure>

<p>下面是我补充的内容</p>
<h3 id="忽略掉一些字段">忽略掉一些字段</h3>
<p>原文中第一节有个错误，我更正过来了。<code>omitempty</code>不会忽略某个字段，而是忽略空的字段，当字段的值为空值的时候，它不会出现在JSON数据中。</p>
<p>如果想忽略某个字段，需要使用 <code>json:&quot;-&quot;</code>格式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果想临时忽略掉空<code>Password</code>字段,可以用<code>-</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">json.Marshal(<span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Password <span class="typename">bool</span> <span class="string">`json:"-"`</span></div><div class="line">}{</div><div class="line">    User: user,</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="忽略掉一些字段2">忽略掉一些字段2</h3>
<p>如果不想更改原struct,还可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</div><div class="line">    Email    <span class="typename">string</span> <span class="string">`json:"email"`</span></div><div class="line">    Password <span class="typename">string</span> <span class="string">`json:"password"`</span></div><div class="line">    <span class="comment">// many more fields…</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">type</span> omit *<span class="keyword">struct</span>{}</div><div class="line"></div><div class="line"><span class="keyword">type</span> PublicUser <span class="keyword">struct</span> {</div><div class="line">    *User</div><div class="line">    Password omit <span class="string">`json:"-"`</span></div><div class="line">}</div><div class="line"></div><div class="line">json.Marshal(PublicUser{</div><div class="line">    User: user,</div><div class="line">})</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/taowen" target="_blank" rel="external">taowen</a>是<a href="https://github.com/json-iterator/go" target="_blank" rel="external">json-iterator</a>的作者。 序列化和反序列化需要处理JSON和struct的关系，其中会用到一些技巧。 原文 <a href="http://jsoniter.com/go-tips.cn.html" target="_blank" rel="external">Golang 中使用 JSON 的小技巧</a>是他的经验之谈，介绍了一些struct解析成json的技巧，以及 json-iterator 库的一些便利的处理。</p>
<p>有的时候上游传过来的字段是string类型的，但是我们却想用变成数字来使用。 本来用一个json:&quot;,string&quot; 就可以支持了，如果不知道golang的这些小技巧，就要大费周章了。</p>
<p>参考文章：<a href="http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/" target="_blank" rel="external">http://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/</a></p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 1.9 的新特性]]></title>
    <link href="http://colobu.com/2017/06/20/what-s-new-in-Go-1-9/"/>
    <id>http://colobu.com/2017/06/20/what-s-new-in-Go-1-9/</id>
    <published>2017-06-20T05:17:18.000Z</published>
    <updated>2017-07-28T15:12:23.284Z</updated>
    <content type="html"><![CDATA[<p>现在 Go 1.9 beta版已发布， 正式版预期在8月初发布，让我们先来看看你Go 1.9带来了那些新特性。</p>
<a id="more"></a>
<h3 id="type_alias">type alias</h3>
<p>类型别名原本在1.8中加入的，但是临时发现有些问题，为了能全面的设计 <code>type alias</code> 被移到了 Go 1.9中了。</p>
<p>这个特性主要用在类型从一个package移动到另外一个package中的时候，导致的项目中对引入的路径不一致导致的问题， 比如原先 <code>context</code>是在<code>golang.org／x/net/context</code>包下，在Go 1.7中菜正式移到标准库<code>context</code>。</p>
<p>相关的issue: <a href="https://github.com/golang/go/issues/16339" target="_blank" rel="external">go#16339</a> <a href="https://github.com/golang/go/issues/18130" target="_blank" rel="external">go#18130</a><br>提案: <a href="https://github.com/golang/proposal/blob/master/design/18130-type-alias.md" target="_blank" rel="external">type alias</a></p>
<h3 id="并发map">并发map</h3>
<p>在Go 1.6之前， 内置的<code>map</code>类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。</p>
<p>群众的呼声是响亮的，并发map在项目中大量使用，所以Go 1.9中在包<code>sync</code>加入了新的map， 查询、存储和删除都是平均常数时间，可以并发访问。</p>
<h3 id="Monotonic_Time">Monotonic Time</h3>
<p>先前的<code>time</code>包的实现都是基于<code>wall time</code>的，但是当机器的时钟调整后会有问题。 比如在计算duration的时候，如果时钟往回拨，可能导致end时间比start时间还早。</p>
<p>所以Go 1.9使用<code>monotonic Time</code>来实现大部分的<code>time</code>中的函数，在计算duration的时候不会出现因为时钟调整出现的误差了。</p>
<p>设计文档: <a href="https://github.com/golang/proposal/blob/master/design/12914-monotonic.md" target="_blank" rel="external">monotonic time</a></p>
<h3 id="位处理操作">位处理操作</h3>
<p>新增加了<code>math/bits</code>包， 提供了很多位运算的函数。</p>
<h3 id="Test_Helper函数">Test Helper函数</h3>
<p>新加｀(<em>T).Helper<code>和</code>(</em>B).Helper m｀， 用来标记调用的函数是一个测试辅助函数，当输出文件名和行数的时候，这个函数回呗忽略。</p>
<h3 id="标准库的微小改动">标准库的微小改动</h3>
<p>标准库也有一些小的功能的加入和提升， 比如<code>image</code>、<code>net</code>、<code>runtime</code>、<code>sync</code>等。</p>
<h3 id="并行编译">并行编译</h3>
<p>支持并行地编译函数，并且在Go 1.9中势默认设置。如果不想并行编译，设置GO19CONCURRENTCOMPILATION为0。</p>
<h3 id="-/-_会忽略vendor下的包">./... 会忽略vendor下的包</h3>
<p>这一条很有用，以后你在Makefile中可以直接使用<code>./...</code>,而不是曲折地将vendor文件夹排除。</p>
<p>如果你想使用vendor下的包， 可以使用<code>./vendor/...</code>通配符。</p>
<h3 id="性能提升">性能提升</h3>
<p>性能提升多少势很难精确描述的，对于大部分的程序，应该运行更快一点。</p>
<p>主要在于垃圾回收器的优化、更好的生成的代码以及核心库的优化。</p>
<p>完整的信息可以参考 <a href="https://golang.org/doc/go1.9" target="_blank" rel="external">Tip Go 1.9 Release Notes</a>, Go 1.9发布后可以访问<a href="https://golang.org/doc/go1.9" target="_blank" rel="external">Go 1.9 Release Notes</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在 Go 1.9 beta版已发布， 正式版预期在8月初发布，让我们先来看看你Go 1.9带来了那些新特性。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]使用os/exec执行命令]]></title>
    <link href="http://colobu.com/2017/06/19/advanced-command-execution-in-Go-with-os-exec/"/>
    <id>http://colobu.com/2017/06/19/advanced-command-execution-in-Go-with-os-exec/</id>
    <published>2017-06-19T07:28:52.000Z</published>
    <updated>2017-07-28T15:12:23.261Z</updated>
    <content type="html"><![CDATA[<p>原文: <a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="external">Advanced command execution in Go with os/exec</a> by Krzysztof Kowalczyk.<br>完整代码在作者的github上： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec" target="_blank" rel="external">advanced-exec</a></p>
<p>Go可以非常方便地执行外部程序，让我们开始探索之旅吧。</p>
<a id="more"></a>
<h3 id="执行命令并获得输出结果">执行命令并获得输出结果</h3>
<p>最简单的例子就是运行<code>ls -lah</code>并获得组合在一起的stdout/stderr输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	out, err := cmd.CombinedOutput()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	fmt.Printf(<span class="string">"combined out:\n%s\n"</span>, <span class="typename">string</span>(out))</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="将stdout和stderr分别处理">将stdout和stderr分别处理</h3>
<p>和上面的例子类似，只不过将stdout和stderr分别处理。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func main() {</div><div class="line">	cmd := exec.<span class="type">Command</span>(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	<span class="keyword">var</span> <span class="literal">stdout</span>, <span class="literal">stderr</span> bytes.<span class="type">Buffer</span></div><div class="line">	cmd.<span class="type">Stdout</span> = &<span class="literal">stdout</span></div><div class="line">	cmd.<span class="type">Stderr</span> = &<span class="literal">stderr</span></div><div class="line">	err := cmd.<span class="type">Run</span>()</div><div class="line">	<span class="keyword">if</span> err != <span class="keyword">nil</span> {</div><div class="line">		log.<span class="type">Fatalf</span>(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="type">string</span>(<span class="literal">stdout</span>.<span class="type">Bytes</span>()), <span class="type">string</span>(<span class="literal">stderr</span>.<span class="type">Bytes</span>())</div><div class="line">	fmt.<span class="type">Printf</span>(<span class="string">"out:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="命令执行过程中获得输出">命令执行过程中获得输出</h3>
<p>如果一个命令需要花费很长时间才能执行完呢？</p>
<p>除了能获得它的stdout/stderr，我们还希望在控制台显示命令执行的进度。</p>
<p>有点小复杂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> copyAndCapture(w io.Writer, r io.Reader) ([]<span class="typename">byte</span>, error) {</div><div class="line">	<span class="keyword">var</span> out []<span class="typename">byte</span></div><div class="line">	buf := <span class="built_in">make</span>([]<span class="typename">byte</span>,<span class="number"> 1024</span>,<span class="number"> 1024</span>)</div><div class="line">	<span class="keyword">for</span> {</div><div class="line">		n, err := r.Read(buf[:])</div><div class="line">		<span class="keyword">if</span> n &gt;<span class="number"> 0</span> {</div><div class="line">			d := buf[:n]</div><div class="line">			out = <span class="built_in">append</span>(out, d...)</div><div class="line">			os.Stdout.Write(d)</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">			<span class="comment">// Read returns io.EOF at the end of file, which is not an error for us</span></div><div class="line">			<span class="keyword">if</span> err == io.EOF {</div><div class="line">				err = <span class="constant">nil</span></div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> out, err</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">// never reached</span></div><div class="line">	<span class="built_in">panic</span>(<span class="constant">true</span>)</div><div class="line">	<span class="keyword">return</span> <span class="constant">nil</span>, <span class="constant">nil</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	<span class="keyword">var</span> stdout, stderr []<span class="typename">byte</span></div><div class="line">	<span class="keyword">var</span> errStdout, errStderr error</div><div class="line">	stdoutIn, _ := cmd.StdoutPipe()</div><div class="line">	stderrIn, _ := cmd.StderrPipe()</div><div class="line">	cmd.Start()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		stdout, errStdout = copyAndCapture(os.Stdout, stdoutIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		stderr, errStderr = copyAndCapture(os.Stderr, stderrIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	err := cmd.Wait()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> errStdout != <span class="constant">nil</span> || errStderr != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to capture stdout or stderr\n"</span>)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="typename">string</span>(stdout), <span class="typename">string</span>(stderr)</div><div class="line">	fmt.Printf(<span class="string">"\nout:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="命令执行过程中获得输出2">命令执行过程中获得输出2</h3>
<p>上一个方案虽然工作，但是看起来<code>copyAndCapture</code>好像重新实现了<code>io.Copy</code>。由于Go的接口的功能，我们可以重用<code>io.Copy</code>。</p>
<p>我们写一个<code>CapturingPassThroughWriter</code>struct，它实现了<code>io.Writer</code>接口。它会捕获所有的数据并写入到底层的<code>io.Writer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CapturingPassThroughWriter is a writer that remembers</span></div><div class="line"><span class="comment">// data written to it and passes it to w</span></div><div class="line"><span class="keyword">type</span> CapturingPassThroughWriter <span class="keyword">struct</span> {</div><div class="line">	buf bytes.Buffer</div><div class="line">	w io.Writer</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// NewCapturingPassThroughWriter creates new CapturingPassThroughWriter</span></div><div class="line"><span class="keyword">func</span> NewCapturingPassThroughWriter(w io.Writer) *CapturingPassThroughWriter {</div><div class="line">	<span class="keyword">return</span> &CapturingPassThroughWriter{</div><div class="line">		w: w,</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (w *CapturingPassThroughWriter) Write(d []<span class="typename">byte</span>) (<span class="typename">int</span>, error) {</div><div class="line">	w.buf.Write(d)</div><div class="line">	<span class="keyword">return</span> w.w.Write(d)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Bytes returns bytes written to the writer</span></div><div class="line"><span class="keyword">func</span> (w *CapturingPassThroughWriter) Bytes() []<span class="typename">byte</span> {</div><div class="line">	<span class="keyword">return</span> w.buf.Bytes()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> errStdout, errStderr error</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line">	stdoutIn, _ := cmd.StdoutPipe()</div><div class="line">	stderrIn, _ := cmd.StderrPipe()</div><div class="line">	stdout := NewCapturingPassThroughWriter(os.Stdout)</div><div class="line">	stderr := NewCapturingPassThroughWriter(os.Stderr)</div><div class="line">	err := cmd.Start()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Start() failed with '%s'\n"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStdout = io.Copy(stdout, stdoutIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStderr = io.Copy(stderr, stderrIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	err = cmd.Wait()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> errStdout != <span class="constant">nil</span> || errStderr != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"failed to capture stdout or stderr\n"</span>)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="typename">string</span>(stdout.Bytes()), <span class="typename">string</span>(stderr.Bytes())</div><div class="line">	fmt.Printf(<span class="string">"\nout:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="命令执行过程中获得输出3">命令执行过程中获得输出3</h3>
<p>事实上Go标准库包含一个更通用的<code>io.MultiWriter</code>,我们可以直接使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	<span class="keyword">var</span> stdoutBuf, stderrBuf bytes.Buffer</div><div class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-lah"</span>)</div><div class="line"></div><div class="line">	stdoutIn, _ := cmd.StdoutPipe()</div><div class="line">	stderrIn, _ := cmd.StderrPipe()</div><div class="line"></div><div class="line">	<span class="keyword">var</span> errStdout, errStderr error</div><div class="line">	stdout := io.MultiWriter(os.Stdout, &stdoutBuf)</div><div class="line">	stderr := io.MultiWriter(os.Stderr, &stderrBuf)</div><div class="line">	err := cmd.Start()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Start() failed with '%s'\n"</span>, err)</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStdout = io.Copy(stdout, stdoutIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="keyword">func</span>() {</div><div class="line">		_, errStderr = io.Copy(stderr, stderrIn)</div><div class="line">	}()</div><div class="line"></div><div class="line">	err = cmd.Wait()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">	}</div><div class="line">	<span class="keyword">if</span> errStdout != <span class="constant">nil</span> || errStderr != <span class="constant">nil</span> {</div><div class="line">		log.Fatal(<span class="string">"failed to capture stdout or stderr\n"</span>)</div><div class="line">	}</div><div class="line">	outStr, errStr := <span class="typename">string</span>(stdoutBuf.Bytes()), <span class="typename">string</span>(stderrBuf.Bytes())</div><div class="line">	fmt.Printf(<span class="string">"\nout:\n%s\nerr:\n%s\n"</span>, outStr, errStr)</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>自己实现是很好滴，但是熟悉标准库并使用它更好。</p>
<h3 id="改变执行程序的环境(environment)">改变执行程序的环境(environment)</h3>
<p>你已经知道了怎么在程序中获得环境变量，对吧： ｀os.Environ()｀返回所有的环境变量<code>[]string</code>,每个字符串以<code>FOO=bar</code>格式存在。<code>FOO</code>是环境变量的名称，<code>bar</code>是环境变量的值， 也就是<code>os.Getenv(&quot;FOO&quot;)</code>的返回值。</p>
<p>有时候你可能想修改执行程序的环境。</p>
<p>你可设置<code>exec.Cmd</code>的<code>Env</code>的值，和<code>os.Environ()</code>格式相同。通常你不会构造一个全新的环境，而是添加自己需要的环境变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   cmd := exec.Command(<span class="string">"programToExecute"</span>)</div><div class="line">additionalEnv := <span class="string">"FOO=bar"</span></div><div class="line">newEnv := <span class="built_in">append</span>(os.Environ(), additionalEnv))</div><div class="line">cmd.Env = newEnv</div><div class="line">out, err := cmd.CombinedOutput()</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">	log.Fatalf(<span class="string">"cmd.Run() failed with %s\n"</span>, err)</div><div class="line">}</div><div class="line">fmt.Printf(<span class="string">"%s"</span>, out)</div></pre></td></tr></table></figure>

<p>包 <a href="https://godoc.org/github.com/shurcooL/go/osutil#Environ" target="_blank" rel="external">shurcooL/go/osutil</a>提供了便利的方法设置环境变量。</p>
<h3 id="预先检查程序是否存在">预先检查程序是否存在</h3>
<p>想象一下你写了一个程序需要花费很长时间执行，再最后你调用<code>foo</code>做一些基本的任务。</p>
<p>如果<code>foo</code>程序不存在，程序会执行失败。</p>
<p>当然如果我们预先能检查程序是否存在就完美了，如果不存在就打印错误信息。</p>
<p>你可以调用<code>exec.LookPath</code>方法来检查：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> checkLsExists() {</div><div class="line">	path, err := exec.LookPath(<span class="string">"ls"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"didn't find 'ls' executable\n"</span>)</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		fmt.Printf(<span class="string">"'ls' executable is in '%s'\n"</span>, path)</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>另一个检查的办法就是让程序执行一个空操作， 比如传递参数&quot;--help&quot;显示帮助信息。</p>
<p>下面的章节是<a href="http://colobu.com" target="_blank" rel="external">译者</a>补充的内容</p>
<h3 id="管道">管道</h3>
<p>我们可以使用管道将多个命令串联起来， 上一个命令的输出是下一个命令的输入。</p>
<p>使用<code>os.Exec</code>有点麻烦，你可以使用下面的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"bytes"</span></div><div class="line">    <span class="string">"io"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    c1 := exec.Command(<span class="string">"ls"</span>)</div><div class="line">    c2 := exec.Command(<span class="string">"wc"</span>, <span class="string">"-l"</span>)</div><div class="line"></div><div class="line">    r, w := io.Pipe() </div><div class="line">    c1.Stdout = w</div><div class="line">    c2.Stdin = r</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b2 bytes.Buffer</div><div class="line">    c2.Stdout = &b2</div><div class="line"></div><div class="line">    c1.Start()</div><div class="line">    c2.Start()</div><div class="line">    c1.Wait()</div><div class="line">    w.Close()</div><div class="line">    c2.Wait()</div><div class="line">    io.Copy(os.Stdout, &b2)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者直接使用<code>Cmd</code>的<code>StdoutPipe</code>方法，而不是自己创建一个io.Pipe`。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">    c1 := exec.Command(<span class="string">"ls"</span>)</div><div class="line">    c2 := exec.Command(<span class="string">"wc"</span>, <span class="string">"-l"</span>)</div><div class="line">    c2.Stdin, _ = c1.StdoutPipe()</div><div class="line">    c2.Stdout = os.Stdout</div><div class="line">    _ = c2.Start()</div><div class="line">    _ = c1.Run()</div><div class="line">    _ = c2.Wait()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="管道2">管道2</h3>
<p>上面的解决方案是Go风格的解决方案，事实上你还可以用一个&quot;Trick&quot;来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os/exec"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	cmd := <span class="string">"cat /proc/cpuinfo | egrep '^model name' | uniq | awk '{print substr($0, index($0,$4))}'"</span></div><div class="line">	out, err := exec.Command(<span class="string">"bash"</span>, <span class="string">"-c"</span>, cmd).Output()</div><div class="line">	<span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">		fmt.Printf(<span class="string">"Failed to execute command: %s"</span>, cmd)</div><div class="line">	}</div><div class="line"></div><div class="line">	fmt.Println(<span class="typename">string</span>(out))</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>原文: <a href="https://blog.kowalczyk.info/article/wOYk/advanced-command-execution-in-go-with-osexec.html" target="_blank" rel="external">Advanced command execution in Go with os/exec</a> by Krzysztof Kowalczyk.<br>完整代码在作者的github上： <a href="https://github.com/kjk/go-cookbook/blob/master/advanced-exec" target="_blank" rel="external">advanced-exec</a></p>
<p>Go可以非常方便地执行外部程序，让我们开始探索之旅吧。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[突破限制,访问其它Go package中的私有函数]]></title>
    <link href="http://colobu.com/2017/05/12/call-private-functions-in-other-packages/"/>
    <id>http://colobu.com/2017/05/12/call-private-functions-in-other-packages/</id>
    <published>2017-05-12T07:09:50.000Z</published>
    <updated>2017-07-28T15:12:23.267Z</updated>
    <content type="html"><![CDATA[<p>熟悉C++、Java、C#等面向对象的编程语言的同学，在学习Go语言的过程中，经常会被访问权限所困扰，逐渐才能了解这样一个事实：</p>
<p><strong> Go语言通过<code>identifier</code>的首字母是否大写来决定它是否可以被其它package所访问。</strong></p>
<p>正式的Go语言规范是这么规定的：</p>
<blockquote>
<p>An identifier may be exported to permit access to it from another package. An identifier is exported if both:</p>
<p>the first character of the identifier&#39;s name is a Unicode upper case letter (Unicode class &quot;Lu&quot;); and<br>the identifier is declared in the package block or it is a field name or method name.</p>
<p>All other identifiers are not exported.</p>
</blockquote>
<p>这个Go语言规范定义的访问权限控制方法。</p>
<a id="more"></a>
<p>但是有没有办法突破这个限制呢？</p>
<p>突破可以从两个方向来讨论： 将<code>exported</code>类型变为其它package不可访问；将<code>unexported</code>的类型变为其它package可访问。</p>
<h3 id="将exported类型变为其它package不可访问">将<code>exported</code>类型变为其它package不可访问</h3>
<p>至少有一个办法可以将package中 exported的函数、类型变为其它package不可访问， 那就是定义一个<code>internal</code> package,将这些package放在<code>internal</code> package之下。</p>
<p>Go语言本身没有这个限制，这是通过<code>go</code>命令实现的。最早这个特性是在 <a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="external">go 1.4</a>版本中引入的，相关的细节可以查看文档： <a href="https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit" target="_blank" rel="external">design document</a></p>
<p>这个规则是这样的：</p>
<blockquote>
<p>An import of a path containing the element “internal” is disallowed if the importing code is outside the tree rooted at the parent of the “internal” directory.</p>
</blockquote>
<p>也就是<code>internal</code>包下的 exported 类型只能由internal所在的package (internal的parent)为root的package所访问。</p>
<p>举例来说：</p>
<ul>
<li><code>/a/b/c/internal/d/e/f</code> 可以被<code>/a/b/c</code> import， 不能被 <code>/a/b/g</code> import.</li>
<li><code>$GOROOT/src/pkg/internal/xxx</code>只可以被标准库import ($GOROOT/src/).</li>
<li><code>$GOROOT/src/pkg/net/http/internal</code> 只可以被 <code>net/http</code> 和 <code>net/http/*</code> import.</li>
<li><code>$GOPATH/src/mypkg/internal/foo</code> 只能被<code>$GOPATH/src/mypkg</code> import.</li>
</ul>
<h3 id="访问其它package中的私有方法">访问其它package中的私有方法</h3>
<p>如果你查看 Go 标准库的的代码， 比如 <a href="https://github.com/golang/go/blob/master/src/time/sleep.go" target="_blank" rel="external">time/sleep.go</a> 文件， 你会发现一些奇怪的函数， 如 <code>Sleep</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> Sleep(d Duration)</div></pre></td></tr></table></figure>

<p>这个函数我们经常会用到， 也就是<code>time.Sleep</code>函数，但是这个函数并没有函数体，而且同样的目录下也没有汇编语言的代码实现，那么，这个函数在哪里定义的？</p>
<p>依照<a href="https://golang.org/ref/spec#Function_declarations" target="_blank" rel="external">规范</a>，一个只有函数声明的函数是在Go的外部实现的，我们称之为<code>external function</code>。</p>
<p>实际上，这个&quot;外部函数&quot;也是在Go标准库中实现的，它是 runtime中的一个 unexported的函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:linkname timeSleep time.Sleep</span></div><div class="line"><span class="keyword">func</span> timeSleep(ns <span class="typename">int64</span>) {</div><div class="line">	<span class="keyword">if</span> ns &lt;=<span class="number"> 0</span> {</div><div class="line">		<span class="keyword">return</span></div><div class="line">	}</div><div class="line"></div><div class="line">	t := getg().timer</div><div class="line">	<span class="keyword">if</span> t == <span class="constant">nil</span> {</div><div class="line">		t = <span class="built_in">new</span>(timer)</div><div class="line">		getg().timer = t</div><div class="line">	}</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>事实上，runtime为其它 package中定义了很多的函数，比如<code>sync</code>、<code>net</code>中的一些函数，你可以通过命令<code>grep linkname /usr/local/go/src/runtime/*.go</code>查找这些函数。</p>
<p>我们会有两个疑问：一是为什么这些函数要定义在 runtime package中，而是这个机制到底是怎么实现的？</p>
<p>将相关的函数定义在<code>runtime</code>中的好处是， 它们可以访问 runtime package中 unexported的类型， 比如<code>getp</code>函数等，相当于往 runtime package打入一个&quot;叛徒&quot;,通过&quot;叛徒&quot;可以访问 runtime package 的私有对象。同时，这些&quot;叛徒&quot;函数尽管被声明为unexported,还是可以在其它package中访问。</p>
<p>第二个问题，其实是Go的<code>go:linkname</code>这个指令发挥的作用,它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go:linkname localname importpath.name</span></div></pre></td></tr></table></figure>

<p><a href="https://golang.org/cmd/compile/" target="_blank" rel="external">Go文档</a>说明了这个指令的作用：</p>
<blockquote>
<p>The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported &quot;unsafe&quot;.</p>
</blockquote>
<p>这个指令告诉编译器为函数或者变量<code>localname</code>使用<code>importpath.name</code>作为目标文件的符号名。因为这个指令破坏了类型系统和包的模块化，所以它只能在 import &quot;unsafe&quot; 的情况下才能使用。</p>
<p><code>importpath.name</code>可以是这种格式:<code>a/b/c/d/apkg.foo</code>，这样在package <code>a/b/c/d/apkg</code>中就可以使用这个函数<code>foo</code>了。</p>
<p>举个例子,假设我们的package布局如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├── <span class="keyword">a</span></div><div class="line">│   └── <span class="keyword">a</span>.<span class="keyword">go</span></div><div class="line">├── <span class="keyword">b</span></div><div class="line">│   ├── <span class="keyword">b</span>.<span class="keyword">go</span></div><div class="line">│   └── internal.<span class="keyword">s</span></div><div class="line">└── main</div><div class="line">    └── main.<span class="keyword">go</span></div></pre></td></tr></table></figure>

<p>package <strong>a</strong> 定义了私有的方法,并加上 <code>go:linkname</code>指令， package <strong>b</strong> 可以调用 package <strong>a</strong>的私有方法。 <strong>main.go</strong> 测试访问 <strong>b</strong>中的函数。</p>
<p>首先看看<code>a.go</code>中的实现：</p>
<figure class="highlight go"><figcaption><span>a.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> a</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"unsafe"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//go:linkname say a.say</span></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> say(name <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> <span class="string">"hello, "</span> + name</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//go:linkname say2 github.com/smallnest/private/b.Hi</span></div><div class="line"><span class="comment">//go:nosplit</span></div><div class="line"><span class="keyword">func</span> say2(name <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> <span class="string">"hi, "</span> + name</div><div class="line">}</div></pre></td></tr></table></figure>

<p>它定义了两个方法，符号名分别为<code>a.say</code>和<code>github.com/smallnest/private/b.Hi</code>。</p>
<p>这个不同的符号名的方式会影响<strong>b</strong>中的使用。</p>
<figure class="highlight go"><figcaption><span>b.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> b</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	_ <span class="string">"unsafe"</span></div><div class="line"></div><div class="line">	_ <span class="string">"github.com/smallnest/private/a"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//go:linkname say a.say</span></div><div class="line"><span class="keyword">func</span> say(name <span class="typename">string</span>) <span class="typename">string</span></div><div class="line"></div><div class="line"><span class="keyword">func</span> Greet(name <span class="typename">string</span>) <span class="typename">string</span> {</div><div class="line">	<span class="keyword">return</span> say(name)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> Hi(name <span class="typename">string</span>) <span class="typename">string</span></div></pre></td></tr></table></figure>

<p>在<strong>b</strong> 中，如果想使用符号<code>a.say</code>，你还是需要<code>go:linkname</code>,告诉编译器这个函数的符号为<code>a.say</code>。对于<code>Hi</code>函数， 我们不需要<code>go:linkname</code>指令，因为在<code>a.go</code>中我们定义的符号名称<strong>恰巧</strong>就是这个<code>package.funcname</code>。</p>
<p>注意，你需要引入package <code>unsafe</code>,并且在<strong>b.go</strong>还需要import package a.</p>
<p>你可以在<code>main.go</code>中调用<strong>b</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/smallnest/private/b"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> main() {</div><div class="line">	s := b.Greet(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(s)</div><div class="line">	s = b.Hi(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，如果你<code>go  run main.go</code>,你不会得到正确的结果，而是会出错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">main <span class="keyword">go</span> run main.<span class="keyword">go</span></div><div class="line"># github.com/smallnest/private/b</div><div class="line">../b/b.<span class="keyword">go</span><span class="number">:10</span>: missing function body <span class="keyword">for</span> <span class="string">"say"</span></div><div class="line">../b/b.<span class="keyword">go</span><span class="number">:16</span>: missing function body <span class="keyword">for</span> <span class="string">"Hi"</span></div></pre></td></tr></table></figure>

<p>难道我们前面讲的都是错的吗？</p>
<p>这里有一个技巧，你在 package b下创建一个空的文件， w文件名随意，只要文件后缀为<code>.s</code>，再运行一下<code>go  run main.go</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">main go run main.go</div><div class="line">hello, world</div><div class="line">hi, world</div></pre></td></tr></table></figure>

<p>原因在于Go在编译的时候会启用<code>-complete</code>编译器flag,它要求所有的函数必需包含函数体。创建一个空的汇编语言文件绕过这个限制。</p>
<p>当然， 一般情况下我们不会用到本文所列出的两种突破方式，只有在很稀少的情况下，为了更好地组织我们的代码，我们才会有选择的采用这两种方法。至少，作为一个Go开发者，你会记住有两种突破方法，可以打破Go语言规范中关于权限的限制。</p>
<h3 id="访问其它package中的struct_私有字段">访问其它package中的struct 私有字段</h3>
<p>再额外附送一个技巧， 可以访问其它package struct的私有字段。</p>
<p>当然正常情况下struct的私有字段并没有export，所以在其它package是不能正常访问。通过使用<code>refect</code>,可以访问struct的私有字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"reflect"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/private/c"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> ChangeFoo(f *c.Foo) {</div><div class="line">	v := reflect.ValueOf(f)</div><div class="line">	x := v.Elem().FieldByName(<span class="string">"x"</span>)</div><div class="line">	fmt.Println(x.Int())</div><div class="line">	<span class="comment">//panic: reflect: reflect.Value.SetInt using value obtained using unexported field</span></div><div class="line">	<span class="comment">//x.SetInt(100)</span></div><div class="line">	fmt.Println(x.Int())</div><div class="line"></div><div class="line">	y := v.Elem().FieldByName(<span class="string">"Y"</span>)</div><div class="line">	y.SetString(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(f.Y)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是你不能设置私有字段的值，否则会panic,这是因为<code>SetXXX</code>会首先使用<code>v.mustBeAssignable()</code>检查字段是否是exported的。</p>
<p>当然，还可以通过&quot;指针&quot;的方式获取字段的地址，通过地址获取数据或者设置数据。<br>还是用相同的例子：</p>
<figure class="highlight go"><figcaption><span>c.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> c</div><div class="line"></div><div class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> {</div><div class="line">	x <span class="typename">int</span></div><div class="line">	Y <span class="typename">string</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> (f Foo) X() <span class="typename">int</span> {</div><div class="line">	<span class="keyword">return</span> f.x</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> New(x <span class="typename">int</span>, y <span class="typename">string</span>) *Foo {</div><div class="line">	<span class="keyword">return</span> &Foo{x: x, Y: y}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在package d中访问：</p>
<figure class="highlight go"><figcaption><span>d.go</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> d</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"unsafe"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/smallnest/private/c"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">func</span> ChangeFoo(f *c.Foo) {</div><div class="line">	p := unsafe.Pointer(f)</div><div class="line">	<span class="comment">// 事先获取或者通过 reflect获得</span></div><div class="line">	<span class="comment">// 本例中是第一个字段，所以offset=0</span></div><div class="line">	offset := <span class="typename">uintptr</span><span class="number">(0</span>)</div><div class="line">	ptr2x := (*<span class="typename">int</span>)(unsafe.Pointer(<span class="typename">uintptr</span>(p) + offset))</div><div class="line">	fmt.Println(*ptr2x)</div><div class="line">	*ptr2x =<span class="number"> 100</span></div><div class="line">	fmt.Println(f.X())</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="更hack的方法">更hack的方法</h3>
<p>如果你还不满足，那么我再赠送一个更hack的方法，但是这个也有点限制，就是你腰调用的方法应该在之前的某处调用过。</p>
<p>这是 Alan Pierce 提供了一个方法。<a href="https://golang.org/src/runtime/symtab.go" target="_blank" rel="external">runtime/symtab.go</a>中保存了符号表，通过一些技巧(<code>go:linkname</code>),能访问它的私有方法，查找到想要调用的函数，然后就可以调用了，Alan将相关的代码写成了一个库，方便调用：<a href="https://github.com/alangpierce/go-forceexport" target="_blank" rel="external">go-forceexport</a>。</p>
<p>使用方法如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> timeNow <span class="keyword">func</span>() (<span class="typename">int64</span>, <span class="typename">int32</span>)</div><div class="line">err := forceexport.GetFunc(&timeNow, <span class="string">"time.now"</span>)</div><div class="line"><span class="keyword">if</span> err != <span class="constant">nil</span> {</div><div class="line">    <span class="comment">// Handle errors if you care about name possibly being invalid.</span></div><div class="line">}</div><div class="line"><span class="comment">// Calls the actual time.now function.</span></div><div class="line">sec, nsec := timeNow()</div></pre></td></tr></table></figure>

<p>我在使用的过程中发现只有相应的方法在某处调用过, 符号表中才有这个函数的信息， <code>forceexport.GetFunc</code>才会返回对应的函数。</p>
<p>另外，这是一个非常hack的方式，不保证Go将来的版本是否还能使用，仅供嬉戏之用，慎用在产品代码中。</p>
<h3 id="参考文档">参考文档</h3>
<ol>
<li><a href="https://golang.org/cmd/compile/" target="_blank" rel="external">https://golang.org/cmd/compile/</a></li>
<li><a href="https://github.com/golang/go/issues/15006" target="_blank" rel="external">https://github.com/golang/go/issues/15006</a></li>
<li><a href="https://siadat.github.io/post/golinkname" target="_blank" rel="external">https://siadat.github.io/post/golinkname</a></li>
<li><a href="https://sitano.github.io/2016/04/28/golang-private/" target="_blank" rel="external">https://sitano.github.io/2016/04/28/golang-private/</a></li>
<li><a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="external">https://golang.org/doc/go1.4#internalpackages</a></li>
<li><a href="http://www.alangpierce.com/blog/2016/03/17/adventures-in-go-accessing-unexported-functions/" target="_blank" rel="external">http://www.alangpierce.com/blog/2016/03/17/adventures-in-go-accessing-unexported-functions/</a></li>
<li><a href="https://groups.google.com/forum/#!topic/golang-nuts/ppGGazd9KXI" target="_blank" rel="external">https://groups.google.com/forum/#!topic/golang-nuts/ppGGazd9KXI</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>熟悉C++、Java、C#等面向对象的编程语言的同学，在学习Go语言的过程中，经常会被访问权限所困扰，逐渐才能了解这样一个事实：</p>
<p><strong> Go语言通过<code>identifier</code>的首字母是否大写来决定它是否可以被其它package所访问。</strong></p>
<p>正式的Go语言规范是这么规定的：</p>
<blockquote>
<p>An identifier may be exported to permit access to it from another package. An identifier is exported if both:</p>
<p>the first character of the identifier&#39;s name is a Unicode upper case letter (Unicode class &quot;Lu&quot;); and<br>the identifier is declared in the package block or it is a field name or method name.</p>
<p>All other identifiers are not exported.</p>
</blockquote>
<p>这个Go语言规范定义的访问权限控制方法。</p>
]]>
    
    </summary>
    
      <category term="Go" scheme="http://colobu.com/categories/Go/"/>
    
  </entry>
  
</feed>
